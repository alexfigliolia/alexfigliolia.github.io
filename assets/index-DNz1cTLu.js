var e=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,n=(n,a)=>{var o={};for(var s in n)t.call(n,s)&&a.indexOf(s)<0&&(o[s]=n[s]);if(null!=n&&e)for(var s of e(n))a.indexOf(s)<0&&r.call(n,s)&&(o[s]=n[s]);return o};import{r as a,j as o,q as s,t as i}from"./index-V6KHFFTR.js";import{O as l,L as u}from"./index-8y9kuNA2.js";import{R as h,u as m,a as c,W as d,H as f,C as p,S as v,U as x,V as g,N as M,b as _,L as S,c as D,d as T,B as y,e as B,M as w,f as U,g as b,P as j,h as R,i as F,j as E,k as C,D as k,l as P,m as A,_ as O,n as z,o as I}from"./index-DsY_2V6a.js";import{u as W,T as N,E as H}from"./Textures-N61V2vZp.js";import{P as L}from"./PerspectiveCamera-PT3-WYbM.js";const V=(()=>parseInt(h.replace(/\D+/g,"")))();function G(e){var t=e,{children:r,frames:o=1/0,resolution:s,near:i,far:l,envMap:u,fog:h}=t,v=n(t,["children","frames","resolution","near","far","envMap","fog"]);const x=a.useRef(null),{fbo:g,camera:M,update:_}=function({resolution:e=256,near:t=.1,far:r=1e3,envMap:n,fog:o}={}){const s=c((({gl:e})=>e)),i=c((({scene:e})=>e)),l=a.useMemo((()=>{const t=new d(e);return t.texture.type=f,t}),[e]);a.useEffect((()=>()=>{l.dispose()}),[l]);const u=a.useMemo((()=>new p(t,r,l)),[t,r,l]);let h,m;const v=a.useCallback((()=>{h=i.fog,m=i.background,i.background=n||m,i.fog=o||h,u.update(s,i),i.fog=h,i.background=m}),[s,i,u]);return{fbo:l,camera:u,update:v}}({resolution:s,near:i,far:l,envMap:u,fog:h});let S=0;return m((()=>{x.current&&(o===1/0||S<o)&&(x.current.visible=!1,_(),x.current.visible=!0,S++)})),a.createElement("group",v,a.createElement("primitive",{object:M}),a.createElement("group",{ref:x},null==r?void 0:r(g.texture)))}class $ extends v{constructor(e=new g){super({uniforms:{inputBuffer:new x(null),depthBuffer:new x(null),resolution:new x(new g),texelSize:new x(new g),halfTexelSize:new x(new g),kernel:new x(0),scale:new x(1),cameraNear:new x(0),cameraFar:new x(1),minDepthThreshold:new x(0),maxDepthThreshold:new x(1),depthScale:new x(0),depthToBlurRatioBias:new x(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${V>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:M,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class q{constructor({gl:e,resolution:t,width:r=500,height:n=500,minDepthThreshold:a=0,maxDepthThreshold:o=1,depthScale:s=0,depthToBlurRatioBias:i=.25}){this.renderToScreen=!1,this.renderTargetA=new _(t,t,{minFilter:S,magFilter:S,stencilBuffer:!1,depthBuffer:!1,type:f}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new $,this.convolutionMaterial.setTexelSize(1/r,1/n),this.convolutionMaterial.setResolution(new g(r,n)),this.scene=new D,this.camera=new T,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=o,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=i,this.convolutionMaterial.defines.USE_DEPTH=s>0;const l=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),h=new y;h.setAttribute("position",new B(l,3)),h.setAttribute("uv",new B(u,2)),this.screen=new w(h,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const n=this.scene,a=this.camera,o=this.renderTargetA,s=this.renderTargetB;let i=this.convolutionMaterial,l=i.uniforms;l.depthBuffer.value=t.depthTexture;const u=i.kernel;let h,m,c,d=t;for(m=0,c=u.length-1;m<c;++m)h=0==(1&m)?o:s,l.kernel.value=u[m],l.inputBuffer.value=d.texture,e.setRenderTarget(h),e.render(n,a),d=h;l.kernel.value=u[m],l.inputBuffer.value=d.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(n,a)}}let Z=class extends U{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}};const J=a.forwardRef(((e,t)=>{var r=e,{mixBlur:o=0,mixStrength:s=1,resolution:i=256,blur:l=[0,0],minDepthThreshold:u=.9,maxDepthThreshold:h=1,depthScale:d=0,depthToBlurRatioBias:p=.25,mirror:v=0,distortion:x=1,mixContrast:g=1,distortionMap:M,reflectorOffset:D=0}=r,T=n(r,["mixBlur","mixStrength","resolution","blur","minDepthThreshold","maxDepthThreshold","depthScale","depthToBlurRatioBias","mirror","distortion","mixContrast","distortionMap","reflectorOffset"]);b({MeshReflectorMaterialImpl:Z});const y=c((({gl:e})=>e)),B=c((({camera:e})=>e)),w=c((({scene:e})=>e)),U=(l=Array.isArray(l)?l:[l,l])[0]+l[1]>0,z=l[0],I=l[1],W=a.useRef(null);a.useImperativeHandle(t,(()=>W.current),[]);const[N]=a.useState((()=>new j)),[H]=a.useState((()=>new R)),[L]=a.useState((()=>new R)),[V]=a.useState((()=>new R)),[G]=a.useState((()=>new F)),[$]=a.useState((()=>new R(0,0,-1))),[J]=a.useState((()=>new E)),[K]=a.useState((()=>new R)),[Q]=a.useState((()=>new R)),[X]=a.useState((()=>new E)),[Y]=a.useState((()=>new F)),[ee]=a.useState((()=>new C)),te=a.useCallback((()=>{var e;const t=W.current.parent||(null==(e=W.current)||null==(e=e.__r3f.parent)?void 0:e.object);if(!t)return;if(L.setFromMatrixPosition(t.matrixWorld),V.setFromMatrixPosition(B.matrixWorld),G.extractRotation(t.matrixWorld),H.set(0,0,1),H.applyMatrix4(G),L.addScaledVector(H,D),K.subVectors(L,V),K.dot(H)>0)return;K.reflect(H).negate(),K.add(L),G.extractRotation(B.matrixWorld),$.set(0,0,-1),$.applyMatrix4(G),$.add(V),Q.subVectors(L,$),Q.reflect(H).negate(),Q.add(L),ee.position.copy(K),ee.up.set(0,1,0),ee.up.applyMatrix4(G),ee.up.reflect(H),ee.lookAt(Q),ee.far=B.far,ee.updateMatrixWorld(),ee.projectionMatrix.copy(B.projectionMatrix),Y.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),Y.multiply(ee.projectionMatrix),Y.multiply(ee.matrixWorldInverse),Y.multiply(t.matrixWorld),N.setFromNormalAndCoplanarPoint(H,L),N.applyMatrix4(ee.matrixWorldInverse),J.set(N.normal.x,N.normal.y,N.normal.z,N.constant);const r=ee.projectionMatrix;X.x=(Math.sign(J.x)+r.elements[8])/r.elements[0],X.y=(Math.sign(J.y)+r.elements[9])/r.elements[5],X.z=-1,X.w=(1+r.elements[10])/r.elements[14],J.multiplyScalar(2/J.dot(X)),r.elements[2]=J.x,r.elements[6]=J.y,r.elements[10]=J.z+1,r.elements[14]=J.w}),[B,D]),[re,ne,ae,oe]=a.useMemo((()=>{const e={minFilter:S,magFilter:S,type:f},t=new _(i,i,e);t.depthBuffer=!0,t.depthTexture=new k(i,i),t.depthTexture.format=P,t.depthTexture.type=A;const r=new _(i,i,e);return[t,r,new q({gl:y,resolution:i,width:z,height:I,minDepthThreshold:u,maxDepthThreshold:h,depthScale:d,depthToBlurRatioBias:p}),{mirror:v,textureMatrix:Y,mixBlur:o,tDiffuse:t.texture,tDepth:t.depthTexture,tDiffuseBlur:r.texture,hasBlur:U,mixStrength:s,minDepthThreshold:u,maxDepthThreshold:h,depthScale:d,depthToBlurRatioBias:p,distortion:x,distortionMap:M,mixContrast:g,"defines-USE_BLUR":U?"":void 0,"defines-USE_DEPTH":d>0?"":void 0,"defines-USE_DISTORTION":M?"":void 0}]}),[y,z,I,Y,i,v,U,o,s,u,h,d,p,x,M,g]);return m((()=>{var e;const t=W.current.parent||(null==(e=W.current)||null==(e=e.__r3f.parent)?void 0:e.object);if(!t)return;t.visible=!1;const r=y.xr.enabled,n=y.shadowMap.autoUpdate;te(),y.xr.enabled=!1,y.shadowMap.autoUpdate=!1,y.setRenderTarget(re),y.state.buffers.depth.setMask(!0),y.autoClear||y.clear(),y.render(w,ee),U&&ae.render(y,re,ne),y.xr.enabled=r,y.shadowMap.autoUpdate=n,t.visible=!0,y.setRenderTarget(null)})),a.createElement("meshReflectorMaterialImpl",O({attach:"material",key:"key"+oe["defines-USE_BLUR"]+oe["defines-USE_DEPTH"]+oe["defines-USE_DISTORTION"],ref:W},oe,T))})),K=({color:e})=>{const t=a.useRef(0),r=a.useRef(null),n=a.useRef(Q()),s=a.useMemo((()=>Math.random()),[]),i=a.useMemo((()=>Math.random()),[]),l=a.useMemo((()=>.5*Math.pow(Math.random(),2)+.05),[]);return m(((e,a)=>{if(t.current+=1.2*a,!r.current)return;const{x:o,y:l,z:u}=n.current,h=u-t.current;h<-10&&(n.current=Q(10*Math.random()+10),t.current=0),r.current.position.set(o,l,h),r.current.rotation.x+=s*a,r.current.rotation.y+=i*a})),o.jsxs("mesh",{castShadow:!0,ref:r,scale:l,children:[o.jsx("boxGeometry",{args:[1,1,1]}),o.jsx("meshStandardMaterial",{color:e,envMapIntensity:.15})]})};function Q(e=15*(2*Math.random()-1)){const t=new R(3*(2*Math.random()-1),Math.max(.5,2.5*Math.random()+.1),e);return t.x<0?t.x-=2.5:t.x>0&&(t.x+=2.5),t}const X=[.4,.1,.1],Y=[.05,.15,.4],ee=({total:e=100})=>{const t=a.useMemo((()=>new Array(e).fill(null)),[e]);return o.jsx(a.Fragment,{children:t.map(((e,t)=>o.jsx(K,{color:t%2==0?X:Y},t)))})};class te{static forEachMesh(e,t){e.traverse((e=>{this.isMesh(e)&&t(e)}))}static forEachMaterial(e,t){const r=Array.isArray(e)?e:[e];for(const n of r)t(n)}static isMesh(e){return e instanceof w}}const re="/assets/scene-niM4kucE.gltf",ne=["polySurface778","polySurface491","polySurface33","polySurface262"],ae=e=>{const{scene:t}=W(re),[r,n]=a.useState([]);return a.useEffect((()=>{const e=[];t.scale.set(110,110,110),t.position.set(0,0,0),te.forEachMesh(t,(t=>{t.castShadow=!0,t.receiveShadow=!0,te.forEachMaterial(t.material,(e=>{e.envMapIntensity=20})),t.name.includes("Wheel")&&!ne.some((e=>t.name.startsWith(e)))&&e.push(t)})),n(e)}),[t]),m((({clock:e})=>{const t=2*e.getElapsedTime();for(const n of r)n.rotation.x=t})),o.jsx("primitive",{object:t})};W.preload(re);const oe="/assets/grid-texture-eDqRcyO2.png",se=e=>{const t=a.useCallback((e=>{N.wrap(e).repeat(e,30).rerender(e),e.anisotropy=4}),[]),r=z(oe,t);return m((({clock:e})=>{r.offset.set(0,.68*-e.getElapsedTime())})),o.jsxs("mesh",{"rotation-x":.5*-Math.PI,position:[0,.015,0],children:[o.jsx("planeGeometry",{args:[35,35]}),o.jsx("meshBasicMaterial",{transparent:!0,map:r,alphaMap:r,opacity:.25,color:[1,1,1]})]})};z.preload(oe);const ie="/assets/ground-normal-C6tMtRR7.jpg",le="/assets/ground-roughness-3HiC32xa.jpg",ue=e=>{const t=a.useCallback((e=>N.wrap(e).repeat(e,5).colorless(e).rerender(e)),[]),r=a.useCallback((e=>N.wrap(e).repeat(e,5).rerender(e)),[]),n=z(ie,t),s=z(le,r);return m((({clock:e})=>{const t=-.128*e.getElapsedTime();n.offset.set(0,t),s.offset.set(0,t)})),o.jsxs("mesh",{castShadow:!0,receiveShadow:!0,"rotation-x":.5*-Math.PI,children:[o.jsx("planeGeometry",{args:[30,30]}),o.jsx(J,{dithering:!0,normalMap:n,roughnessMap:s,envMapIntensity:0,normalScale:[1,1],color:[.015,.015,.015],roughness:.7,blur:[1e3,400],mixBlur:30,mixStrength:80,mixContrast:1,resolution:1024,mirror:0,depthScale:.01,minDepthThreshold:.9,maxDepthThreshold:1,depthToBlurRatioBias:.25,reflectorOffset:.2})]})};z.preload([ie,le]);const he=new I(6,.16,.7).multiplyScalar(.5),me=new I(.1,.7,3).multiplyScalar(.5),ce=({total:e=14})=>{const t=a.useRef([]),r=a.useMemo((()=>[0,0,0]),[]),n=a.useMemo((()=>[0,0,0]),[]),s=a.useMemo((()=>[.5,.5,.5]),[]),i=a.useMemo((()=>[3.35,.05,16,100]),[]),l=a.useMemo((()=>new Array(e).fill(null)),[e]),u=a.useCallback((e=>r=>{t.current[e]=r}),[]);return m((({clock:r})=>{let n=-1;const a=r.getElapsedTime();for(const o of t.current){if(n++,!o)continue;const t=3.5*(n-e/2)+.4*a%3.5*2;o.position.set(0,0,-t);const r=Math.abs(t),s=1-.04*r;o.scale.set(s,s,s);const i=(n%2==0?me:he).clone();let l=1;r>2&&(l=1-(Math.min(12,r)-2)/10),l*=.5,i.multiplyScalar(l),te.forEachMaterial(o.material,(e=>{e.emissive=i}))}})),o.jsx(a.Fragment,{children:l.map(((e,t)=>{const a=u(t);return o.jsxs("mesh",{ref:a,castShadow:!0,receiveShadow:!0,position:n,children:[o.jsx("torusGeometry",{args:i}),o.jsx("meshStandardMaterial",{emissive:s,color:r})]},t)}))})},de=e=>{const t=c((e=>e.camera)),[r,n]=s(i),u=a.useMemo((()=>Math.max(r,n)),[r,n]);return a.useEffect((()=>{t.position.x=Math.max(5,50-u/20)}),[u,t]),o.jsxs(a.Fragment,{children:[o.jsx(l,{target:[0,.35,0],maxPolarAngle:1.45,maxZoom:-5,minDistance:5,maxDistance:50}),o.jsx(L,{makeDefault:!0,fov:50,position:[3,2,5]}),o.jsx("color",{args:[0,0,0],attach:"background"}),o.jsx("spotLight",{castShadow:!0,color:[1,.25,.7],intensity:10.5,angle:.6,decay:.5,penumbra:.5,position:[5,5,0],"shadow-bias":-1e-4}),o.jsx("spotLight",{castShadow:!0,color:[.14,.5,1],intensity:20,angle:.6,decay:.5,penumbra:.5,position:[-5,5,0],"shadow-bias":-1e-4}),o.jsx(G,{resolution:256,frames:1/0,children:e=>o.jsxs(a.Fragment,{children:[o.jsx(H,{map:e,environmentIntensity:15}),o.jsx(ae,{})]})}),o.jsx(ce,{}),o.jsx(ee,{}),o.jsx(se,{}),o.jsx(ue,{})]})},fe=e=>o.jsx(u,{children:o.jsx(de,{})});export{fe as CarScene};
//# sourceMappingURL=index-DNz1cTLu.js.map
