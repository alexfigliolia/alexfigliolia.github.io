{"version":3,"file":"threeStdLib-Js3c5gj8.js","sources":["../../node_modules/three-stdlib/_polyfill/constants.js","../../node_modules/three-stdlib/utils/BufferGeometryUtils.js","../../node_modules/three-stdlib/node_modules/fflate/esm/browser.js","../../node_modules/three-stdlib/objects/GroundProjectedEnv.js","../../node_modules/three-stdlib/controls/EventDispatcher.js","../../node_modules/three-stdlib/controls/OrbitControls.js","../../node_modules/three-stdlib/_polyfill/LoaderUtils.js","../../node_modules/three-stdlib/loaders/GLTFLoader.js","../../node_modules/three-stdlib/_polyfill/Data3DTexture.js","../../node_modules/three-stdlib/utils/WorkerPool.js","../../node_modules/three-stdlib/libs/ktx-parse.js","../../node_modules/three-stdlib/libs/zstddec.js","../../node_modules/three-stdlib/_polyfill/CompressedCubeTexture.js","../../node_modules/three-stdlib/_polyfill/CompressedArrayTexture.js","../../node_modules/three-stdlib/loaders/KTX2Loader.js","../../node_modules/three-stdlib/loaders/RGBELoader.js","../../node_modules/three-stdlib/loaders/EXRLoader.js","../../node_modules/three-stdlib/loaders/DRACOLoader.js","../../node_modules/three-stdlib/libs/MeshoptDecoder.js"],"sourcesContent":["import { REVISION } from \"three\";\nconst version = /* @__PURE__ */ (() => parseInt(REVISION.replace(/\\D+/g, \"\")))();\nexport {\n  version\n};\n//# sourceMappingURL=constants.js.map\n","import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n//# sourceMappingURL=BufferGeometryUtils.js.map\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst isCubeTexture = (def) => def && def.isCubeTexture;\nclass GroundProjectedEnv extends Mesh {\n  constructor(texture, options) {\n    var _a, _b;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [\n      isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n      `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n    ];\n    const vertexShader = (\n      /* glsl */\n      `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    );\n    const fragmentShader = defines.join(\"\\n\") + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n    const uniforms = {\n      map: { value: texture },\n      height: { value: (options == null ? void 0 : options.height) || 15 },\n      radius: { value: (options == null ? void 0 : options.radius) || 100 }\n    };\n    const geometry = new IcosahedronGeometry(1, 16);\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\nexport {\n  GroundProjectedEnv\n};\n//# sourceMappingURL=GroundProjectedEnv.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventDispatcher {\n  constructor() {\n    // not defined in @types/three\n    __publicField(this, \"_listeners\");\n  }\n  /**\n   * Adds a listener to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */\n  addEventListener(type, listener) {\n    if (this._listeners === void 0)\n      this._listeners = {};\n    const listeners = this._listeners;\n    if (listeners[type] === void 0) {\n      listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n  /**\n      * Checks if listener is added to an event type.\n      * @param type The type of event to listen to.\n      * @param listener The function that gets called when the event is fired.\n      */\n  hasEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return false;\n    const listeners = this._listeners;\n    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n  }\n  /**\n      * Removes a listener from an event type.\n      * @param type The type of the listener that gets removed.\n      * @param listener The listener function that gets removed.\n      */\n  removeEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n    if (listenerArray !== void 0) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n  /**\n      * Fire an event type.\n      * @param event The event that gets fired.\n      */\n  dispatchEvent(event) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n    if (listenerArray !== void 0) {\n      event.target = this;\n      const array = listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n      event.target = null;\n    }\n  }\n}\nexport {\n  EventDispatcher\n};\n//# sourceMappingURL=EventDispatcher.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, MOUSE, TOUCH, Quaternion, PerspectiveCamera, OrthographicCamera, Spherical, Vector2, Ray, Plane } from \"three\";\nimport { EventDispatcher } from \"./EventDispatcher.js\";\nconst _ray = /* @__PURE__ */ new Ray();\nconst _plane = /* @__PURE__ */ new Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;\nclass OrbitControls extends EventDispatcher {\n  constructor(object, domElement) {\n    super();\n    __publicField(this, \"object\");\n    __publicField(this, \"domElement\");\n    // Set to false to disable this control\n    __publicField(this, \"enabled\", true);\n    // \"target\" sets the location of focus, where the object orbits around\n    __publicField(this, \"target\", new Vector3());\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    __publicField(this, \"minDistance\", 0);\n    __publicField(this, \"maxDistance\", Infinity);\n    // How far you can zoom in and out ( OrthographicCamera only )\n    __publicField(this, \"minZoom\", 0);\n    __publicField(this, \"maxZoom\", Infinity);\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    __publicField(this, \"minPolarAngle\", 0);\n    // radians\n    __publicField(this, \"maxPolarAngle\", Math.PI);\n    // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    __publicField(this, \"minAzimuthAngle\", -Infinity);\n    // radians\n    __publicField(this, \"maxAzimuthAngle\", Infinity);\n    // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"enableDamping\", false);\n    __publicField(this, \"dampingFactor\", 0.05);\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    __publicField(this, \"enableZoom\", true);\n    __publicField(this, \"zoomSpeed\", 1);\n    // Set to false to disable rotating\n    __publicField(this, \"enableRotate\", true);\n    __publicField(this, \"rotateSpeed\", 1);\n    // Set to false to disable panning\n    __publicField(this, \"enablePan\", true);\n    __publicField(this, \"panSpeed\", 1);\n    __publicField(this, \"screenSpacePanning\", true);\n    // if false, pan orthogonal to world-space direction camera.up\n    __publicField(this, \"keyPanSpeed\", 7);\n    // pixels moved per arrow key push\n    __publicField(this, \"zoomToCursor\", false);\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"autoRotate\", false);\n    __publicField(this, \"autoRotateSpeed\", 2);\n    // 30 seconds per orbit when fps is 60\n    __publicField(this, \"reverseOrbit\", false);\n    // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n    __publicField(this, \"reverseHorizontalOrbit\", false);\n    // true if you want to reverse the horizontal orbit direction\n    __publicField(this, \"reverseVerticalOrbit\", false);\n    // true if you want to reverse the vertical orbit direction\n    // The four arrow keys\n    __publicField(this, \"keys\", { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" });\n    // Mouse buttons\n    __publicField(this, \"mouseButtons\", {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    });\n    // Touch fingers\n    __publicField(this, \"touches\", { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN });\n    __publicField(this, \"target0\");\n    __publicField(this, \"position0\");\n    __publicField(this, \"zoom0\");\n    // the target DOM element for key events\n    __publicField(this, \"_domElementKeyEvents\", null);\n    __publicField(this, \"getPolarAngle\");\n    __publicField(this, \"getAzimuthalAngle\");\n    __publicField(this, \"setPolarAngle\");\n    __publicField(this, \"setAzimuthalAngle\");\n    __publicField(this, \"getDistance\");\n    // Not used in most scenarios, however they can be useful for specific use cases\n    __publicField(this, \"getZoomScale\");\n    __publicField(this, \"listenToKeyEvents\");\n    __publicField(this, \"stopListenToKeyEvents\");\n    __publicField(this, \"saveState\");\n    __publicField(this, \"reset\");\n    __publicField(this, \"update\");\n    __publicField(this, \"connect\");\n    __publicField(this, \"dispose\");\n    // Dolly in programmatically\n    __publicField(this, \"dollyIn\");\n    // Dolly out programmatically\n    __publicField(this, \"dollyOut\");\n    // Get the current scale\n    __publicField(this, \"getScale\");\n    // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n    __publicField(this, \"setScale\");\n    this.object = object;\n    this.domElement = domElement;\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    this.getPolarAngle = () => spherical.phi;\n    this.getAzimuthalAngle = () => spherical.theta;\n    this.setPolarAngle = (value) => {\n      let phi = moduloWrapAround(value, 2 * Math.PI);\n      let currentPhi = spherical.phi;\n      if (currentPhi < 0)\n        currentPhi += 2 * Math.PI;\n      if (phi < 0)\n        phi += 2 * Math.PI;\n      let phiDist = Math.abs(phi - currentPhi);\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI;\n        } else {\n          currentPhi += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi;\n      scope.update();\n    };\n    this.setAzimuthalAngle = (value) => {\n      let theta = moduloWrapAround(value, 2 * Math.PI);\n      let currentTheta = spherical.theta;\n      if (currentTheta < 0)\n        currentTheta += 2 * Math.PI;\n      if (theta < 0)\n        theta += 2 * Math.PI;\n      let thetaDist = Math.abs(theta - currentTheta);\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI;\n        } else {\n          currentTheta += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta;\n      scope.update();\n    };\n    this.getDistance = () => scope.object.position.distanceTo(scope.target);\n    this.listenToKeyEvents = (domElement2) => {\n      domElement2.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement2;\n    };\n    this.stopListenToKeyEvents = () => {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = null;\n    };\n    this.saveState = () => {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n    this.reset = () => {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(changeEvent);\n      scope.update();\n      state = STATE.NONE;\n    };\n    this.update = (() => {\n      const offset = new Vector3();\n      const up = new Vector3(0, 1, 0);\n      const quat = new Quaternion().setFromUnitVectors(object.up, up);\n      const quatInverse = quat.clone().invert();\n      const lastPosition = new Vector3();\n      const lastQuaternion = new Quaternion();\n      const twoPI = 2 * Math.PI;\n      return function update() {\n        const position = scope.object.position;\n        quat.setFromUnitVectors(object.up, up);\n        quatInverse.copy(quat).invert();\n        offset.copy(position).sub(scope.target);\n        offset.applyQuaternion(quat);\n        spherical.setFromVector3(offset);\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI)\n            min += twoPI;\n          else if (min > Math.PI)\n            min -= twoPI;\n          if (max < -Math.PI)\n            max += twoPI;\n          else if (max > Math.PI)\n            max -= twoPI;\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n          }\n        }\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n        spherical.makeSafe();\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius);\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale);\n        }\n        offset.setFromSpherical(spherical);\n        offset.applyQuaternion(quatInverse);\n        position.copy(scope.target).add(offset);\n        if (!scope.object.matrixAutoUpdate)\n          scope.object.updateMatrix();\n        scope.object.lookAt(scope.target);\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n          panOffset.set(0, 0, 0);\n        }\n        let zoomChanged = false;\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null;\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            const prevRadius = offset.length();\n            newRadius = clampDistance(prevRadius * scale);\n            const radiusDelta = prevRadius - newRadius;\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n            scope.object.updateMatrixWorld();\n          } else if (scope.object.isOrthographicCamera) {\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0);\n            mouseBefore.unproject(scope.object);\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0);\n            mouseAfter.unproject(scope.object);\n            scope.object.position.sub(mouseAfter).add(mouseBefore);\n            scope.object.updateMatrixWorld();\n            newRadius = offset.length();\n          } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n            scope.zoomToCursor = false;\n          }\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n            } else {\n              _ray.origin.copy(scope.object.position);\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target);\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                _ray.intersectPlane(_plane, scope.target);\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1;\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n          }\n        }\n        scale = 1;\n        performCursorZoom = false;\n        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n          scope.dispatchEvent(changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n        return false;\n      };\n    })();\n    this.connect = (domElement2) => {\n      scope.domElement = domElement2;\n      scope.domElement.style.touchAction = \"none\";\n      scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n      scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n      scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n    };\n    this.dispose = () => {\n      var _a, _b, _c, _d, _e, _f;\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = \"auto\";\n      }\n      (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n      (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n      (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n      (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n      (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n      (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      }\n    };\n    const scope = this;\n    const changeEvent = { type: \"change\" };\n    const startEvent = { type: \"start\" };\n    const endEvent = { type: \"end\" };\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    let state = STATE.NONE;\n    const EPS = 1e-6;\n    const spherical = new Spherical();\n    const sphericalDelta = new Spherical();\n    let scale = 1;\n    const panOffset = new Vector3();\n    const rotateStart = new Vector2();\n    const rotateEnd = new Vector2();\n    const rotateDelta = new Vector2();\n    const panStart = new Vector2();\n    const panEnd = new Vector2();\n    const panDelta = new Vector2();\n    const dollyStart = new Vector2();\n    const dollyEnd = new Vector2();\n    const dollyDelta = new Vector2();\n    const dollyDirection = new Vector3();\n    const mouse = new Vector2();\n    let performCursorZoom = false;\n    const pointers = [];\n    const pointerPositions = {};\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function rotateLeft(angle) {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle;\n      } else {\n        sphericalDelta.theta -= angle;\n      }\n    }\n    function rotateUp(angle) {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle;\n      } else {\n        sphericalDelta.phi -= angle;\n      }\n    }\n    const panLeft = (() => {\n      const v = new Vector3();\n      return function panLeft2(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    })();\n    const panUp = (() => {\n      const v = new Vector3();\n      return function panUp2(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    })();\n    const pan = (() => {\n      const offset = new Vector3();\n      return function pan2(deltaX, deltaY) {\n        const element = scope.domElement;\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          panLeft(\n            deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix\n          );\n          panUp(\n            deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix\n          );\n        } else {\n          console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n          scope.enablePan = false;\n        }\n      };\n    })();\n    function setScale(newScale) {\n      if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale = newScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function dollyOut(dollyScale) {\n      setScale(scale / dollyScale);\n    }\n    function dollyIn(dollyScale) {\n      setScale(scale * dollyScale);\n    }\n    function updateMouseParameters(event) {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return;\n      }\n      performCursorZoom = true;\n      const rect = scope.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const w = rect.width;\n      const h = rect.height;\n      mouse.x = x / w * 2 - 1;\n      mouse.y = -(y / h) * 2 + 1;\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n    }\n    function clampDistance(dist) {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n    }\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownDolly(event) {\n      updateMouseParameters(event);\n      dollyStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseMoveRotate(event) {\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    }\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n      dollyStart.copy(dollyEnd);\n      scope.update();\n    }\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n      scope.update();\n    }\n    function handleMouseWheel(event) {\n      updateMouseParameters(event);\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n      scope.update();\n    }\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n      if (needsUpdate) {\n        event.preventDefault();\n        scope.update();\n      }\n    }\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        rotateStart.set(x, y);\n      }\n    }\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        panStart.set(x, y);\n      }\n    }\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enablePan)\n        handleTouchStartPan();\n    }\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enableRotate)\n        handleTouchStartRotate();\n    }\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        rotateEnd.set(x, y);\n      }\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n    }\n    function handleTouchMovePan(event) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        panEnd.set(x, y);\n      }\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyOut(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enablePan)\n        handleTouchMovePan(event);\n    }\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enableRotate)\n        handleTouchMoveRotate(event);\n    }\n    function onPointerDown(event) {\n      var _a, _b;\n      if (scope.enabled === false)\n        return;\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n      }\n      addPointer(event);\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n    function onPointerMove(event) {\n      if (scope.enabled === false)\n        return;\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n    function onPointerUp(event) {\n      var _a, _b, _c;\n      removePointer(event);\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n        (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      }\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n    function onMouseDown(event) {\n      let mouseAction;\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n        default:\n          mouseAction = -1;\n      }\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseDownDolly(event);\n          state = STATE.DOLLY;\n          break;\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          }\n          break;\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onMouseMove(event) {\n      if (scope.enabled === false)\n        return;\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleMouseMoveRotate(event);\n          break;\n        case STATE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseMoveDolly(event);\n          break;\n        case STATE.PAN:\n          if (scope.enablePan === false)\n            return;\n          handleMouseMovePan(event);\n          break;\n      }\n    }\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n        return;\n      }\n      event.preventDefault();\n      scope.dispatchEvent(startEvent);\n      handleMouseWheel(event);\n      scope.dispatchEvent(endEvent);\n    }\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false)\n        return;\n      handleKeyDown(event);\n    }\n    function onTouchStart(event) {\n      trackPointer(event);\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false)\n                return;\n              handleTouchStartRotate();\n              state = STATE.TOUCH_ROTATE;\n              break;\n            case TOUCH.PAN:\n              if (scope.enablePan === false)\n                return;\n              handleTouchStartPan();\n              state = STATE.TOUCH_PAN;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false)\n                return;\n              handleTouchStartDollyPan();\n              state = STATE.TOUCH_DOLLY_PAN;\n              break;\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false)\n                return;\n              handleTouchStartDollyRotate();\n              state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onTouchMove(event) {\n      trackPointer(event);\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleTouchMoveRotate(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false)\n            return;\n          handleTouchMovePan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false)\n            return;\n          handleTouchMoveDollyPan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false)\n            return;\n          handleTouchMoveDollyRotate(event);\n          scope.update();\n          break;\n        default:\n          state = STATE.NONE;\n      }\n    }\n    function onContextMenu(event) {\n      if (scope.enabled === false)\n        return;\n      event.preventDefault();\n    }\n    function addPointer(event) {\n      pointers.push(event);\n    }\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n      if (position === void 0) {\n        position = new Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n      position.set(event.pageX, event.pageY);\n    }\n    function getSecondPointerPosition(event) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n      return pointerPositions[pointer.pointerId];\n    }\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale);\n      scope.update();\n    };\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n      dollyOut(dollyScale);\n      scope.update();\n    };\n    this.getScale = () => {\n      return scale;\n    };\n    this.setScale = (newScale) => {\n      setScale(newScale);\n      scope.update();\n    };\n    this.getZoomScale = () => {\n      return getZoomScale();\n    };\n    if (domElement !== void 0)\n      this.connect(domElement);\n    this.update();\n  }\n}\nclass MapControls extends OrbitControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n    this.screenSpacePanning = false;\n    this.mouseButtons.LEFT = MOUSE.PAN;\n    this.mouseButtons.RIGHT = MOUSE.ROTATE;\n    this.touches.ONE = TOUCH.PAN;\n    this.touches.TWO = TOUCH.DOLLY_ROTATE;\n  }\n}\nexport {\n  MapControls,\n  OrbitControls\n};\n//# sourceMappingURL=OrbitControls.js.map\n","function decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  try {\n    return decodeURIComponent(escape(s));\n  } catch (e) {\n    return s;\n  }\n}\nexport {\n  decodeText\n};\n//# sourceMappingURL=LoaderUtils.js.map\n","import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, MeshPhysicalMaterial, Vector2, Matrix4, Vector3, Quaternion, InstancedMesh, InstancedBufferAttribute, Object3D, TextureLoader, ImageBitmapLoader, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, TriangleStripDrawMode, TriangleFanDrawMode, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, Skeleton, AnimationClip, Bone, InterpolateLinear, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, VectorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack, Box3, Sphere, Interpolant } from \"three\";\nimport { toTrianglesDrawMode } from \"../utils/BufferGeometryUtils.js\";\nimport { version } from \"../_polyfill/constants.js\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = LoaderUtils.extractUrlBase(url);\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name)\n        console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(16777215);\n    if (lightDef.color !== void 0)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace\n    );\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new Matrix4();\n        const p = new Vector3();\n        const q = new Quaternion();\n        const s = new Vector3(1, 1, 1);\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = /* @__PURE__ */ new Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = /* @__PURE__ */ new Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\")\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = colorSpace;\n        else\n          texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace\n      );\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nexport {\n  GLTFLoader\n};\n//# sourceMappingURL=GLTFLoader.js.map\n","import { Texture, NearestFilter, ClampToEdgeWrapping } from \"three\";\nclass Data3DTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.isData3DTexture = true;\n    this.image = { data, width, height, depth };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n  }\n}\nexport {\n  Data3DTexture\n};\n//# sourceMappingURL=Data3DTexture.js.map\n","class WorkerPool {\n  constructor(pool = 4) {\n    this.pool = pool;\n    this.queue = [];\n    this.workers = [];\n    this.workersResolve = [];\n    this.workerStatus = 0;\n  }\n  _initWorker(workerId) {\n    if (!this.workers[workerId]) {\n      const worker = this.workerCreator();\n      worker.addEventListener(\"message\", this._onMessage.bind(this, workerId));\n      this.workers[workerId] = worker;\n    }\n  }\n  _getIdleWorker() {\n    for (let i = 0; i < this.pool; i++)\n      if (!(this.workerStatus & 1 << i))\n        return i;\n    return -1;\n  }\n  _onMessage(workerId, msg) {\n    const resolve = this.workersResolve[workerId];\n    resolve && resolve(msg);\n    if (this.queue.length) {\n      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();\n      this.workersResolve[workerId] = resolve2;\n      this.workers[workerId].postMessage(msg2, transfer);\n    } else {\n      this.workerStatus ^= 1 << workerId;\n    }\n  }\n  setWorkerCreator(workerCreator) {\n    this.workerCreator = workerCreator;\n  }\n  setWorkerLimit(pool) {\n    this.pool = pool;\n  }\n  postMessage(msg, transfer) {\n    return new Promise((resolve) => {\n      const workerId = this._getIdleWorker();\n      if (workerId !== -1) {\n        this._initWorker(workerId);\n        this.workerStatus |= 1 << workerId;\n        this.workersResolve[workerId] = resolve;\n        this.workers[workerId].postMessage(msg, transfer);\n      } else {\n        this.queue.push({ resolve, msg, transfer });\n      }\n    });\n  }\n  dispose() {\n    this.workers.forEach((worker) => worker.terminate());\n    this.workersResolve.length = 0;\n    this.workers.length = 0;\n    this.queue.length = 0;\n    this.workerStatus = 0;\n  }\n}\nexport {\n  WorkerPool\n};\n//# sourceMappingURL=WorkerPool.js.map\n","const KHR_SUPERCOMPRESSION_NONE = 0;\nconst KHR_SUPERCOMPRESSION_ZSTD = 2;\nconst KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;\nconst KHR_DF_VENDORID_KHRONOS = 0;\nconst KHR_DF_VERSION = 2;\nconst KHR_DF_MODEL_UNSPECIFIED = 0;\nconst KHR_DF_FLAG_ALPHA_STRAIGHT = 0;\nconst KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1;\nconst KHR_DF_TRANSFER_SRGB = 2;\nconst KHR_DF_PRIMARIES_UNSPECIFIED = 0;\nconst KHR_DF_PRIMARIES_BT709 = 1;\nconst KHR_DF_PRIMARIES_DISPLAYP3 = 10;\nconst KHR_DF_SAMPLE_DATATYPE_SIGNED = 64;\nconst VK_FORMAT_UNDEFINED = 0;\nconst VK_FORMAT_R8_UNORM = 9;\nconst VK_FORMAT_R8_SRGB = 15;\nconst VK_FORMAT_R8G8_UNORM = 16;\nconst VK_FORMAT_R8G8_SRGB = 22;\nconst VK_FORMAT_R8G8B8A8_UNORM = 37;\nconst VK_FORMAT_R8G8B8A8_SRGB = 43;\nconst VK_FORMAT_R16_SFLOAT = 76;\nconst VK_FORMAT_R16G16_SFLOAT = 83;\nconst VK_FORMAT_R16G16B16A16_SFLOAT = 97;\nconst VK_FORMAT_R32_SFLOAT = 100;\nconst VK_FORMAT_R32G32_SFLOAT = 103;\nconst VK_FORMAT_R32G32B32A32_SFLOAT = 109;\nconst VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165;\nconst VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166;\nclass KTX2Container {\n  constructor() {\n    this.vkFormat = VK_FORMAT_UNDEFINED;\n    this.typeSize = 1;\n    this.pixelWidth = 0;\n    this.pixelHeight = 0;\n    this.pixelDepth = 0;\n    this.layerCount = 0;\n    this.faceCount = 1;\n    this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE;\n    this.levels = [];\n    this.dataFormatDescriptor = [\n      {\n        vendorId: KHR_DF_VENDORID_KHRONOS,\n        descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n        descriptorBlockSize: 0,\n        versionNumber: KHR_DF_VERSION,\n        colorModel: KHR_DF_MODEL_UNSPECIFIED,\n        colorPrimaries: KHR_DF_PRIMARIES_BT709,\n        transferFunction: KHR_DF_TRANSFER_SRGB,\n        flags: KHR_DF_FLAG_ALPHA_STRAIGHT,\n        texelBlockDimension: [0, 0, 0, 0],\n        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],\n        samples: []\n      }\n    ];\n    this.keyValue = {};\n    this.globalData = null;\n  }\n}\nclass BufferReader {\n  constructor(data, byteOffset, byteLength, littleEndian) {\n    this._dataView = void 0;\n    this._littleEndian = void 0;\n    this._offset = void 0;\n    this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n    this._littleEndian = littleEndian;\n    this._offset = 0;\n  }\n  _nextUint8() {\n    const value = this._dataView.getUint8(this._offset);\n    this._offset += 1;\n    return value;\n  }\n  _nextUint16() {\n    const value = this._dataView.getUint16(this._offset, this._littleEndian);\n    this._offset += 2;\n    return value;\n  }\n  _nextUint32() {\n    const value = this._dataView.getUint32(this._offset, this._littleEndian);\n    this._offset += 4;\n    return value;\n  }\n  _nextUint64() {\n    const left = this._dataView.getUint32(this._offset, this._littleEndian);\n    const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n    const value = left + 2 ** 32 * right;\n    this._offset += 8;\n    return value;\n  }\n  _nextInt32() {\n    const value = this._dataView.getInt32(this._offset, this._littleEndian);\n    this._offset += 4;\n    return value;\n  }\n  _nextUint8Array(len) {\n    const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len);\n    this._offset += len;\n    return value;\n  }\n  _skip(bytes) {\n    this._offset += bytes;\n    return this;\n  }\n  _scan(maxByteLength, term) {\n    if (term === void 0) {\n      term = 0;\n    }\n    const byteOffset = this._offset;\n    let byteLength = 0;\n    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n      byteLength++;\n      this._offset++;\n    }\n    if (byteLength < maxByteLength)\n      this._offset++;\n    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);\n  }\n}\nconst KTX2_ID = [\n  // '', 'K', 'T', 'X', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\n  171,\n  75,\n  84,\n  88,\n  32,\n  50,\n  48,\n  187,\n  13,\n  10,\n  26,\n  10\n];\nfunction decodeText(buffer) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(buffer);\n  }\n  return Buffer.from(buffer).toString(\"utf8\");\n}\nfunction read(data) {\n  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n  if (id[0] !== KTX2_ID[0] || // ''\n  id[1] !== KTX2_ID[1] || // 'K'\n  id[2] !== KTX2_ID[2] || // 'T'\n  id[3] !== KTX2_ID[3] || // 'X'\n  id[4] !== KTX2_ID[4] || // ' '\n  id[5] !== KTX2_ID[5] || // '2'\n  id[6] !== KTX2_ID[6] || // '0'\n  id[7] !== KTX2_ID[7] || // ''\n  id[8] !== KTX2_ID[8] || // '\\r'\n  id[9] !== KTX2_ID[9] || // '\\n'\n  id[10] !== KTX2_ID[10] || // '\\x1A'\n  id[11] !== KTX2_ID[11]) {\n    throw new Error(\"Missing KTX 2.0 identifier.\");\n  }\n  const container = new KTX2Container();\n  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n  container.vkFormat = headerReader._nextUint32();\n  container.typeSize = headerReader._nextUint32();\n  container.pixelWidth = headerReader._nextUint32();\n  container.pixelHeight = headerReader._nextUint32();\n  container.pixelDepth = headerReader._nextUint32();\n  container.layerCount = headerReader._nextUint32();\n  container.faceCount = headerReader._nextUint32();\n  const levelCount = headerReader._nextUint32();\n  container.supercompressionScheme = headerReader._nextUint32();\n  const dfdByteOffset = headerReader._nextUint32();\n  const dfdByteLength = headerReader._nextUint32();\n  const kvdByteOffset = headerReader._nextUint32();\n  const kvdByteLength = headerReader._nextUint32();\n  const sgdByteOffset = headerReader._nextUint64();\n  const sgdByteLength = headerReader._nextUint64();\n  const levelByteLength = levelCount * 3 * 8;\n  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n  for (let i = 0; i < levelCount; i++) {\n    container.levels.push({\n      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n      uncompressedByteLength: levelReader._nextUint64()\n    });\n  }\n  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n  const dfd = {\n    vendorId: dfdReader._skip(\n      4\n      /* totalSize */\n    )._nextUint16(),\n    descriptorType: dfdReader._nextUint16(),\n    versionNumber: dfdReader._nextUint16(),\n    descriptorBlockSize: dfdReader._nextUint16(),\n    colorModel: dfdReader._nextUint8(),\n    colorPrimaries: dfdReader._nextUint8(),\n    transferFunction: dfdReader._nextUint8(),\n    flags: dfdReader._nextUint8(),\n    texelBlockDimension: [\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8()\n    ],\n    bytesPlane: [\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8(),\n      dfdReader._nextUint8()\n    ],\n    samples: []\n  };\n  const sampleStart = 6;\n  const sampleWords = 4;\n  const numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n  for (let i = 0; i < numSamples; i++) {\n    const sample = {\n      bitOffset: dfdReader._nextUint16(),\n      bitLength: dfdReader._nextUint8(),\n      channelType: dfdReader._nextUint8(),\n      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],\n      sampleLower: -Infinity,\n      sampleUpper: Infinity\n    };\n    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n      sample.sampleLower = dfdReader._nextInt32();\n      sample.sampleUpper = dfdReader._nextInt32();\n    } else {\n      sample.sampleLower = dfdReader._nextUint32();\n      sample.sampleUpper = dfdReader._nextUint32();\n    }\n    dfd.samples[i] = sample;\n  }\n  container.dataFormatDescriptor.length = 0;\n  container.dataFormatDescriptor.push(dfd);\n  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n  while (kvdReader._offset < kvdByteLength) {\n    const keyValueByteLength = kvdReader._nextUint32();\n    const keyData = kvdReader._scan(keyValueByteLength);\n    const key = decodeText(keyData);\n    container.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);\n    if (key.match(/^ktx/i)) {\n      const text = decodeText(container.keyValue[key]);\n      container.keyValue[key] = text.substring(0, text.lastIndexOf(\"\\0\"));\n    }\n    const kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0;\n    kvdReader._skip(kvPadding);\n  }\n  if (sgdByteLength <= 0)\n    return container;\n  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n  const endpointCount = sgdReader._nextUint16();\n  const selectorCount = sgdReader._nextUint16();\n  const endpointsByteLength = sgdReader._nextUint32();\n  const selectorsByteLength = sgdReader._nextUint32();\n  const tablesByteLength = sgdReader._nextUint32();\n  const extendedByteLength = sgdReader._nextUint32();\n  const imageDescs = [];\n  for (let i = 0; i < levelCount; i++) {\n    imageDescs.push({\n      imageFlags: sgdReader._nextUint32(),\n      rgbSliceByteOffset: sgdReader._nextUint32(),\n      rgbSliceByteLength: sgdReader._nextUint32(),\n      alphaSliceByteOffset: sgdReader._nextUint32(),\n      alphaSliceByteLength: sgdReader._nextUint32()\n    });\n  }\n  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n  const extendedByteOffset = tablesByteOffset + tablesByteLength;\n  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n  container.globalData = {\n    endpointCount,\n    selectorCount,\n    imageDescs,\n    endpointsData,\n    selectorsData,\n    tablesData,\n    extendedData\n  };\n  return container;\n}\nexport {\n  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,\n  KHR_DF_FLAG_ALPHA_STRAIGHT,\n  KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n  KHR_DF_MODEL_UNSPECIFIED,\n  KHR_DF_PRIMARIES_BT709,\n  KHR_DF_PRIMARIES_DISPLAYP3,\n  KHR_DF_PRIMARIES_UNSPECIFIED,\n  KHR_DF_SAMPLE_DATATYPE_SIGNED,\n  KHR_DF_TRANSFER_SRGB,\n  KHR_DF_VENDORID_KHRONOS,\n  KHR_DF_VERSION,\n  KHR_SUPERCOMPRESSION_NONE,\n  KHR_SUPERCOMPRESSION_ZSTD,\n  KTX2Container,\n  VK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n  VK_FORMAT_R16G16B16A16_SFLOAT,\n  VK_FORMAT_R16G16_SFLOAT,\n  VK_FORMAT_R16_SFLOAT,\n  VK_FORMAT_R32G32B32A32_SFLOAT,\n  VK_FORMAT_R32G32_SFLOAT,\n  VK_FORMAT_R32_SFLOAT,\n  VK_FORMAT_R8G8B8A8_SRGB,\n  VK_FORMAT_R8G8B8A8_UNORM,\n  VK_FORMAT_R8G8_SRGB,\n  VK_FORMAT_R8G8_UNORM,\n  VK_FORMAT_R8_SRGB,\n  VK_FORMAT_R8_UNORM,\n  VK_FORMAT_UNDEFINED,\n  read\n};\n//# sourceMappingURL=ktx-parse.js.map\n","let init;\nlet instance;\nlet heap;\nconst IMPORT_OBJECT = {\n  env: {\n    emscripten_notify_memory_growth: function(index) {\n      heap = new Uint8Array(instance.exports.memory.buffer);\n    }\n  }\n};\nclass ZSTDDecoder {\n  init() {\n    if (init)\n      return init;\n    if (typeof fetch !== \"undefined\") {\n      init = fetch(\"data:application/wasm;base64,\" + wasm).then((response) => response.arrayBuffer()).then((arrayBuffer) => WebAssembly.instantiate(arrayBuffer, IMPORT_OBJECT)).then(this._init);\n    } else {\n      init = WebAssembly.instantiate(Buffer.from(wasm, \"base64\"), IMPORT_OBJECT).then(this._init);\n    }\n    return init;\n  }\n  _init(result) {\n    instance = result.instance;\n    IMPORT_OBJECT.env.emscripten_notify_memory_growth(0);\n  }\n  decode(array, uncompressedSize = 0) {\n    if (!instance)\n      throw new Error(`ZSTDDecoder: Await .init() before decoding.`);\n    const compressedSize = array.byteLength;\n    const compressedPtr = instance.exports.malloc(compressedSize);\n    heap.set(array, compressedPtr);\n    uncompressedSize = uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));\n    const uncompressedPtr = instance.exports.malloc(uncompressedSize);\n    const actualSize = instance.exports.ZSTD_decompress(\n      uncompressedPtr,\n      uncompressedSize,\n      compressedPtr,\n      compressedSize\n    );\n    const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize);\n    instance.exports.free(compressedPtr);\n    instance.exports.free(uncompressedPtr);\n    return dec;\n  }\n}\nconst wasm = \"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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ\";\nexport {\n  ZSTDDecoder\n};\n//# sourceMappingURL=zstddec.js.map\n","import { CompressedTexture, CubeReflectionMapping } from \"three\";\nclass CompressedCubeTexture extends CompressedTexture {\n  constructor(images, format, type) {\n    super(void 0, images[0].width, images[0].height, format, type, CubeReflectionMapping);\n    this.isCompressedCubeTexture = true;\n    this.isCubeTexture = true;\n    this.image = images;\n  }\n}\nexport {\n  CompressedCubeTexture\n};\n//# sourceMappingURL=CompressedCubeTexture.js.map\n","import { CompressedTexture, ClampToEdgeWrapping } from \"three\";\nclass CompressedArrayTexture extends CompressedTexture {\n  constructor(mipmaps, width, height, depth, format, type) {\n    super(mipmaps, width, height, format, type);\n    this.isCompressedArrayTexture = true;\n    this.image.depth = depth;\n    this.wrapR = ClampToEdgeWrapping;\n  }\n}\nexport {\n  CompressedArrayTexture\n};\n//# sourceMappingURL=CompressedArrayTexture.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, UnsignedByteType, CompressedTexture, LinearFilter, LinearMipmapLinearFilter, FloatType, HalfFloatType, DataTexture, RGFormat, RedFormat, RGBA_ASTC_6x6_Format } from \"three\";\nimport { WorkerPool } from \"../utils/WorkerPool.js\";\nimport { KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_ZSTD, KHR_SUPERCOMPRESSION_NONE, KHR_DF_PRIMARIES_BT709, KHR_DF_TRANSFER_SRGB, KHR_DF_PRIMARIES_DISPLAYP3, KHR_DF_PRIMARIES_UNSPECIFIED, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK } from \"../libs/ktx-parse.js\";\nimport { ZSTDDecoder } from \"../libs/zstddec.js\";\nimport { CompressedCubeTexture } from \"../_polyfill/CompressedCubeTexture.js\";\nimport { CompressedArrayTexture } from \"../_polyfill/CompressedArrayTexture.js\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nconst LinearEncoding = 3e3;\nconst sRGBEncoding = 3001;\nconst NoColorSpace = \"\";\nconst DisplayP3ColorSpace = \"display-p3\";\nconst LinearDisplayP3ColorSpace = \"display-p3-linear\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst SRGBColorSpace = \"srgb\";\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nlet _activeLoaders = 0;\nlet _zstd;\nconst KTX2Loader = /* @__PURE__ */ (() => {\n  const _KTX2Loader = class extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.transcoderPath = \"\";\n      this.transcoderBinary = null;\n      this.transcoderPending = null;\n      this.workerPool = new WorkerPool();\n      this.workerSourceURL = \"\";\n      this.workerConfig = null;\n      if (typeof MSC_TRANSCODER !== \"undefined\") {\n        console.warn(\n          'THREE.KTX2Loader: Please update to latest \"basis_transcoder\". \"msc_basis_transcoder\" is no longer supported in three.js r125+.'\n        );\n      }\n    }\n    setTranscoderPath(path) {\n      this.transcoderPath = path;\n      return this;\n    }\n    setWorkerLimit(num) {\n      this.workerPool.setWorkerLimit(num);\n      return this;\n    }\n    detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n        etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n        etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n        dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n        bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n        pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n      };\n      if (renderer.capabilities.isWebGL2) {\n        this.workerConfig.etc1Supported = false;\n      }\n      return this;\n    }\n    init() {\n      if (!this.transcoderPending) {\n        const jsLoader = new FileLoader(this.manager);\n        jsLoader.setPath(this.transcoderPath);\n        jsLoader.setWithCredentials(this.withCredentials);\n        const jsContent = jsLoader.loadAsync(\"basis_transcoder.js\");\n        const binaryLoader = new FileLoader(this.manager);\n        binaryLoader.setPath(this.transcoderPath);\n        binaryLoader.setResponseType(\"arraybuffer\");\n        binaryLoader.setWithCredentials(this.withCredentials);\n        const binaryContent = binaryLoader.loadAsync(\"basis_transcoder.wasm\");\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n          const fn = _KTX2Loader.BasisWorker.toString();\n          const body = [\n            \"/* constants */\",\n            \"let _EngineFormat = \" + JSON.stringify(_KTX2Loader.EngineFormat),\n            \"let _TranscoderFormat = \" + JSON.stringify(_KTX2Loader.TranscoderFormat),\n            \"let _BasisFormat = \" + JSON.stringify(_KTX2Loader.BasisFormat),\n            \"/* basis_transcoder.js */\",\n            jsContent2,\n            \"/* worker */\",\n            fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n          ].join(\"\\n\");\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n          this.transcoderBinary = binaryContent2;\n          this.workerPool.setWorkerCreator(() => {\n            const worker = new Worker(this.workerSourceURL);\n            const transcoderBinary = this.transcoderBinary.slice(0);\n            worker.postMessage({ type: \"init\", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);\n            return worker;\n          });\n        });\n        if (_activeLoaders > 0) {\n          console.warn(\n            \"THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.\"\n          );\n        }\n        _activeLoaders++;\n      }\n      return this.transcoderPending;\n    }\n    load(url, onLoad, onProgress, onError) {\n      if (this.workerConfig === null) {\n        throw new Error(\"THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.\");\n      }\n      const loader = new FileLoader(this.manager);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(\n        url,\n        (buffer) => {\n          if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            return cachedTask.promise.then(onLoad).catch(onError);\n          }\n          this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);\n        },\n        onProgress,\n        onError\n      );\n    }\n    _createTextureFrom(transcodeResult, container) {\n      const { faces, width, height, format, type, error, dfdFlags } = transcodeResult;\n      if (type === \"error\")\n        return Promise.reject(error);\n      let texture;\n      if (container.faceCount === 6) {\n        texture = new CompressedCubeTexture(faces, format, UnsignedByteType);\n      } else {\n        const mipmaps = faces[0].mipmaps;\n        texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      }\n      texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      const colorSpace = parseColorSpace(container);\n      if (\"colorSpace\" in texture)\n        texture.colorSpace = colorSpace;\n      else\n        texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\n      return texture;\n    }\n    /**\n     * @param {ArrayBuffer} buffer\n     * @param {object?} config\n     * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n     */\n    async _createTexture(buffer, config = {}) {\n      const container = read(new Uint8Array(buffer));\n      if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n        return createRawTexture(container);\n      }\n      const taskConfig = config;\n      const texturePending = this.init().then(() => {\n        return this.workerPool.postMessage({ type: \"transcode\", buffer, taskConfig }, [buffer]);\n      }).then((e) => this._createTextureFrom(e.data, container));\n      _taskCache.set(buffer, { promise: texturePending });\n      return texturePending;\n    }\n    dispose() {\n      this.workerPool.dispose();\n      if (this.workerSourceURL)\n        URL.revokeObjectURL(this.workerSourceURL);\n      _activeLoaders--;\n      return this;\n    }\n  };\n  let KTX2Loader2 = _KTX2Loader;\n  /* CONSTANTS */\n  __publicField(KTX2Loader2, \"BasisFormat\", {\n    ETC1S: 0,\n    UASTC_4x4: 1\n  });\n  __publicField(KTX2Loader2, \"TranscoderFormat\", {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16\n  });\n  __publicField(KTX2Loader2, \"EngineFormat\", {\n    RGBAFormat,\n    RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format,\n    RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format\n  });\n  /* WEB WORKER */\n  __publicField(KTX2Loader2, \"BasisWorker\", function() {\n    let config;\n    let transcoderPending;\n    let BasisModule;\n    const EngineFormat = _EngineFormat;\n    const TranscoderFormat = _TranscoderFormat;\n    const BasisFormat = _BasisFormat;\n    self.addEventListener(\"message\", function(e) {\n      const message = e.data;\n      switch (message.type) {\n        case \"init\":\n          config = message.config;\n          init(message.transcoderBinary);\n          break;\n        case \"transcode\":\n          transcoderPending.then(() => {\n            try {\n              const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode(message.buffer);\n              self.postMessage(\n                { type: \"transcode\", id: message.id, faces, width, height, hasAlpha, format, dfdFlags },\n                buffers\n              );\n            } catch (error) {\n              console.error(error);\n              self.postMessage({ type: \"error\", id: message.id, error: error.message });\n            }\n          });\n          break;\n      }\n    });\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve };\n        BASIS(BasisModule);\n      }).then(() => {\n        BasisModule.initializeBasis();\n        if (BasisModule.KTX2File === void 0) {\n          console.warn(\"THREE.KTX2Loader: Please update Basis Universal transcoder.\");\n        }\n      });\n    }\n    function transcode(buffer) {\n      const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n      function cleanup() {\n        ktx2File.close();\n        ktx2File.delete();\n      }\n      if (!ktx2File.isValid()) {\n        cleanup();\n        throw new Error(\"THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file\");\n      }\n      const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n      const width = ktx2File.getWidth();\n      const height = ktx2File.getHeight();\n      const layerCount = ktx2File.getLayers() || 1;\n      const levelCount = ktx2File.getLevels();\n      const faceCount = ktx2File.getFaces();\n      const hasAlpha = ktx2File.getHasAlpha();\n      const dfdFlags = ktx2File.getDFDFlags();\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n      if (!width || !height || !levelCount) {\n        cleanup();\n        throw new Error(\"THREE.KTX2Loader:\tInvalid texture\");\n      }\n      if (!ktx2File.startTranscoding()) {\n        cleanup();\n        throw new Error(\"THREE.KTX2Loader: .startTranscoding failed\");\n      }\n      const faces = [];\n      const buffers = [];\n      for (let face = 0; face < faceCount; face++) {\n        const mipmaps = [];\n        for (let mip = 0; mip < levelCount; mip++) {\n          const layerMips = [];\n          let mipWidth, mipHeight;\n          for (let layer = 0; layer < layerCount; layer++) {\n            const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);\n            if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {\n              console.warn(\"THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.\");\n            }\n            if (levelCount > 1) {\n              mipWidth = levelInfo.origWidth;\n              mipHeight = levelInfo.origHeight;\n            } else {\n              mipWidth = levelInfo.width;\n              mipHeight = levelInfo.height;\n            }\n            const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));\n            const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);\n            if (!status) {\n              cleanup();\n              throw new Error(\"THREE.KTX2Loader: .transcodeImage failed.\");\n            }\n            layerMips.push(dst);\n          }\n          const mipData = concat(layerMips);\n          mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });\n          buffers.push(mipData.buffer);\n        }\n        faces.push({ mipmaps, width, height, format: engineFormat });\n      }\n      cleanup();\n      return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags };\n    }\n    const FORMAT_OPTIONS = [\n      {\n        if: \"astcSupported\",\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false\n      },\n      {\n        if: \"bptcSupported\",\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false\n      },\n      {\n        if: \"dxtSupported\",\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false\n      },\n      {\n        if: \"etc2Supported\",\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false\n      },\n      {\n        if: \"etc1Supported\",\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false\n      },\n      {\n        if: \"pvrtcSupported\",\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true\n      }\n    ];\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {\n      return a.priorityETC1S - b.priorityETC1S;\n    });\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {\n      return a.priorityUASTC - b.priorityUASTC;\n    });\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat;\n      let engineFormat;\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i];\n        if (!config[opt.if])\n          continue;\n        if (!opt.basisFormat.includes(basisFormat))\n          continue;\n        if (hasAlpha && opt.transcoderFormat.length < 2)\n          continue;\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))\n          continue;\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n        return { transcoderFormat, engineFormat };\n      }\n      console.warn(\"THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.\");\n      transcoderFormat = TranscoderFormat.RGBA32;\n      engineFormat = EngineFormat.RGBAFormat;\n      return { transcoderFormat, engineFormat };\n    }\n    function isPowerOfTwo(value) {\n      if (value <= 2)\n        return true;\n      return (value & value - 1) === 0 && value !== 0;\n    }\n    function concat(arrays) {\n      if (arrays.length === 1)\n        return arrays[0];\n      let totalByteLength = 0;\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i];\n        totalByteLength += array.byteLength;\n      }\n      const result = new Uint8Array(totalByteLength);\n      let byteOffset = 0;\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i];\n        result.set(array, byteOffset);\n        byteOffset += array.byteLength;\n      }\n      return result;\n    }\n  });\n  return KTX2Loader2;\n})();\nconst UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([RGBAFormat, RGFormat, RedFormat]);\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format\n};\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType\n};\nasync function createRawTexture(container) {\n  const { vkFormat } = container;\n  if (FORMAT_MAP[vkFormat] === void 0) {\n    throw new Error(\"THREE.KTX2Loader: Unsupported vkFormat.\");\n  }\n  let zstd;\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async (resolve) => {\n        const zstd2 = new ZSTDDecoder();\n        await zstd2.init();\n        resolve(zstd2);\n      });\n    }\n    zstd = await _zstd;\n  }\n  const mipmaps = [];\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;\n    const level = container.levels[levelIndex];\n    let levelData;\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData;\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);\n    } else {\n      throw new Error(\"THREE.KTX2Loader: Unsupported supercompressionScheme.\");\n    }\n    let data;\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Float32Array.BYTES_PER_ELEMENT\n      );\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(\n        levelData.buffer,\n        levelData.byteOffset,\n        levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT\n      );\n    } else {\n      data = levelData;\n    }\n    mipmaps.push({\n      data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth\n    });\n  }\n  let texture;\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);\n  } else {\n    if (container.pixelDepth > 0)\n      throw new Error(\"THREE.KTX2Loader: Unsupported pixelDepth.\");\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);\n  }\n  texture.mipmaps = mipmaps;\n  texture.type = TYPE_MAP[vkFormat];\n  texture.format = FORMAT_MAP[vkFormat];\n  texture.needsUpdate = true;\n  const colorSpace = parseColorSpace(container);\n  if (\"colorSpace\" in texture)\n    texture.colorSpace = colorSpace;\n  else\n    texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  return Promise.resolve(texture);\n}\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0];\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace;\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`);\n    return NoColorSpace;\n  }\n}\nexport {\n  KTX2Loader\n};\n//# sourceMappingURL=KTX2Loader.js.map\n","import { DataTextureLoader, HalfFloatType, FloatType, DataUtils, LinearFilter } from \"three\";\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse(buffer) {\n    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n        case rgbe_write_error:\n          throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n        case rgbe_format_error:\n          throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n        default:\n        case rgbe_memory_error:\n          throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n      }\n    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      }\n      if (-1 < i) {\n        if (false !== consume)\n          buffer2.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n      return false;\n    }, RGBE_ReadHeader = function(buffer2) {\n      const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n        valid: 0,\n        string: \"\",\n        comments: \"\",\n        programtype: \"RGBE\",\n        format: \"\",\n        gamma: 1,\n        exposure: 1,\n        width: 0,\n        height: 0\n      };\n      let line, match;\n      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n        rgbe_error(rgbe_read_error, \"no header found\");\n      }\n      if (!(match = line.match(magic_token_re))) {\n        rgbe_error(rgbe_format_error, \"bad initial token\");\n      }\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + \"\\n\";\n      while (true) {\n        line = fgets(buffer2);\n        if (false === line)\n          break;\n        header.string += line + \"\\n\";\n        if (\"#\" === line.charAt(0)) {\n          header.comments += line + \"\\n\";\n          continue;\n        }\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1]);\n        }\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1]);\n        }\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1];\n        }\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\n          break;\n      }\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        rgbe_error(rgbe_format_error, \"missing format specifier\");\n      }\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        rgbe_error(rgbe_format_error, \"missing image size specifier\");\n      }\n      return header;\n    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n      const scanline_width = w2;\n      if (\n        // run length encoding is not allowed so read flat\n        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n        2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128\n      ) {\n        return new Uint8Array(buffer2);\n      }\n      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n        rgbe_error(rgbe_format_error, \"wrong scanline width\");\n      }\n      const data_rgba = new Uint8Array(4 * w2 * h2);\n      if (!data_rgba.length) {\n        rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n      }\n      let offset = 0, pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h2;\n      while (num_scanlines > 0 && pos < buffer2.byteLength) {\n        if (pos + 4 > buffer2.byteLength) {\n          rgbe_error(rgbe_read_error);\n        }\n        rgbeStart[0] = buffer2[pos++];\n        rgbeStart[1] = buffer2[pos++];\n        rgbeStart[2] = buffer2[pos++];\n        rgbeStart[3] = buffer2[pos++];\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n        }\n        let ptr = 0, count;\n        while (ptr < ptr_end && pos < buffer2.byteLength) {\n          count = buffer2[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun)\n            count -= 128;\n          if (0 === count || ptr + count > ptr_end) {\n            rgbe_error(rgbe_format_error, \"bad scanline data\");\n          }\n          if (isEncodedRun) {\n            const byteValue = buffer2[pos++];\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            }\n          } else {\n            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        }\n        const l = scanline_width;\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n        num_scanlines--;\n      }\n      return data_rgba;\n    };\n    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      destArray[destOffset + 3] = 1;\n    };\n    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);\n    };\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n    let data, type;\n    let numElements;\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4;\n        const floatArray = new Float32Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n        }\n        data = floatArray;\n        type = FloatType;\n        break;\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4;\n        const halfArray = new Uint16Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n        }\n        data = halfArray;\n        type = HalfFloatType;\n        break;\n      default:\n        throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n    }\n    return {\n      width: w,\n      height: h,\n      data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if (\"colorSpace\" in texture)\n            texture.colorSpace = \"srgb-linear\";\n          else\n            texture.encoding = 3e3;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  RGBELoader\n};\n//# sourceMappingURL=RGBELoader.js.map\n","import { DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, RedFormat, LinearFilter, DataUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nimport { version } from \"../_polyfill/constants.js\";\nconst hasColorSpace = version >= 152;\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = unzlibSync(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = unzlibSync(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = unzlibSync(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if ((spec & ~4) != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4)\n        EXRDecoder2.format = RGBAFormat;\n      else\n        EXRDecoder2.format = RedFormat;\n      if (hasColorSpace)\n        EXRDecoder2.colorSpace = \"srgb-linear\";\n      else\n        EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace)\n        texture.colorSpace = texData.colorSpace;\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = LinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\nexport {\n  EXRLoader\n};\n//# sourceMappingURL=EXRLoader.js.map\n","import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport {\n  DRACOLoader\n};\n//# sourceMappingURL=DRACOLoader.js.map\n","let generated;\nconst MeshoptDecoder = () => {\n  if (generated)\n    return generated;\n  const wasm_base = \"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\";\n  const wasm_simd = \"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\";\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11\n  ]);\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167\n  ]);\n  if (typeof WebAssembly !== \"object\") {\n    return {\n      supported: false\n    };\n  }\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n  }\n  let instance;\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance;\n    instance.exports.__wasm_call_ctors();\n  });\n  function unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n  }\n  function decode(fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = count + 3 & ~3;\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n      filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`);\n    }\n  }\n  const filters = {\n    // legacy index-based enums for glTF\n    0: \"\",\n    1: \"meshopt_decodeFilterOct\",\n    2: \"meshopt_decodeFilterQuat\",\n    3: \"meshopt_decodeFilterExp\",\n    // string-based enums for glTF\n    NONE: \"\",\n    OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n    QUATERNION: \"meshopt_decodeFilterQuat\",\n    EXPONENTIAL: \"meshopt_decodeFilterExp\"\n  };\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: \"meshopt_decodeVertexBuffer\",\n    1: \"meshopt_decodeIndexBuffer\",\n    2: \"meshopt_decodeIndexSequence\",\n    // string-based enums for glTF\n    ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n    TRIANGLES: \"meshopt_decodeIndexBuffer\",\n    INDICES: \"meshopt_decodeIndexSequence\"\n  };\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    }\n  };\n  return generated;\n};\nexport {\n  MeshoptDecoder\n};\n//# sourceMappingURL=MeshoptDecoder.js.map\n"],"names":["version","parseInt","REVISION","replace","toTrianglesDrawMode","geometry","drawMode","TrianglesDrawMode","console","warn","TriangleFanDrawMode","TriangleStripDrawMode","index","getIndex","indices","position","getAttribute","error","i","count","push","setIndex","numberOfTriangles","newIndices","getX","length","newGeometry","clone","clearGroups","u8","Uint8Array","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","r","j","_a","fl","revfl","fd","rev","x","hMap","cd","mb","s","l","co","le","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","Math","set","final","f","pos","bt","lm","dm","lbt","dbt","n","tbts","type","t","subarray","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","lpos","sym","add","dsym","end","e","slc","et","unzlibSync","data","out","zlv","td","TextDecoder","decode","stream","GroundProjectedEnv","Mesh","constructor","texture","options","_b","isCubeMap","def","isCubeTexture","cubeSize","image","width","_lodMax","floor","log2","_cubeSize","pow","fragmentShader","join","uniforms","map","value","height","radius","super","IcosahedronGeometry","ShaderMaterial","vertexShader","side","DoubleSide","this","material","__defProp","Object","defineProperty","__publicField","obj","key","enumerable","configurable","writable","__defNormalProp","EventDispatcher","addEventListener","listener","_listeners","listeners","indexOf","hasEventListener","removeEventListener","listenerArray","splice","dispatchEvent","event","target","array","slice","call","_ray","Ray","_plane","Plane","TILT_LIMIT","cos","PI","moduloWrapAround","offset","capacity","OrbitControls","object","domElement","__publicField$1","Vector3","Infinity","LEFT","UP","RIGHT","BOTTOM","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","ONE","TOUCH","TWO","DOLLY_PAN","target0","position0","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","setPolarAngle","currentPhi","phiDist","abs","sphericalDelta","scope","update","setAzimuthalAngle","currentTheta","thetaDist","getDistance","distanceTo","listenToKeyEvents","domElement2","onKeyDown","_domElementKeyEvents","stopListenToKeyEvents","saveState","copy","reset","updateProjectionMatrix","changeEvent","state","STATE","NONE","up","quat","Quaternion","setFromUnitVectors","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","autoRotate","rotateLeft","autoRotateSpeed","enableDamping","dampingFactor","min","minAzimuthAngle","maxAzimuthAngle","isFinite","minPolarAngle","maxPolarAngle","makeSafe","addScaledVector","panOffset","zoomToCursor","performCursorZoom","isOrthographicCamera","clampDistance","scale","setFromSpherical","matrixAutoUpdate","updateMatrix","lookAt","multiplyScalar","zoomChanged","newRadius","PerspectiveCamera","isPerspectiveCamera","prevRadius","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","y","unproject","minZoom","maxZoom","mouseAfter","screenSpacePanning","transformDirection","matrix","origin","direction","dot","setFromNormalAndCoplanarPoint","intersectPlane","OrthographicCamera","distanceToSquared","EPS","quaternion","connect","style","touchAction","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","dispose","_c","_d","_e","_f","ownerDocument","onPointerMove","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","zoomSpeed","angle","reverseOrbit","reverseHorizontalOrbit","rotateUp","reverseVerticalOrbit","panLeft","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","enablePan","setScale","newScale","enableZoom","dollyOut","dollyScale","dollyIn","updateMouseParameters","rect","getBoundingClientRect","clientX","clientY","w","h","normalize","dist","minDistance","maxDistance","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","rotateSpeed","handleTouchMovePan","panSpeed","handleTouchMoveDolly","enabled","addPointer","pointerType","trackPointer","touches","enableRotate","DOLLY_ROTATE","onTouchStart","mouseAction","button","mouseButtons","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","pointerId","removePointer","releasePointerCapture","preventDefault","handleMouseWheel","needsUpdate","code","keys","keyPanSpeed","handleKeyDown","pointer","getScale","decodeText","il","String","fromCharCode","decodeURIComponent","escape","SRGBColorSpace","LinearSRGBColorSpace","GLTFLoader","Loader","manager","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsBumpExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","load","url","onLoad","onProgress","onError","resourcePath","path","relativeUrl","LoaderUtils","extractUrlBase","resolveURL","itemStart","_onError","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","parse","gltf","setDRACOLoader","setDDSLoader","Error","setKTX2Loader","setMeshoptDecoder","callback","unregister","json","extensions","plugins","JSON","ArrayBuffer","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","GLTFParser","crossOrigin","fileLoader","plugin","name","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","Promise","resolve","reject","GLTFRegistry","objects","get","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_DISPERSION","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_MATERIALS_BUMP","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDef","lights","lightNode","color","Color","setRGB","range","DirectionalLight","PointLight","SpotLight","spot","innerConeAngle","outerConeAngle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","self2","then","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","baseColorTexture","assignTexture","all","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoatNormalScale","dispersion","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","colorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","bumpScale","bumpFactor","bumpTexture","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","loadTexture","textureIndex","textureDef","textures","loadTextureImage","source","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","Image","src","onload","onerror","loadBufferView","bufferView","bufferViews","extensionDef","buffer","decoder","supported","res","byteOffset","byteLength","stride","byteStride","decodeGltfBufferAsync","mode","filter","res2","ready","result","decodeGltfBuffer","createNodeMesh","mesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","attributes","accessor","results","nodeObject","pop","isGroup","children","instancedMeshes","Matrix4","q","instancedMesh","InstancedMesh","TRANSLATION","fromBufferAttribute","ROTATION","SCALE","setMatrixAt","compose","attributeName","attr","instanceColor","InstancedBufferAttribute","itemSize","normalized","setAttribute","Object3D","prototype","assignFinalMaterial","clear","BINARY_EXTENSION_CHUNK_TYPES","body","headerView","DataView","header","magic","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","decodeDracoFile","attribute","extendTexture","transform","texCoord","channel","rotation","fromArray","repeat","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","interpolate_","i1","t0","t1","stride2","stride3","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","Int8Array","Int16Array","Float32Array","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","__spreadValues","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","assign","updateMorphTargets","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","targets","attributesKey","sort","getNormalizedComponentScale","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","userAgent","test","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","catch","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","bufferIndex","bufferDef","buffers","bufferViewDef","accessorIndex","sparse","TypedArray","BufferAttribute","pendingBufferViews","elementBytes","BYTES_PER_ELEMENT","itemBytes","bufferAttribute","ibSlice","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","promise","loadImageSource","flipY","startsWith","samplers","magFilter","minFilter","wrapS","wrapT","URL","self","webkitURL","sourceURI","isObjectURL","blob","Blob","mimeType","createObjectURL","sourceURI2","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","search","mapName","mapDef","colorSpace","gltfReference","encoding","useDerivativeTangents","tangent","useVertexColors","useFlatShading","normal","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","MeshStandardMaterial","materialType","kmuExtension","metalness","metallicFactor","roughness","roughnessFactor","metallicRoughnessTexture","doubleSided","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissive","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","depthTest","FrontSide","geometries","SkinnedMesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","morphAttributes","group","Group","cameraIndex","cameraDef","params","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","node","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","createdTracks","_createAnimationTracks","k","AnimationClip","traverse","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","forEach","Bone","applyMatrix4","has","sceneIndex","sceneDef","nodeIds","reducedAssociations","node2","reduceAssociations","targetName","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","interpolation","outputArray","_getArrayFromAccessor","jl","track","_createCubicSplineTrackInterpolant","scaled","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","assignAttributeAccessor","gltfAttributeName","accessor2","box","Box3","boxScale","maxDisplacement","vector","expandByVector","boundingBox","sphere","Sphere","getCenter","center","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative","addMorphTargets","Data3DTexture","depth","isData3DTexture","wrapR","generateMipmaps","unpackAlignment","WorkerPool","pool","queue","workers","workersResolve","workerStatus","_initWorker","workerId","worker","workerCreator","_onMessage","_getIdleWorker","msg","resolve2","msg2","transfer","shift","postMessage","setWorkerCreator","setWorkerLimit","terminate","KHR_DF_TRANSFER_SRGB","KHR_DF_PRIMARIES_UNSPECIFIED","KHR_DF_PRIMARIES_BT709","KHR_DF_PRIMARIES_DISPLAYP3","KTX2Container","vkFormat","typeSize","pixelWidth","pixelHeight","pixelDepth","layerCount","faceCount","supercompressionScheme","levels","dataFormatDescriptor","vendorId","descriptorType","descriptorBlockSize","versionNumber","colorModel","colorPrimaries","transferFunction","flags","texelBlockDimension","bytesPlane","samples","keyValue","globalData","BufferReader","littleEndian","_dataView","_littleEndian","_offset","_nextUint8","getUint8","_nextUint16","getUint16","_nextUint32","_nextUint64","__pow","_nextInt32","getInt32","_nextUint8Array","len","_skip","bytes","_scan","maxByteLength","term","KTX2_ID","Buffer","from","toString","init","instance","heap","IMPORT_OBJECT","env","emscripten_notify_memory_growth","exports","memory","ZSTDDecoder","fetch","wasm","response","arrayBuffer","WebAssembly","instantiate","_init","uncompressedSize","compressedSize","compressedPtr","malloc","Number","ZSTD_findDecompressedSize","uncompressedPtr","actualSize","ZSTD_decompress","dec","free","CompressedCubeTexture","CompressedTexture","format","CubeReflectionMapping","isCompressedCubeTexture","CompressedArrayTexture","mipmaps","isCompressedArrayTexture","LinearEncoding","sRGBEncoding","NoColorSpace","DisplayP3ColorSpace","LinearDisplayP3ColorSpace","_taskCache","WeakMap","_zstd","_activeLoaders","KTX2Loader","_KTX2Loader","transcoderPath","transcoderBinary","transcoderPending","workerPool","workerSourceURL","workerConfig","MSC_TRANSCODER","setTranscoderPath","num","renderer","astcSupported","etc1Supported","etc2Supported","dxtSupported","bptcSupported","pvrtcSupported","capabilities","isWebGL2","jsLoader","jsContent","loadAsync","binaryLoader","binaryContent","jsContent2","binaryContent2","fn","BasisWorker","stringify","EngineFormat","TranscoderFormat","BasisFormat","substring","lastIndexOf","Worker","config","_createTexture","_createTextureFrom","transcodeResult","container","faces","dfdFlags","UnsignedByteType","parseColorSpace","premultiplyAlpha","_0","__async","arguments","id","headerByteLength","headerReader","levelCount","dfdByteOffset","dfdByteLength","kvdByteOffset","kvdByteLength","sgdByteOffset","sgdByteLength","levelReader","levelData","uncompressedByteLength","dfdReader","dfd","numSamples","sample","bitOffset","bitLength","channelType","samplePosition","sampleLower","sampleUpper","kvdReader","keyValueByteLength","keyData","text","kvPadding","sgdReader","endpointCount","selectorCount","endpointsByteLength","selectorsByteLength","tablesByteLength","extendedByteLength","imageDescs","imageFlags","rgbSliceByteOffset","rgbSliceByteLength","alphaSliceByteOffset","alphaSliceByteLength","endpointsByteOffset","selectorsByteOffset","tablesByteOffset","extendedByteOffset","endpointsData","selectorsData","tablesData","extendedData","read","FORMAT_MAP","zstd","zstd2","levelIndex","levelWidth","levelHeight","levelDepth","level","TYPE_MAP","FloatType","HalfFloatType","UNCOMPRESSED_FORMATS","DataTexture","createRawTexture","taskConfig","texturePending","KTX2Loader2","ETC1S","UASTC_4x4","ETC1","ETC2","BC1","BC3","BC4","BC5","BC7_M6_OPAQUE_ONLY","BC7_M5","PVRTC1_4_RGB","PVRTC1_4_RGBA","ASTC_4x4","ATC_RGB","ATC_RGBA_INTERPOLATED_ALPHA","RGBA32","RGB565","BGR565","RGBA4444","RGBAFormat","RGBA_ASTC_4x4_Format","RGBA_BPTC_Format","RGBA_ETC2_EAC_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGB_PVRTC_4BPPV1_Format","RGB_S3TC_DXT1_Format","BasisModule","_EngineFormat","_TranscoderFormat","_BasisFormat","message","wasmBinary","onRuntimeInitialized","BASIS","initializeBasis","KTX2File","hasAlpha","ktx2File","cleanup","close","delete","isValid","basisFormat","isUASTC","getWidth","getHeight","getLayers","getLevels","getFaces","getHasAlpha","getDFDFlags","transcoderFormat","engineFormat","ETC1S_OPTIONS","UASTC_OPTIONS","opt","if","includes","needsPowerOfTwo","isPowerOfTwo","getTranscoderFormat","startTranscoding","face","mip","layerMips","mipWidth","mipHeight","layer","levelInfo","getImageLevelInfo","origWidth","origHeight","dst","getImageTranscodedSizeInBytes","transcodeImage","mipData","concat","transcode","FORMAT_OPTIONS","priorityETC1S","priorityUASTC","arrays","totalByteLength","Set","RGFormat","RedFormat","RGBA_ASTC_6x6_Format","RGBELoader","DataTextureLoader","rgbe_error","rgbe_error_code","fgets","buffer2","lineLimit","consume","chunk","apply","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","RGBEByteToRGBHalf","DataUtils","toHalfFloat","byteArray","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","valid","string","comments","programtype","gamma","exposure","line","charAt","parseFloat","RGBE_ReadHeader","image_rgba_data","w2","h2","scanline_width","data_rgba","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","isEncodedRun","byteValue","off","RGBE_ReadPixels_RLE","numElements","floatArray","halfArray","setDataType","texData","hasColorSpace","EXRLoader","USHORT_RANGE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","logBase","getBitsReturn","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","hufUnpackEncTable","inDataView","ni","im","iM","hcode","zerun","nc","hufCanonicalCodeTable","hufLength","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","UInt16","Int16","wdec14Return","wdec14","ls","hs","ai","as","bs","wdec16","bb","aa","wav2Decode","nx","ox","ny","oy","mx","p2","w14","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","interleaveScalar","t2","stop","decodeRunLength","size","reader","getInt8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","unZigZag","decodeFloat16","dctInverse","g","alpha","beta","row","rowPtr","column","csc709Inverse","cb","cr","convertToHalf","idx","toLinear","float","sign","uncompressRAW","info","uncompressRLE","compressed","viewer","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","bitmap","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","lut","maxValue","reverseLutFromBitmap","nData","applyLut","tmpOffset2","cp","uncompressPXR","sz","tmpBufferEnd","writePtr","pixel","uncompressDWA","dwaHeader","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","parseNullTerminatedString","channelData","decoded","pixelType","pLinear","cscSet","offset2","rule","zlibInfo","dcBuffer","rleBuffer","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp2","blocky","maxY","maxX","blockx","fill","type2","y2","setUint16","offset3","x2","halfRow","comp","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","parseInt32","Int32","Uint32","Uint8","int","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Uint16","parseFloat16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","parseV3f","parseRational","parseTimecode","bufferDataView","uInt8Array","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeType","attributeValue","parseHeader","EXRDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","blockCount","outputChannels","setupDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line_y","true_y","channelID","cOff","outIndex","DRACOLoader","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerNextTaskID","defaultAttributeIDs","uv","defaultAttributeTypes","setDecoderPath","setDecoderConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","taskKey","cachedTask","taskID","taskCost","geometryPending","_getWorker","_worker","_callbacks","_createGeometry","_releaseTask","geometryData","_loadLibrary","responseType","_initDecoder","useJS","librariesPending","libraries","DRACOWorker","worker2","_taskCosts","_taskLoad","onmessage","debug","log","decodeAttribute","draco","dracoGeometry","numComponents","num_components","numValues","num_points","dataType","DT_FLOAT32","DT_INT8","DT_INT16","Int32Array","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","getDracoDataType","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","_free","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","error_msg","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","decodeIndex","destroy","generated","MeshoptDecoder","detector","wasmpack","validate","ch","charCodeAt","write","unpack","__wasm_call_ctors","fun","sbrk","count4","tp","sp","filters","OCTAHEDRAL","QUATERNION","EXPONENTIAL","decoders","INDICES","decodeVertexBuffer","meshopt_decodeVertexBuffer","decodeIndexBuffer","meshopt_decodeIndexBuffer","decodeIndexSequence","meshopt_decodeIndexSequence"],"mappings":"kwCACA,MAAMA,QAAiCC,SAASC,EAASC,QAAQ,OAAQ,QC4RzE,SAASC,GAAoBC,EAAUC,GACrC,GAAIA,IAAaC,EAER,OADPC,QAAQC,KAAK,2FACNJ,EAEL,GAAAC,IAAaI,GAAuBJ,IAAaK,EAAuB,CACtE,IAAAC,EAAQP,EAASQ,WACrB,GAAc,OAAVD,EAAgB,CAClB,MAAME,EAAU,GACVC,EAAWV,EAASW,aAAa,YACvC,QAAiB,IAAbD,EAUK,OAHCP,QAAAS,MACN,2GAEKZ,EATP,IAAA,IAASa,EAAI,EAAGA,EAAIH,EAASI,MAAOD,IAClCJ,EAAQM,KAAKF,GAEfb,EAASgB,SAASP,GAClBF,EAAQP,EAASQ,UAOpB,CACK,MAAAS,EAAoBV,EAAMO,MAAQ,EAClCI,EAAa,GACnB,GAAIX,EACF,GAAIN,IAAaI,EACf,IAAA,IAASQ,EAAI,EAAGA,GAAKI,EAAmBJ,IACtCK,EAAWH,KAAKR,EAAMY,KAAK,IAC3BD,EAAWH,KAAKR,EAAMY,KAAKN,IAC3BK,EAAWH,KAAKR,EAAMY,KAAKN,EAAI,SAGjC,IAAA,IAASA,EAAI,EAAGA,EAAII,EAAmBJ,IACjCA,EAAI,GAAM,GACZK,EAAWH,KAAKR,EAAMY,KAAKN,IAC3BK,EAAWH,KAAKR,EAAMY,KAAKN,EAAI,IAC/BK,EAAWH,KAAKR,EAAMY,KAAKN,EAAI,MAE/BK,EAAWH,KAAKR,EAAMY,KAAKN,EAAI,IAC/BK,EAAWH,KAAKR,EAAMY,KAAKN,EAAI,IAC/BK,EAAWH,KAAKR,EAAMY,KAAKN,KAK/BK,EAAWE,OAAS,IAAMH,GAC5Bd,QAAQS,MAAM,oGAEV,MAAAS,EAAcrB,EAASsB,QAGtB,OAFPD,EAAYL,SAASE,GACrBG,EAAYE,cACLF,CACX,CAEW,OADClB,QAAAS,MAAM,sEAAuEX,GAC9ED,CAEX,CCnUA,IAAIwB,GAAKC,WAAYC,GAAMC,YAAaC,GAAMC,YAE1CC,GAAO,IAAIN,GAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAgB,EAAG,EAAoB,IAG1IO,GAAO,IAAIP,GAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAiB,EAAG,IAEjIQ,GAAO,IAAIR,GAAG,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,KAE7ES,GAAO,SAAUC,EAAIC,GAErB,IADI,IAAAC,EAAI,IAAIV,GAAI,IACPb,EAAI,EAAGA,EAAI,KAAMA,EACtBuB,EAAEvB,GAAKsB,GAAS,GAAKD,EAAGrB,EAAI,GAGhC,IAAIwB,EAAI,IAAIT,GAAIQ,EAAE,KAClB,IAASvB,EAAI,EAAGA,EAAI,KAAMA,EACb,IAAA,IAAAyB,EAAIF,EAAEvB,GAAIyB,EAAIF,EAAEvB,EAAI,KAAMyB,EAC/BD,EAAEC,GAAOA,EAAIF,EAAEvB,IAAO,EAAKA,EAG5B,MAAA,CAACuB,EAAGC,EACf,EACIE,GAAKN,GAAKH,GAAM,GAAIU,GAAKD,GAAG,GAAIE,GAAQF,GAAG,GAE/CC,GAAG,IAAM,IAAKC,GAAM,KAAO,GAI3B,IAHG,IAAqBC,GAAfT,GAAKF,GAAM,GAAY,GAE5BY,GAAM,IAAIjB,GAAI,OACTb,GAAI,EAAGA,GAAI,QAASA,GAAG,CAE5B,IAAI+B,IAAU,MAAJ/B,MAAgB,GAAW,MAAJA,KAAe,EAEhD+B,IAAU,OADVA,IAAU,MAAJA,MAAgB,GAAW,MAAJA,KAAe,MACtB,GAAW,KAAJA,KAAe,EAC5CD,GAAI9B,MAAY,MAAJ+B,MAAgB,GAAW,IAAJA,KAAe,KAAQ,CAC9D,CAIA,IAAIC,GAAQ,SAAUC,EAAIC,EAAIV,GAOnB,IANP,IAAIW,EAAIF,EAAG1B,OAEPP,EAAI,EAEJoC,EAAI,IAAIvB,GAAIqB,GAETlC,EAAImC,IAAKnC,IACVoC,EAAEH,EAAGjC,GAAK,GAEZ,IAIAqC,EAJAC,EAAK,IAAIzB,GAAIqB,GACjB,IAAKlC,EAAI,EAAGA,EAAIkC,IAAMlC,EACfsC,EAAAtC,GAAMsC,EAAGtC,EAAI,GAAKoC,EAAEpC,EAAI,IAAO,EAGtC,GAAIwB,EAAG,CAEEa,EAAA,IAAIxB,GAAI,GAAKqB,GAElB,IAAIK,EAAM,GAAKL,EACf,IAAKlC,EAAI,EAAGA,EAAImC,IAAKnC,EAEb,GAAAiC,EAAGjC,GAQM,IANT,IAAIwC,EAAMxC,GAAK,EAAKiC,EAAGjC,GAEnByC,EAAMP,EAAKD,EAAGjC,GAEd0C,EAAIJ,EAAGL,EAAGjC,GAAK,MAAQyC,EAElBE,EAAID,GAAM,GAAKD,GAAO,EAAIC,GAAKC,IAAKD,EAEzCL,EAAGP,GAAIY,KAAOH,GAAOC,CAIpC,MAGG,IADKH,EAAA,IAAIxB,GAAIsB,GACRnC,EAAI,EAAGA,EAAImC,IAAKnC,EACbiC,EAAGjC,KACHqC,EAAGrC,GAAK8B,GAAIQ,EAAGL,EAAGjC,GAAK,QAAW,GAAKiC,EAAGjC,IAI/C,OAAAqC,CACX,EAEIO,GAAM,IAAIjC,GAAG,KACjB,IAASX,GAAI,EAAGA,GAAI,MAAOA,GACvB4C,GAAI5C,IAAK,EACb,IAASA,GAAI,IAAKA,GAAI,MAAOA,GACzB4C,GAAI5C,IAAK,EACb,IAASA,GAAI,IAAKA,GAAI,MAAOA,GACzB4C,GAAI5C,IAAK,EACb,IAASA,GAAI,IAAKA,GAAI,MAAOA,GACzB4C,GAAI5C,IAAK,EAEb,IAAI6C,GAAM,IAAIlC,GAAG,IACjB,IAASX,GAAI,EAAGA,GAAI,KAAMA,GACtB6C,GAAI7C,IAAK,EAEV,IAAsC8C,GAAqBd,GAAKY,GAAK,EAAG,GAElCG,GAAqBf,GAAKa,GAAK,EAAG,GAEvEG,GAAM,SAAUC,GAEhB,IADI,IAAAN,EAAIM,EAAE,GACDjD,EAAI,EAAGA,EAAIiD,EAAE1C,SAAUP,EACxBiD,EAAEjD,GAAK2C,IACPA,EAAIM,EAAEjD,IAEP,OAAA2C,CACX,EAEIO,GAAO,SAAUC,EAAGC,EAAGT,GACnB,IAAAU,EAAKD,EAAI,EAAK,EACT,OAAAD,EAAEE,GAAMF,EAAEE,EAAI,IAAM,KAAY,EAAJD,GAAUT,CACnD,EAEIW,GAAS,SAAUH,EAAGC,GAClB,IAAAC,EAAKD,EAAI,EAAK,EAClB,OAASD,EAAEE,GAAMF,EAAEE,EAAI,IAAM,EAAMF,EAAEE,EAAI,IAAM,MAAa,EAAJD,EAC5D,EAgBIG,GAAQ,SAAUC,EAAKC,EAAKC,GAE5B,IAAIC,EAAKH,EAAIjD,OACb,IAAKoD,GAAOD,IAAOA,EAAGtB,GAAKuB,EAAK,EACrB,OAAAF,GAAO,IAAI9C,GAAG,GAErB,IAAAiD,GAASH,GAAOC,EAEhBG,GAAQH,GAAMA,EAAG1D,EAChB0D,IACDA,EAAK,CAAA,GAEJD,IACKA,EAAA,IAAI9C,GAAQ,EAALgD,IAEb,IA7BaP,EA6BbU,EAAO,SAAU1B,GACjB,IAAI2B,EAAKN,EAAIlD,OAEb,GAAI6B,EAAI2B,EAAI,CAEJ,IAAAC,EAAO,IAAIrD,GAAGsD,KAAKjB,IAAS,EAALe,EAAQ3B,IACnC4B,EAAKE,IAAIT,GACHA,EAAAO,CACT,CACT,EAEQG,EAAQT,EAAGU,GAAK,EAAGC,EAAMX,EAAGN,GAAK,EAAGkB,EAAKZ,EAAGnC,GAAK,EAAGgD,EAAKb,EAAGtB,EAAGoC,EAAKd,EAAGP,EAAGsB,EAAMf,EAAGf,EAAG+B,EAAMhB,EAAGiB,EAE/FC,EAAY,EAALjB,EACR,EAAA,CACC,IAAKY,EAAI,CAELb,EAAGU,EAAID,EAAQjB,GAAKM,EAAKa,EAAK,GAE9B,IAAIQ,EAAO3B,GAAKM,EAAKa,EAAM,EAAG,GAE9B,GADOA,GAAA,GACFQ,EAAM,CAEP,IAAuBzC,EAAIoB,GAAvBrB,IApDCiB,EAoDQiB,GApDU,EAAK,IAAU,EAAJjB,GAAS,GAoDvB,GAAe,GAAMI,EAAIrB,EAAI,IAAM,EAAI2C,EAAI3C,EAAIC,EACnE,GAAI0C,EAAInB,EAAI,CACJ,GAAAE,EACM,KAAA,iBACV,KACH,CAEGD,GACAE,EAAKQ,EAAKlC,GAEdqB,EAAIS,IAAIV,EAAIuB,SAAS5C,EAAG2C,GAAIR,GAE5BZ,EAAGnC,EAAI+C,GAAMlC,EAAGsB,EAAGN,EAAIiB,EAAU,EAAJS,EAC7B,QACH,IACgB,GAARD,EACLN,EAAKzB,GAAM0B,EAAKzB,GAAM0B,EAAM,EAAGC,EAAM,MAAA,IACxB,GAARG,EAmDC,KAAA,qBAjDN,IAAIG,EAAO9B,GAAKM,EAAKa,EAAK,IAAM,IAAKY,EAAQ/B,GAAKM,EAAKa,EAAM,GAAI,IAAM,EACnEa,EAAKF,EAAO9B,GAAKM,EAAKa,EAAM,EAAG,IAAM,EAClCA,GAAA,GAKP,IAHI,IAAAc,EAAM,IAAIxE,GAAGuE,GAEbE,EAAM,IAAIzE,GAAG,IACRX,EAAI,EAAGA,EAAIiF,IAASjF,EAErBoF,EAAAjE,GAAKnB,IAAMkD,GAAKM,EAAKa,EAAU,EAAJrE,EAAO,GAE1CqE,GAAe,EAARY,EAEP,IAAII,EAAMrC,GAAIoC,GAAME,GAAU,GAAKD,GAAO,EAEtCE,EAAMvD,GAAKoD,EAAKC,EAAK,GAChB,IAAArF,EAAI,EAAGA,EAAIkF,GAAK,CACrB,IAII/C,EAJAX,EAAI+D,EAAIrC,GAAKM,EAAKa,EAAKiB,IAM3B,GAJAjB,GAAW,GAAJ7C,GAEHW,EAAIX,IAAM,GAEN,GACJ2D,EAAInF,KAAOmC,MAEV,CAEG,IAAAqD,EAAI,EAAGb,EAAI,EAOR,IANE,IAALxC,GACIwC,EAAA,EAAIzB,GAAKM,EAAKa,EAAK,GAAIA,GAAO,EAAGmB,EAAIL,EAAInF,EAAI,IACvC,IAALmC,GACLwC,EAAI,EAAIzB,GAAKM,EAAKa,EAAK,GAAIA,GAAO,GACxB,IAALlC,IACLwC,EAAI,GAAKzB,GAAKM,EAAKa,EAAK,KAAMA,GAAO,GAClCM,KACHQ,EAAInF,KAAOwF,CAClB,CACJ,CAEG,IAAAC,EAAKN,EAAIJ,SAAS,EAAGC,GAAOU,EAAKP,EAAIJ,SAASC,GAElDP,EAAMzB,GAAIyC,GAEVf,EAAM1B,GAAI0C,GACLnB,EAAAvC,GAAKyD,EAAIhB,EAAK,GACdD,EAAAxC,GAAK0D,EAAIhB,EAAK,EAGb,CACV,GAAIL,EAAMO,EAAM,CACR,GAAAf,EACM,KAAA,iBACV,KACH,CACJ,CAGGD,GACAE,EAAKQ,EAAK,QAGd,IAFA,IAAIqB,GAAO,GAAKlB,GAAO,EAAGmB,GAAO,GAAKlB,GAAO,EACzCmB,EAAOxB,GACHwB,EAAOxB,EAAK,CAEZ,IAAgCyB,GAAhCN,EAAIjB,EAAGjB,GAAOE,EAAKa,GAAOsB,MAAkB,EAEhD,IADAtB,GAAW,GAAJmB,GACGZ,EAAM,CACR,GAAAf,EACM,KAAA,iBACV,KACH,CACD,IAAK2B,EACK,KAAA,yBACV,GAAIM,EAAM,IACNrC,EAAIa,KAAQwB,MAAA,IACA,KAAPA,EAAY,CACjBD,EAAOxB,EAAKE,EAAK,KACjB,KACH,CAEG,IAAIwB,EAAMD,EAAM,IAEhB,GAAIA,EAAM,IAAK,CAEX,IAAmBvE,EAAIN,GAAnBjB,EAAI8F,EAAM,KACRC,EAAA7C,GAAKM,EAAKa,GAAM,GAAK9C,GAAK,GAAKI,GAAG3B,GACjCqE,GAAA9C,CACV,CAEG,IAAA4B,EAAIqB,EAAGlB,GAAOE,EAAKa,GAAOuB,GAAMI,EAAO7C,IAAM,EACjD,IAAKA,EACK,KAAA,mBACVkB,GAAW,GAAJlB,EACHuC,EAAK7D,GAAGmE,GACZ,GAAIA,EAAO,EAAG,CACNzE,EAAIL,GAAK8E,GACbN,GAAMpC,GAAOE,EAAKa,IAAS,GAAK9C,GAAK,EAAI8C,GAAO9C,CACnD,CACD,GAAI8C,EAAMO,EAAM,CACR,GAAAf,EACM,KAAA,iBACV,KACH,CACGD,GACAE,EAAKQ,EAAK,QAEP,IADP,IAAI2B,EAAM3B,EAAKyB,EACRzB,EAAK2B,EAAK3B,GAAM,EACnBb,EAAIa,GAAMb,EAAIa,EAAKoB,GACnBjC,EAAIa,EAAK,GAAKb,EAAIa,EAAK,EAAIoB,GAC3BjC,EAAIa,EAAK,GAAKb,EAAIa,EAAK,EAAIoB,GAC3BjC,EAAIa,EAAK,GAAKb,EAAIa,EAAK,EAAIoB,GAE1BpB,EAAA2B,CACR,CACJ,CACDvC,EAAGtB,EAAImC,EAAIb,EAAGN,EAAIyC,EAAMnC,EAAGnC,EAAI+C,EAC3BC,IACQJ,EAAA,EAAGT,EAAGf,EAAI8B,EAAKf,EAAGP,EAAIqB,EAAId,EAAGiB,EAAID,EAChD,QAASP,GACV,OAAOG,GAAMb,EAAIlD,OAASkD,EA3LpB,SAAUf,EAAGP,EAAG+D,IACb,MAAL/D,GAAaA,EAAI,KACbA,EAAA,IACC,MAAL+D,GAAaA,EAAIxD,EAAEnC,UACnB2F,EAAIxD,EAAEnC,QAEN,IAAAoE,EAAI,IAAKjC,aAAa7B,GAAMA,GAAM6B,aAAa3B,GAAMA,GAAMJ,IAAIuF,EAAI/D,GAEhE,OADPwC,EAAET,IAAIxB,EAAEqC,SAAS5C,EAAG+D,IACbvB,CACX,CAkLoCwB,CAAI1C,EAAK,EAAGa,EAChD,EAmOI8B,GAAuB,IAAAzF,GAAG,GA0xBvB,SAAS0F,GAAWC,EAAMC,GACtB,OAAAhD,IAxcD,SAAUJ,GAChB,GAAmB,IAAP,GAAPA,EAAE,KAAkBA,EAAE,KAAO,EAAK,IAAOA,EAAE,IAAM,EAAIA,EAAE,IAAM,GACxD,KAAA,oBACN,GAAO,GAAPA,EAAE,GACI,KAAA,sDACd,CAmckBqD,CAAIF,GAAOA,EAAKvB,SAAS,GAAK,IAAIwB,EACpD,CAoHA,IAAIE,GAA2B,oBAAfC,iBAAgDA,YAGhE,IACID,GAAGE,OAAOP,GAAI,CAAEQ,QAAQ,IAClB,CACV,CAAA,MACOV,IAAG,CCr8CV,MAAMW,WAA2BC,EAC/B,WAAAC,CAAYC,EAASC,GACnB,IAAIvF,EAAIwF,EACF,MAAAC,GAJaC,EAIaJ,IAJEI,EAAIC,cAApB,IAACD,EAKnB,MACME,GADoG,OAA/FJ,EAAKC,EAAuC,OAA1BzF,EAAKsF,EAAQO,MAAM,SAAc,EAAS7F,EAAG8F,MAAQR,EAAQO,MAAMC,OAAiBN,EAAK,MACjG,EACfO,EAAUxD,KAAKyD,MAAMzD,KAAK0D,KAAKL,IAC/BM,EAAY3D,KAAK4D,IAAI,EAAGJ,GAsBxBK,EAnBU,CACdX,EAAY,2BAA6B,GACzC,8BAA8B,GAJlB,EAAIlD,KAAKjB,IAAI4E,EAAW,MAKpC,+BAA+B,GAJlB,EAAIA,GAKjB,0BAA0BH,OAeGM,KAAK,MACpC,2/EAqEoBjJ,IAAW,IAAM,sBAAwB,6CAGvDkJ,EAAW,CACfC,IAAK,CAAEC,MAAOlB,GACdmB,OAAQ,CAAED,OAAmB,MAAXjB,OAAkB,EAASA,EAAQkB,SAAW,IAChEC,OAAQ,CAAEF,OAAmB,MAAXjB,OAAkB,EAASA,EAAQmB,SAAW,MASlEC,MAPiB,IAAIC,EAAoB,EAAG,IAC3B,IAAIC,EAAe,CAClCP,WACAF,iBACAU,aA7FA,gUA8FAC,KAAMC,IAGT,CACD,UAAIN,CAAOA,GACJO,KAAAC,SAASZ,SAASI,OAAOF,MAAQE,CACvC,CACD,UAAIA,GACK,OAAAO,KAAKC,SAASZ,SAASI,OAAOF,KACtC,CACD,UAAIC,CAAOA,GACJQ,KAAAC,SAASZ,SAASG,OAAOD,MAAQC,CACvC,CACD,UAAIA,GACK,OAAAQ,KAAKC,SAASZ,SAASG,OAAOD,KACtC,EClIH,IAAIW,GAAYC,OAAOC,eAEnBC,GAAgB,CAACC,EAAKC,EAAKhB,KADT,EAACe,EAAKC,EAAKhB,KAAUgB,KAAOD,EAAMJ,GAAUI,EAAKC,EAAK,CAAEC,YAAY,EAAMC,cAAc,EAAMC,UAAU,EAAMnB,UAAWe,EAAIC,GAAOhB,CAAA,EAExJoB,CAAgBL,EAAoB,iBAARC,EAAmBA,EAAM,GAAKA,EAAKhB,GACxDA,GAET,MAAMqB,GACJ,WAAAxC,GAEEiC,GAAcL,KAAM,aACrB,CAMD,gBAAAa,CAAiB3E,EAAM4E,QACG,IAApBd,KAAKe,aACPf,KAAKe,WAAa,IACpB,MAAMC,EAAYhB,KAAKe,gBACC,IAApBC,EAAU9E,KACF8E,EAAA9E,GAAQ,KAE0B,IAA1C8E,EAAU9E,GAAM+E,QAAQH,IAChBE,EAAA9E,GAAM3E,KAAKuJ,EAExB,CAMD,gBAAAI,CAAiBhF,EAAM4E,GACrB,QAAwB,IAApBd,KAAKe,WACA,OAAA,EACT,MAAMC,EAAYhB,KAAKe,WAChB,YAAoB,IAApBC,EAAU9E,KAA0D,IAAtC8E,EAAU9E,GAAM+E,QAAQH,EAC9D,CAMD,mBAAAK,CAAoBjF,EAAM4E,GACxB,QAAwB,IAApBd,KAAKe,WACP,OACF,MACMK,EADYpB,KAAKe,WACS7E,GAChC,QAAsB,IAAlBkF,EAA0B,CACtB,MAAArK,EAAQqK,EAAcH,QAAQH,IAClB,IAAd/J,GACYqK,EAAAC,OAAOtK,EAAO,EAE/B,CACF,CAKD,aAAAuK,CAAcC,GACZ,QAAwB,IAApBvB,KAAKe,WACP,OACF,MACMK,EADYpB,KAAKe,WACSQ,EAAMrF,MACtC,QAAsB,IAAlBkF,EAA0B,CAC5BG,EAAMC,OAASxB,KACT,MAAAyB,EAAQL,EAAcM,MAAM,GAClC,IAAA,IAASrK,EAAI,EAAGoC,EAAIgI,EAAM7J,OAAQP,EAAIoC,EAAGpC,IACvCoK,EAAMpK,GAAGsK,KAAK3B,KAAMuB,GAEtBA,EAAMC,OAAS,IAChB,CACF,ECxEH,IAAItB,GAAYC,OAAOC,eAEnBC,GAAgB,CAACC,EAAKC,EAAKhB,KADT,EAACe,EAAKC,EAAKhB,KAAUgB,KAAOD,EAAMJ,GAAUI,EAAKC,EAAK,CAAEC,YAAY,EAAMC,cAAc,EAAMC,UAAU,EAAMnB,UAAWe,EAAIC,GAAOhB,CAAA,EAExJoB,CAAgBL,EAAoB,iBAARC,EAAmBA,EAAM,GAAKA,EAAKhB,GACxDA,GAIT,MAAMqC,OAA2BC,EAC3BC,OAA6BC,EAC7BC,GAAa1G,KAAK2G,IAAU3G,KAAK4G,GAAK,IAAhB,IACtBC,GAAmB,CAACC,EAAQC,KAAcD,EAASC,EAAWA,GAAYA,EAChF,MAAMC,WAAsB1B,GAC1B,WAAAxC,CAAYmE,EAAQC,WAElBnC,GAAcL,KAAM,UACpBK,GAAcL,KAAM,cAENyC,GAAAzC,KAAM,WAAW,GAE/BK,GAAcL,KAAM,SAAU,IAAI0C,GAEpBD,GAAAzC,KAAM,cAAe,GACrByC,GAAAzC,KAAM,cAAe2C,KAErBF,GAAAzC,KAAM,UAAW,GACjByC,GAAAzC,KAAM,UAAW2C,KAGjBF,GAAAzC,KAAM,gBAAiB,GAEvByC,GAAAzC,KAAM,gBAAiB1E,KAAK4G,IAI5BO,GAAAzC,KAAM,mBAA4B2C,KAElCF,GAAAzC,KAAM,kBAAmB2C,KAIzBF,GAAAzC,KAAM,iBAAiB,GACvByC,GAAAzC,KAAM,gBAAiB,KAGvByC,GAAAzC,KAAM,cAAc,GACpByC,GAAAzC,KAAM,YAAa,GAEnByC,GAAAzC,KAAM,gBAAgB,GACtByC,GAAAzC,KAAM,cAAe,GAErByC,GAAAzC,KAAM,aAAa,GACnByC,GAAAzC,KAAM,WAAY,GAClByC,GAAAzC,KAAM,sBAAsB,GAE5ByC,GAAAzC,KAAM,cAAe,GAErByC,GAAAzC,KAAM,gBAAgB,GAGtByC,GAAAzC,KAAM,cAAc,GACpByC,GAAAzC,KAAM,kBAAmB,GAEzByC,GAAAzC,KAAM,gBAAgB,GAEtByC,GAAAzC,KAAM,0BAA0B,GAEhCyC,GAAAzC,KAAM,wBAAwB,GAG9ByC,GAAAzC,KAAM,OAAQ,CAAE4C,KAAM,YAAaC,GAAI,UAAWC,MAAO,aAAcC,OAAQ,cAE7F1C,GAAcL,KAAM,eAAgB,CAClC4C,KAAMI,EAAMC,OACZC,OAAQF,EAAMG,MACdL,MAAOE,EAAMI,MAGDX,GAAAzC,KAAM,UAAW,CAAEqD,IAAKC,EAAML,OAAQM,IAAKD,EAAME,YAC/DnD,GAAcL,KAAM,WACpBK,GAAcL,KAAM,aACpBK,GAAcL,KAAM,SAENyC,GAAAzC,KAAM,uBAAwB,MAC5CK,GAAcL,KAAM,iBACpBK,GAAcL,KAAM,qBACpBK,GAAcL,KAAM,iBACpBK,GAAcL,KAAM,qBACpBK,GAAcL,KAAM,eAEpBK,GAAcL,KAAM,gBACpBK,GAAcL,KAAM,qBACpBK,GAAcL,KAAM,yBACpBK,GAAcL,KAAM,aACpBK,GAAcL,KAAM,SACpBK,GAAcL,KAAM,UACpBK,GAAcL,KAAM,WACpBK,GAAcL,KAAM,WAEpBK,GAAcL,KAAM,WAEpBK,GAAcL,KAAM,YAEpBK,GAAcL,KAAM,YAEpBK,GAAcL,KAAM,YACpBA,KAAKuC,OAASA,EACdvC,KAAKwC,WAAaA,EACbxC,KAAAyD,QAAUzD,KAAKwB,OAAO1J,QAC3BkI,KAAK0D,UAAY1D,KAAKuC,OAAOrL,SAASY,QACjCkI,KAAA2D,MAAQ3D,KAAKuC,OAAOqB,KACpB5D,KAAA6D,cAAgB,IAAMC,EAAUC,IAChC/D,KAAAgE,kBAAoB,IAAMF,EAAUG,MACpCjE,KAAAkE,cAAiB3E,IACpB,IAAIwE,EAAM5B,GAAiB5C,EAAO,EAAIjE,KAAK4G,IACvCiC,EAAaL,EAAUC,IACvBI,EAAa,IACfA,GAAc,EAAI7I,KAAK4G,IACrB6B,EAAM,IACRA,GAAO,EAAIzI,KAAK4G,IAClB,IAAIkC,EAAU9I,KAAK+I,IAAIN,EAAMI,GACzB,EAAI7I,KAAK4G,GAAKkC,EAAUA,IACtBL,EAAMI,EACRJ,GAAO,EAAIzI,KAAK4G,GAEhBiC,GAAc,EAAI7I,KAAK4G,IAG3BoC,EAAeP,IAAMA,EAAMI,EAC3BI,EAAMC,QAAM,EAETxE,KAAAyE,kBAAqBlF,IACxB,IAAI0E,EAAQ9B,GAAiB5C,EAAO,EAAIjE,KAAK4G,IACzCwC,EAAeZ,EAAUG,MACzBS,EAAe,IACjBA,GAAgB,EAAIpJ,KAAK4G,IACvB+B,EAAQ,IACVA,GAAS,EAAI3I,KAAK4G,IACpB,IAAIyC,EAAYrJ,KAAK+I,IAAIJ,EAAQS,GAC7B,EAAIpJ,KAAK4G,GAAKyC,EAAYA,IACxBV,EAAQS,EACVT,GAAS,EAAI3I,KAAK4G,GAElBwC,GAAgB,EAAIpJ,KAAK4G,IAG7BoC,EAAeL,MAAQA,EAAQS,EAC/BH,EAAMC,QAAM,EAEdxE,KAAK4E,YAAc,IAAML,EAAMhC,OAAOrL,SAAS2N,WAAWN,EAAM/C,QAC3DxB,KAAA8E,kBAAqBC,IACZA,EAAAlE,iBAAiB,UAAWmE,IACxChF,KAAKiF,qBAAuBF,CAAA,EAE9B/E,KAAKkF,sBAAwB,KACtBlF,KAAAiF,qBAAqB9D,oBAAoB,UAAW6D,IACzDhF,KAAKiF,qBAAuB,IAAA,EAE9BjF,KAAKmF,UAAY,KACTZ,EAAAd,QAAQ2B,KAAKb,EAAM/C,QACzB+C,EAAMb,UAAU0B,KAAKb,EAAMhC,OAAOrL,UAC5BqN,EAAAZ,MAAQY,EAAMhC,OAAOqB,IAAA,EAE7B5D,KAAKqF,MAAQ,KACLd,EAAA/C,OAAO4D,KAAKb,EAAMd,SACxBc,EAAMhC,OAAOrL,SAASkO,KAAKb,EAAMb,WAC3Ba,EAAAhC,OAAOqB,KAAOW,EAAMZ,MAC1BY,EAAMhC,OAAO+C,yBACbf,EAAMjD,cAAciE,GACpBhB,EAAMC,SACNgB,EAAQC,EAAMC,IAAA,EAEhB1F,KAAKwE,aACG,MAAApC,EAAS,IAAIM,EACbiD,EAAK,IAAIjD,EAAQ,EAAG,EAAG,GACvBkD,GAAO,IAAIC,GAAaC,mBAAmBvD,EAAOoD,GAAIA,GACtDI,EAAcH,EAAK9N,QAAQkO,SAC3BC,EAAe,IAAIvD,EACnBwD,EAAiB,IAAIL,EACrBM,EAAQ,EAAI7K,KAAK4G,GACvB,OAAO,WACC,MAAAhL,EAAWqN,EAAMhC,OAAOrL,SACzB0O,EAAAE,mBAAmBvD,EAAOoD,GAAIA,GACvBI,EAAAX,KAAKQ,GAAMI,SACvB5D,EAAOgD,KAAKlO,GAAUkP,IAAI7B,EAAM/C,QAChCY,EAAOiE,gBAAgBT,GACvB9B,EAAUwC,eAAelE,GACrBmC,EAAMgC,YAAcf,IAAUC,EAAMC,MACtCc,EAuKG,EAAIlL,KAAK4G,GAAK,GAAK,GAAKqC,EAAMkC,iBArK/BlC,EAAMmC,eACE5C,EAAAG,OAASK,EAAeL,MAAQM,EAAMoC,cACtC7C,EAAAC,KAAOO,EAAeP,IAAMQ,EAAMoC,gBAE5C7C,EAAUG,OAASK,EAAeL,MAClCH,EAAUC,KAAOO,EAAeP,KAElC,IAAI6C,EAAMrC,EAAMsC,gBACZxM,EAAMkK,EAAMuC,gBACZC,SAASH,IAAQG,SAAS1M,KACxBuM,GAAOtL,KAAK4G,GACP0E,GAAAT,EACAS,EAAMtL,KAAK4G,KACX0E,GAAAT,GACL9L,GAAOiB,KAAK4G,GACd7H,GAAO8L,EACA9L,EAAMiB,KAAK4G,KAClB7H,GAAO8L,GAEGrC,EAAAG,MADR2C,GAAOvM,EACSiB,KAAKjB,IAAIuM,EAAKtL,KAAKsL,IAAIvM,EAAKyJ,EAAUG,QAEtCH,EAAUG,OAAS2C,EAAMvM,GAAO,EAAIiB,KAAKjB,IAAIuM,EAAK9C,EAAUG,OAAS3I,KAAKsL,IAAIvM,EAAKyJ,EAAUG,QAGzGH,EAAAC,IAAMzI,KAAKjB,IAAIkK,EAAMyC,cAAe1L,KAAKsL,IAAIrC,EAAM0C,cAAenD,EAAUC,MACtFD,EAAUoD,YACkB,IAAxB3C,EAAMmC,cACRnC,EAAM/C,OAAO2F,gBAAgBC,EAAW7C,EAAMoC,eAExCpC,EAAA/C,OAAOpE,IAAIgK,GAEf7C,EAAM8C,cAAgBC,GAAqB/C,EAAMhC,OAAOgF,qBAChDzD,EAAArE,OAAS+H,EAAc1D,EAAUrE,QAE3CqE,EAAUrE,OAAS+H,EAAc1D,EAAUrE,OAASgI,GAEtDrF,EAAOsF,iBAAiB5D,GACxB1B,EAAOiE,gBAAgBN,GACvB7O,EAASkO,KAAKb,EAAM/C,QAAQpE,IAAIgF,GAC3BmC,EAAMhC,OAAOoF,kBAChBpD,EAAMhC,OAAOqF,eACTrD,EAAAhC,OAAOsF,OAAOtD,EAAM/C,SACE,IAAxB+C,EAAMmC,eACOpC,EAAAL,OAAS,EAAIM,EAAMoC,cACnBrC,EAAAP,KAAO,EAAIQ,EAAMoC,cACtBS,EAAAU,eAAe,EAAIvD,EAAMoC,iBAEpBrC,EAAA/I,IAAI,EAAG,EAAG,GACf6L,EAAA7L,IAAI,EAAG,EAAG,IAEtB,IAAIwM,GAAc,EACd,GAAAxD,EAAM8C,cAAgBC,EAAmB,CAC3C,IAAIU,EAAY,KAChB,GAAIzD,EAAMhC,kBAAkB0F,GAAqB1D,EAAMhC,OAAO2F,oBAAqB,CAC3E,MAAAC,EAAa/F,EAAOxK,SACdoQ,EAAAR,EAAcW,EAAaV,GACvC,MAAMW,EAAcD,EAAaH,EACjCzD,EAAMhC,OAAOrL,SAASiQ,gBAAgBkB,EAAgBD,GACtD7D,EAAMhC,OAAO+F,mBACzB,MAAA,GAAqB/D,EAAMhC,OAAOgF,qBAAsB,CAC5C,MAAMgB,EAAc,IAAI7F,EAAQ8F,EAAMpP,EAAGoP,EAAMC,EAAG,GACtCF,EAAAG,UAAUnE,EAAMhC,QAC5BgC,EAAMhC,OAAOqB,KAAOtI,KAAKjB,IAAIkK,EAAMoE,QAASrN,KAAKsL,IAAIrC,EAAMqE,QAASrE,EAAMhC,OAAOqB,KAAO6D,IACxFlD,EAAMhC,OAAO+C,yBACCyC,GAAA,EACd,MAAMc,EAAa,IAAInG,EAAQ8F,EAAMpP,EAAGoP,EAAMC,EAAG,GACtCI,EAAAH,UAAUnE,EAAMhC,QAC3BgC,EAAMhC,OAAOrL,SAASkP,IAAIyC,GAAYzL,IAAImL,GAC1ChE,EAAMhC,OAAO+F,oBACbN,EAAY5F,EAAOxK,QAC/B,MACYjB,QAAQC,KAAK,2FACb2N,EAAM8C,cAAe,EAEL,OAAdW,IACEzD,EAAMuE,mBACRvE,EAAM/C,OAAOjG,IAAI,EAAG,GAAG,GAAIwN,mBAAmBxE,EAAMhC,OAAOyG,QAAQlB,eAAeE,GAAW5K,IAAImH,EAAMhC,OAAOrL,WAE9G0K,GAAKqH,OAAO7D,KAAKb,EAAMhC,OAAOrL,UACzB0K,GAAAsH,UAAU3N,IAAI,EAAG,MAAOwN,mBAAmBxE,EAAMhC,OAAOyG,QACzD1N,KAAK+I,IAAIE,EAAMhC,OAAOoD,GAAGwD,IAAIvH,GAAKsH,YAAclH,GAC3CO,EAAAsF,OAAOtD,EAAM/C,SAEpBM,GAAOsH,8BAA8B7E,EAAMhC,OAAOoD,GAAIpB,EAAM/C,QACvDI,GAAAyH,eAAevH,GAAQyC,EAAM/C,UAIlD,MAAmB+C,EAAMhC,kBAAkB+G,GAAsB/E,EAAMhC,OAAOgF,uBACpEQ,EAAwB,IAAVN,EACVM,IACFxD,EAAMhC,OAAOqB,KAAOtI,KAAKjB,IAAIkK,EAAMoE,QAASrN,KAAKsL,IAAIrC,EAAMqE,QAASrE,EAAMhC,OAAOqB,KAAO6D,IACxFlD,EAAMhC,OAAO+C,2BAKjB,OAFQmC,EAAA,EACYH,GAAA,KAChBS,GAAe9B,EAAasD,kBAAkBhF,EAAMhC,OAAOrL,UAAYsS,GAAO,GAAK,EAAItD,EAAeiD,IAAI5E,EAAMhC,OAAOkH,aAAeD,KACxIjF,EAAMjD,cAAciE,GACPU,EAAAb,KAAKb,EAAMhC,OAAOrL,UAChBgP,EAAAd,KAAKb,EAAMhC,OAAOkH,YACnB1B,GAAA,GACP,EAGjB,MAES/H,KAAA0J,QAAW3E,IACdR,EAAM/B,WAAauC,EACbR,EAAA/B,WAAWmH,MAAMC,YAAc,OAC/BrF,EAAA/B,WAAW3B,iBAAiB,cAAegJ,IAC3CtF,EAAA/B,WAAW3B,iBAAiB,cAAeiJ,IAC3CvF,EAAA/B,WAAW3B,iBAAiB,gBAAiBkJ,IAC7CxF,EAAA/B,WAAW3B,iBAAiB,QAASmJ,GAAY,EAEzDhK,KAAKiK,QAAU,KACb,IAAIlR,EAAIwF,EAAI2L,EAAIC,EAAIC,EAAIC,EACpB9F,EAAM/B,aACF+B,EAAA/B,WAAWmH,MAAMC,YAAc,QAEZ,OAA1B7Q,EAAKwL,EAAM/B,aAA+BzJ,EAAGoI,oBAAoB,cAAe0I,IACtD,OAA1BtL,EAAKgG,EAAM/B,aAA+BjE,EAAG4C,oBAAoB,cAAe2I,IACtD,OAA1BI,EAAK3F,EAAM/B,aAA+B0H,EAAG/I,oBAAoB,gBAAiB4I,IACxD,OAA1BI,EAAK5F,EAAM/B,aAA+B2H,EAAGhJ,oBAAoB,QAAS6I,IAChD,OAA1BI,EAAK7F,EAAM/B,aAA+B4H,EAAGE,cAAcnJ,oBAAoB,cAAeoJ,IACpE,OAA1BF,EAAK9F,EAAM/B,aAA+B6H,EAAGC,cAAcnJ,oBAAoB,YAAa4I,IAC1D,OAA/BxF,EAAMU,sBACFV,EAAAU,qBAAqB9D,oBAAoB,UAAW6D,GAC3D,EAEH,MAAMT,EAAQvE,KACRuF,EAAc,CAAErJ,KAAM,UACtBsO,EAAa,CAAEtO,KAAM,SACrBuO,EAAW,CAAEvO,KAAM,OACnBuJ,EAAQ,CACZC,MAAM,EACNzC,OAAQ,EACRE,MAAO,EACPC,IAAK,EACLsH,aAAc,EACdC,UAAW,EACXC,gBAAiB,EACjBC,mBAAoB,GAEtB,IAAIrF,EAAQC,EAAMC,KAClB,MAAM8D,EAAM,KACN1F,EAAY,IAAIgH,EAChBxG,EAAiB,IAAIwG,EAC3B,IAAIrD,EAAQ,EACN,MAAAL,EAAY,IAAI1E,EAChBqI,EAAc,IAAIC,EAClBC,EAAY,IAAID,EAChBE,EAAc,IAAIF,EAClBG,EAAW,IAAIH,EACfI,EAAS,IAAIJ,EACbK,EAAW,IAAIL,EACfM,EAAa,IAAIN,EACjBO,EAAW,IAAIP,EACfQ,EAAa,IAAIR,EACjB3C,EAAiB,IAAI3F,EACrB8F,EAAQ,IAAIwC,EAClB,IAAI1D,GAAoB,EACxB,MAAMmE,EAAW,GACXC,EAAmB,CAAA,EAIzB,SAASC,IACP,OAAOrQ,KAAK4D,IAAI,IAAMqF,EAAMqH,UAC7B,CACD,SAASpF,EAAWqF,GACdtH,EAAMuH,cAAgBvH,EAAMwH,uBAC9BzH,EAAeL,OAAS4H,EAExBvH,EAAeL,OAAS4H,CAE3B,CACD,SAASG,EAASH,GACZtH,EAAMuH,cAAgBvH,EAAM0H,qBAC9B3H,EAAeP,KAAO8H,EAEtBvH,EAAeP,KAAO8H,CAEzB,CACD,MAAMK,QACE,MAAAnS,EAAI,IAAI2I,EACP,OAAA,SAAkByJ,EAAUC,GAC/BrS,EAAAsS,oBAAoBD,EAAc,GAClCrS,EAAA+N,gBAAgBqE,GAClB/E,EAAUhK,IAAIrD,EACtB,MAEUuS,QACE,MAAAvS,EAAI,IAAI2I,EACP,OAAA,SAAgByJ,EAAUC,IACE,IAA7B7H,EAAMuE,mBACN/O,EAAAsS,oBAAoBD,EAAc,IAElCrS,EAAAsS,oBAAoBD,EAAc,GACpCrS,EAAEwS,aAAahI,EAAMhC,OAAOoD,GAAI5L,IAElCA,EAAE+N,eAAeqE,GACjB/E,EAAUhK,IAAIrD,EACtB,MAEUyS,QACE,MAAApK,EAAS,IAAIM,EACZ,OAAA,SAAc+J,EAAQC,GAC3B,MAAMC,EAAUpI,EAAM/B,WACtB,GAAImK,GAAWpI,EAAMhC,kBAAkB0F,GAAqB1D,EAAMhC,OAAO2F,oBAAqB,CACtF,MAAAhR,EAAWqN,EAAMhC,OAAOrL,SAC9BkL,EAAOgD,KAAKlO,GAAUkP,IAAI7B,EAAM/C,QAC5B,IAAAoL,EAAiBxK,EAAOxK,SACVgV,GAAAtR,KAAKuR,IAAItI,EAAMhC,OAAOuK,IAAM,EAAIxR,KAAK4G,GAAK,KAC5DgK,EAAQ,EAAIO,EAASG,EAAiBD,EAAQI,aAAcxI,EAAMhC,OAAOyG,QACzEsD,EAAM,EAAII,EAASE,EAAiBD,EAAQI,aAAcxI,EAAMhC,OAAOyG,OACjF,MAAmB2D,GAAWpI,EAAMhC,kBAAkB+G,GAAsB/E,EAAMhC,OAAOgF,sBAC/E2E,EACEO,GAAUlI,EAAMhC,OAAOyK,MAAQzI,EAAMhC,OAAO0K,MAAQ1I,EAAMhC,OAAOqB,KAAO+I,EAAQO,YAChF3I,EAAMhC,OAAOyG,QAEfsD,EACEI,GAAUnI,EAAMhC,OAAO4K,IAAM5I,EAAMhC,OAAO6K,QAAU7I,EAAMhC,OAAOqB,KAAO+I,EAAQI,aAChFxI,EAAMhC,OAAOyG,UAGfrS,QAAQC,KAAK,gFACb2N,EAAM8I,WAAY,EAE5B,MAEI,SAASC,EAASC,GACZhJ,EAAMhC,kBAAkB0F,GAAqB1D,EAAMhC,OAAO2F,qBAAuB3D,EAAMhC,kBAAkB+G,GAAsB/E,EAAMhC,OAAOgF,qBACtIE,EAAA8F,GAER5W,QAAQC,KAAK,uFACb2N,EAAMiJ,YAAa,EAEtB,CACD,SAASC,EAASC,GAChBJ,EAAS7F,EAAQiG,EAClB,CACD,SAASC,EAAQD,GACfJ,EAAS7F,EAAQiG,EAClB,CACD,SAASE,EAAsBrM,GAC7B,IAAKgD,EAAM8C,eAAiB9C,EAAM/B,WAChC,OAEkB8E,GAAA,EACd,MAAAuG,EAAOtJ,EAAM/B,WAAWsL,wBACxB1U,EAAImI,EAAMwM,QAAUF,EAAKZ,KACzBxE,EAAIlH,EAAMyM,QAAUH,EAAKV,IACzBc,EAAIJ,EAAKhP,MACTqP,EAAIL,EAAKrO,OACTgJ,EAAApP,EAAIA,EAAI6U,EAAI,EAAI,EACtBzF,EAAMC,GAAMA,EAAIyF,EAAK,EAAI,EACzB7F,EAAe9M,IAAIiN,EAAMpP,EAAGoP,EAAMC,EAAG,GAAGC,UAAUnE,EAAMhC,QAAQ6D,IAAI7B,EAAMhC,OAAOrL,UAAUiX,WAC5F,CACD,SAAS3G,EAAc4G,GACd,OAAA9S,KAAKjB,IAAIkK,EAAM8J,YAAa/S,KAAKsL,IAAIrC,EAAM+J,YAAaF,GAChE,CACD,SAASG,EAAsBhN,GAC7BwJ,EAAYxP,IAAIgG,EAAMwM,QAASxM,EAAMyM,QACtC,CAKD,SAASQ,EAAmBjN,GAC1B4J,EAAS5P,IAAIgG,EAAMwM,QAASxM,EAAMyM,QACnC,CAgED,SAASS,IACH,GAAmB,GAAnBhD,EAAS7T,OACCmT,EAAAxP,IAAIkQ,EAAS,GAAGiD,MAAOjD,EAAS,GAAGkD,WAC1C,CACC,MAAAvV,EAAI,IAAOqS,EAAS,GAAGiD,MAAQjD,EAAS,GAAGiD,OAC3CjG,EAAI,IAAOgD,EAAS,GAAGkD,MAAQlD,EAAS,GAAGkD,OACrC5D,EAAAxP,IAAInC,EAAGqP,EACpB,CACF,CACD,SAASmG,IACH,GAAmB,GAAnBnD,EAAS7T,OACFuT,EAAA5P,IAAIkQ,EAAS,GAAGiD,MAAOjD,EAAS,GAAGkD,WACvC,CACC,MAAAvV,EAAI,IAAOqS,EAAS,GAAGiD,MAAQjD,EAAS,GAAGiD,OAC3CjG,EAAI,IAAOgD,EAAS,GAAGkD,MAAQlD,EAAS,GAAGkD,OACxCxD,EAAA5P,IAAInC,EAAGqP,EACjB,CACF,CACD,SAASoG,IACP,MAAMC,EAAKrD,EAAS,GAAGiD,MAAQjD,EAAS,GAAGiD,MACrCK,EAAKtD,EAAS,GAAGkD,MAAQlD,EAAS,GAAGkD,MACrCxC,EAAW7Q,KAAK0T,KAAKF,EAAKA,EAAKC,EAAKA,GAC/BzD,EAAA/P,IAAI,EAAG4Q,EACnB,CAaD,SAAS8C,EAAsB1N,GACzB,GAAmB,GAAnBkK,EAAS7T,OACXqT,EAAU1P,IAAIgG,EAAMmN,MAAOnN,EAAMoN,WAC5B,CACC,MAAAzX,EAAWgY,GAAyB3N,GACpCnI,EAAI,IAAOmI,EAAMmN,MAAQxX,EAASkC,GAClCqP,EAAI,IAAOlH,EAAMoN,MAAQzX,EAASuR,GAC9BwC,EAAA1P,IAAInC,EAAGqP,EAClB,CACDyC,EAAYiE,WAAWlE,EAAWF,GAAajD,eAAevD,EAAM6K,aACpE,MAAMzC,EAAUpI,EAAM/B,WAClBmK,IACFnG,EAAW,EAAIlL,KAAK4G,GAAKgJ,EAAY9R,EAAIuT,EAAQI,cACjDf,EAAS,EAAI1Q,KAAK4G,GAAKgJ,EAAYzC,EAAIkE,EAAQI,eAEjDhC,EAAY3F,KAAK6F,EAClB,CACD,SAASoE,EAAmB9N,GACtB,GAAmB,GAAnBkK,EAAS7T,OACXwT,EAAO7P,IAAIgG,EAAMmN,MAAOnN,EAAMoN,WACzB,CACC,MAAAzX,EAAWgY,GAAyB3N,GACpCnI,EAAI,IAAOmI,EAAMmN,MAAQxX,EAASkC,GAClCqP,EAAI,IAAOlH,EAAMoN,MAAQzX,EAASuR,GACjC2C,EAAA7P,IAAInC,EAAGqP,EACf,CACD4C,EAAS8D,WAAW/D,EAAQD,GAAUrD,eAAevD,EAAM+K,UACvD9C,EAAAnB,EAASjS,EAAGiS,EAAS5C,GACzB0C,EAAS/F,KAAKgG,EACf,CACD,SAASmE,EAAqBhO,GACtB,MAAArK,EAAWgY,GAAyB3N,GACpCuN,EAAKvN,EAAMmN,MAAQxX,EAASkC,EAC5B2V,EAAKxN,EAAMoN,MAAQzX,EAASuR,EAC5B0D,EAAW7Q,KAAK0T,KAAKF,EAAKA,EAAKC,EAAKA,GACjCxD,EAAAhQ,IAAI,EAAG4Q,GACLX,EAAAjQ,IAAI,EAAGD,KAAK4D,IAAIqM,EAAS9C,EAAI6C,EAAW7C,EAAGlE,EAAMqH,YAC5D6B,EAASjC,EAAW/C,GACpB6C,EAAWlG,KAAKmG,EACjB,CAaD,SAASzB,GAAcvI,GACrB,IAAIxI,EAAIwF,GACc,IAAlBgG,EAAMiL,UAEc,IAApB/D,EAAS7T,SACgB,OAA1BmB,EAAKwL,EAAM/B,aAA+BzJ,EAAGuR,cAAczJ,iBAAiB,cAAe0J,IACjE,OAA1BhM,EAAKgG,EAAM/B,aAA+BjE,EAAG+L,cAAczJ,iBAAiB,YAAakJ,KAyM9F,SAAoBxI,GAClBkK,EAASlU,KAAKgK,EACf,CAzMCkO,CAAWlO,GACe,UAAtBA,EAAMmO,YAoHZ,SAAsBnO,GAEpB,OADAoO,GAAapO,GACLkK,EAAS7T,QACf,KAAK,EACK,OAAA2M,EAAMqL,QAAQvM,KACpB,KAAKC,EAAML,OACT,IAA2B,IAAvBsB,EAAMsL,aACR,WAEFrK,EAAQC,EAAMiF,aACd,MACF,KAAKpH,EAAMF,IACT,IAAwB,IAApBmB,EAAM8I,UACR,WAEF7H,EAAQC,EAAMkF,UACd,MACF,QACEnF,EAAQC,EAAMC,KAElB,MACF,KAAK,EACK,OAAAnB,EAAMqL,QAAQrM,KACpB,KAAKD,EAAME,UACT,IAAyB,IAArBe,EAAMiJ,aAA4C,IAApBjJ,EAAM8I,UACtC,OArNN9I,EAAMiJ,gBAENjJ,EAAM8I,eAqNF7H,EAAQC,EAAMmF,gBACd,MACF,KAAKtH,EAAMwM,aACT,IAAyB,IAArBvL,EAAMiJ,aAA+C,IAAvBjJ,EAAMsL,aACtC,OArNNtL,EAAMiJ,gBAENjJ,EAAMsL,kBAqNFrK,EAAQC,EAAMoF,mBACd,MACF,QACErF,EAAQC,EAAMC,KAElB,MACF,QACEF,EAAQC,EAAMC,KAEdF,IAAUC,EAAMC,MAClBnB,EAAMjD,cAAckJ,EAEvB,CAhKGuF,CAAaxO,GAyBjB,SAAqBA,GACf,IAAAyO,EACJ,OAAQzO,EAAM0O,QACZ,KAAK,EACHD,EAAczL,EAAM2L,aAAatN,KACjC,MACF,KAAK,EACHoN,EAAczL,EAAM2L,aAAahN,OACjC,MACF,KAAK,EACH8M,EAAczL,EAAM2L,aAAapN,MACjC,MACF,QACgBkN,GAAA,EAElB,OAAQA,GACN,KAAKhN,EAAMG,MACT,IAAyB,IAArBoB,EAAMiJ,WACR,QAnNR,SAA8BjM,GAC5BqM,EAAsBrM,GACtB+J,EAAW/P,IAAIgG,EAAMwM,QAASxM,EAAMyM,QACrC,CAiNKmC,CAAqB5O,GACrBiE,EAAQC,EAAMtC,MACd,MACF,KAAKH,EAAMC,OACT,GAAI1B,EAAM6O,SAAW7O,EAAM8O,SAAW9O,EAAM+O,SAAU,CACpD,IAAwB,IAApB/L,EAAM8I,UACR,OACFmB,EAAmBjN,GACnBiE,EAAQC,EAAMrC,GAC1B,KAAiB,CACL,IAA2B,IAAvBmB,EAAMsL,aACR,OACFtB,EAAsBhN,GACtBiE,EAAQC,EAAMxC,MACf,CACD,MACF,KAAKD,EAAMI,IACT,GAAI7B,EAAM6O,SAAW7O,EAAM8O,SAAW9O,EAAM+O,SAAU,CACpD,IAA2B,IAAvB/L,EAAMsL,aACR,OACFtB,EAAsBhN,GACtBiE,EAAQC,EAAMxC,MAC1B,KAAiB,CACL,IAAwB,IAApBsB,EAAM8I,UACR,OACFmB,EAAmBjN,GACnBiE,EAAQC,EAAMrC,GACf,CACD,MACF,QACEoC,EAAQC,EAAMC,KAEdF,IAAUC,EAAMC,MAClBnB,EAAMjD,cAAckJ,EAEvB,CA7EG+F,CAAYhP,GAEf,CACD,SAASgJ,GAAchJ,IACC,IAAlBgD,EAAMiL,UAEgB,UAAtBjO,EAAMmO,YAyJZ,SAAqBnO,GAEnB,OADAoO,GAAapO,GACLiE,GACN,KAAKC,EAAMiF,aACT,IAA2B,IAAvBnG,EAAMsL,aACR,OACFZ,EAAsB1N,GACtBgD,EAAMC,SACN,MACF,KAAKiB,EAAMkF,UACT,IAAwB,IAApBpG,EAAM8I,UACR,OACFgC,EAAmB9N,GACnBgD,EAAMC,SACN,MACF,KAAKiB,EAAMmF,gBACT,IAAyB,IAArBrG,EAAMiJ,aAA4C,IAApBjJ,EAAM8I,UACtC,QAxMR,SAAiC9L,GAC3BgD,EAAMiJ,YACR+B,EAAqBhO,GACnBgD,EAAM8I,WACRgC,EAAmB9N,EACtB,CAoMKiP,CAAwBjP,GACxBgD,EAAMC,SACN,MACF,KAAKiB,EAAMoF,mBACT,IAAyB,IAArBtG,EAAMiJ,aAA+C,IAAvBjJ,EAAMsL,aACtC,QAxMR,SAAoCtO,GAC9BgD,EAAMiJ,YACR+B,EAAqBhO,GACnBgD,EAAMsL,cACRZ,EAAsB1N,EACzB,CAoMKkP,CAA2BlP,GAC3BgD,EAAMC,SACN,MACF,QACEgB,EAAQC,EAAMC,KAEnB,CAtLGgL,CAAYnP,GAuEhB,SAAqBA,GACnB,IAAsB,IAAlBgD,EAAMiL,QACR,OACF,OAAQhK,GACN,KAAKC,EAAMxC,OACT,IAA2B,IAAvBsB,EAAMsL,aACR,QAvPR,SAA+BtO,GAC7B0J,EAAU1P,IAAIgG,EAAMwM,QAASxM,EAAMyM,SACnC9C,EAAYiE,WAAWlE,EAAWF,GAAajD,eAAevD,EAAM6K,aACpE,MAAMzC,EAAUpI,EAAM/B,WAClBmK,IACFnG,EAAW,EAAIlL,KAAK4G,GAAKgJ,EAAY9R,EAAIuT,EAAQI,cACjDf,EAAS,EAAI1Q,KAAK4G,GAAKgJ,EAAYzC,EAAIkE,EAAQI,eAEjDhC,EAAY3F,KAAK6F,GACjB1G,EAAMC,QACP,CA8OKmM,CAAsBpP,GACtB,MACF,KAAKkE,EAAMtC,MACT,IAAyB,IAArBoB,EAAMiJ,WACR,QAjPR,SAA8BjM,GAC5BgK,EAAShQ,IAAIgG,EAAMwM,QAASxM,EAAMyM,SACvBxC,EAAA2D,WAAW5D,EAAUD,GAC5BE,EAAW/C,EAAI,EACjBgF,EAAS9B,KACAH,EAAW/C,EAAI,GACxBkF,EAAQhC,KAEVL,EAAWlG,KAAKmG,GAChBhH,EAAMC,QACP,CAwOKoM,CAAqBrP,GACrB,MACF,KAAKkE,EAAMrC,IACT,IAAwB,IAApBmB,EAAM8I,UACR,QA3OR,SAA4B9L,GAC1B6J,EAAO7P,IAAIgG,EAAMwM,QAASxM,EAAMyM,SAChC3C,EAAS8D,WAAW/D,EAAQD,GAAUrD,eAAevD,EAAM+K,UACvD9C,EAAAnB,EAASjS,EAAGiS,EAAS5C,GACzB0C,EAAS/F,KAAKgG,GACd7G,EAAMC,QACP,CAsOKqM,CAAmBtP,GAGxB,CAzFGuP,CAAYvP,GAEf,CACD,SAASwI,GAAYxI,GACnB,IAAIxI,EAAIwF,EAAI2L,GAyLd,SAAuB3I,UACdmK,EAAiBnK,EAAMwP,WAC9B,IAAA,IAAS1Z,EAAI,EAAGA,EAAIoU,EAAS7T,OAAQP,IACnC,GAAIoU,EAASpU,GAAG0Z,WAAaxP,EAAMwP,UAEjC,YADStF,EAAApK,OAAOhK,EAAG,EAIxB,CAhMC2Z,CAAczP,GACU,IAApBkK,EAAS7T,SACgB,OAA1BmB,EAAKwL,EAAM/B,aAA+BzJ,EAAGkY,sBAAsB1P,EAAMwP,WAC/C,OAA1BxS,EAAKgG,EAAM/B,aAA+BjE,EAAG+L,cAAcnJ,oBAAoB,cAAeoJ,IACpE,OAA1BL,EAAK3F,EAAM/B,aAA+B0H,EAAGI,cAAcnJ,oBAAoB,YAAa4I,KAE/FxF,EAAMjD,cAAcmJ,GACpBjF,EAAQC,EAAMC,IACf,CA6ED,SAASsE,GAAazI,IACE,IAAlBgD,EAAMiL,UAA0C,IAArBjL,EAAMiJ,YAAwBhI,IAAUC,EAAMC,MAAQF,IAAUC,EAAMxC,SAGrG1B,EAAM2P,iBACN3M,EAAMjD,cAAckJ,GA9OtB,SAA0BjJ,GACxBqM,EAAsBrM,GAClBA,EAAMmL,OAAS,EACjBiB,EAAQhC,KACCpK,EAAMmL,OAAS,GACxBe,EAAS9B,KAEXpH,EAAMC,QACP,CAuOC2M,CAAiB5P,GACjBgD,EAAMjD,cAAcmJ,GACrB,CACD,SAASzF,GAAUzD,IACK,IAAlBgD,EAAMiL,UAAyC,IAApBjL,EAAM8I,WA1OvC,SAAuB9L,GACrB,IAAI6P,GAAc,EAClB,OAAQ7P,EAAM8P,MACZ,KAAK9M,EAAM+M,KAAKzO,GACV2J,EAAA,EAAGjI,EAAMgN,aACCH,GAAA,EACd,MACF,KAAK7M,EAAM+M,KAAKvO,OACVyJ,EAAA,GAAIjI,EAAMgN,aACAH,GAAA,EACd,MACF,KAAK7M,EAAM+M,KAAK1O,KACV4J,EAAAjI,EAAMgN,YAAa,GACTH,GAAA,EACd,MACF,KAAK7M,EAAM+M,KAAKxO,MACV0J,GAACjI,EAAMgN,YAAa,GACVH,GAAA,EAGdA,IACF7P,EAAM2P,iBACN3M,EAAMC,SAET,CAoNCgN,CAAcjQ,EACf,CA8ED,SAASsI,GAActI,IACC,IAAlBgD,EAAMiL,SAEVjO,EAAM2P,gBACP,CAaD,SAASvB,GAAapO,GAChB,IAAArK,EAAWwU,EAAiBnK,EAAMwP,gBACrB,IAAb7Z,IACFA,EAAW,IAAI8T,EACEU,EAAAnK,EAAMwP,WAAa7Z,GAEtCA,EAASqE,IAAIgG,EAAMmN,MAAOnN,EAAMoN,MACjC,CACD,SAASO,GAAyB3N,GAC1B,MAAAkQ,EAAUlQ,EAAMwP,YAActF,EAAS,GAAGsF,UAAYtF,EAAS,GAAKA,EAAS,GAC5E,OAAAC,EAAiB+F,EAAQV,UACjC,CACD/Q,KAAK2N,QAAU,CAACD,EAAa/B,OAC3BgC,EAAQD,GACRnJ,EAAMC,QAAM,EAEdxE,KAAKyN,SAAW,CAACC,EAAa/B,OAC5B8B,EAASC,GACTnJ,EAAMC,QAAM,EAEdxE,KAAK0R,SAAW,IACPjK,EAEJzH,KAAAsN,SAAYC,IACfD,EAASC,GACThJ,EAAMC,QAAM,EAEdxE,KAAK2L,aAAe,IACXA,SAEU,IAAfnJ,GACFxC,KAAK0J,QAAQlH,GACfxC,KAAKwE,QACN,ECj2BH,SAASmN,GAAWlQ,GACd,GAAuB,oBAAhB1D,YACT,OAAO,IAAIA,aAAcC,OAAOyD,GAElC,IAAIjI,EAAI,GACR,IAAA,IAASnC,EAAI,EAAGua,EAAKnQ,EAAM7J,OAAQP,EAAIua,EAAIva,IACzCmC,GAAKqY,OAAOC,aAAarQ,EAAMpK,IAE7B,IACK,OAAA0a,mBAAmBC,OAAOxY,GAClC,OAAQ+D,IACA,OAAA/D,CACR,CACH,CCTA,MAAMyY,GAAiB,OACjBC,GAAuB,cAG7B,MAAMC,WAAmBC,EACvB,WAAAhU,CAAYiU,GACV3S,MAAM2S,GACNrS,KAAKsS,YAAc,KACnBtS,KAAKuS,WAAa,KAClBvS,KAAKwS,eAAiB,KACtBxS,KAAKyS,gBAAkB,GAClBzS,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIC,GAAgCD,EACjD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIE,GAAiCF,EAClD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIG,GAA2BH,EAC5C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAII,GAAyBJ,EAC1C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIK,GAAyBL,EAC1C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIM,GAA4BN,EAC7C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIO,GAAmCP,EACpD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIQ,GAA6BR,EAC9C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIS,GAA0BT,EAC3C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIU,GAAuCV,EACxD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIW,GAA+BX,EAChD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIY,GAAkCZ,EACnD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIa,GAAiCb,EAClD,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIc,GAA2Bd,EAC5C,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIe,GAAoBf,EACrC,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIgB,GAAuBhB,EACxC,IACS3S,KAAA0S,UAAS,SAASC,GACd,OAAA,IAAIiB,GAAsBjB,EACvC,GACG,CACD,IAAAkB,CAAKC,EAAKC,EAAQC,EAAYC,GAC5B,MAAM1P,EAAQvE,KACV,IAAAkU,EACA,GAAsB,KAAtBlU,KAAKkU,aACPA,EAAelU,KAAKkU,kBAC1B,GAA6B,KAAdlU,KAAKmU,KAAa,CACrB,MAAAC,EAAcC,EAAYC,eAAeR,GAC/CI,EAAeG,EAAYE,WAAWH,EAAapU,KAAKmU,KAC9D,MACqBD,EAAAG,EAAYC,eAAeR,GAEvC9T,KAAAqS,QAAQmC,UAAUV,GACjB,MAAAW,EAAW,SAASlX,GACpB0W,EACFA,EAAQ1W,GAER5G,QAAQS,MAAMmG,GAEVgH,EAAA8N,QAAQqC,UAAUZ,GAClBvP,EAAA8N,QAAQsC,QAAQb,EAC5B,EACUc,EAAS,IAAIC,EAAW7U,KAAKqS,SAC5BuC,EAAAE,QAAQ9U,KAAKmU,MACpBS,EAAOG,gBAAgB,eAChBH,EAAAI,iBAAiBhV,KAAKiV,eACtBL,EAAAM,mBAAmBlV,KAAKmV,iBACxBP,EAAAf,KACLC,GACA,SAASnW,GACH,IACI4G,EAAA6Q,MACJzX,EACAuW,GACA,SAASmB,GACPtB,EAAOsB,GACD9Q,EAAA8N,QAAQsC,QAAQb,EACvB,GACDW,EAEH,OAAQlX,IACPkX,EAASlX,GACV,CACF,GACDyW,EACAS,EAEH,CACD,cAAAa,CAAehD,GAEN,OADPtS,KAAKsS,YAAcA,EACZtS,IACR,CACD,YAAAuV,GACQ,MAAA,IAAIC,MAAM,mGACjB,CACD,aAAAC,CAAclD,GAEL,OADPvS,KAAKuS,WAAaA,EACXvS,IACR,CACD,iBAAA0V,CAAkBlD,GAET,OADPxS,KAAKwS,eAAiBA,EACfxS,IACR,CACD,QAAA0S,CAASiD,GAIA,OAH4C,IAA/C3V,KAAKyS,gBAAgBxR,QAAQ0U,IAC1B3V,KAAAyS,gBAAgBlb,KAAKoe,GAErB3V,IACR,CACD,UAAA4V,CAAWD,GAIF,OAH4C,IAA/C3V,KAAKyS,gBAAgBxR,QAAQ0U,IAC/B3V,KAAKyS,gBAAgBpR,OAAOrB,KAAKyS,gBAAgBxR,QAAQ0U,GAAW,GAE/D3V,IACR,CACD,KAAAoV,CAAMzX,EAAMwW,EAAMJ,EAAQE,GACpB,IAAA4B,EACJ,MAAMC,EAAa,CAAA,EACbC,EAAU,CAAA,EACZ,GAAgB,iBAATpY,EACFkY,EAAAG,KAAKZ,MAAMzX,QACxB,GAAeA,aAAgBsY,YAAa,CAEtC,GADctE,GAAW,IAAI1Z,WAAW0F,EAAK+D,MAAM,EAAG,OACxCwU,GAA+B,CACvC,IACFJ,EAAWK,GAAWC,iBAAmB,IAAIC,GAAoB1Y,EAClE,OAAQvG,GAGP,YAFI6c,GACFA,EAAQ7c,GAEX,CACDye,EAAOG,KAAKZ,MAAMU,EAAWK,GAAWC,iBAAiBE,QACjE,MACQT,EAAOG,KAAKZ,MAAMzD,GAAW,IAAI1Z,WAAW0F,IAEpD,MACakY,EAAAlY,EAEL,QAAe,IAAfkY,EAAKU,OAAoBV,EAAKU,MAAMpgB,QAAQ,GAAK,EAGnD,YAFI8d,GACMA,EAAA,IAAIuB,MAAM,6EAGhB,MAAA7C,EAAS,IAAI6D,GAAWX,EAAM,CAClC1B,KAAMA,GAAQnU,KAAKkU,cAAgB,GACnCuC,YAAazW,KAAKyW,YAClBxB,cAAejV,KAAKiV,cACpB5C,QAASrS,KAAKqS,QACdE,WAAYvS,KAAKuS,WACjBC,eAAgBxS,KAAKwS,iBAEhBG,EAAA+D,WAAW1B,iBAAiBhV,KAAKiV,eACxC,IAAA,IAAS5d,EAAI,EAAGA,EAAI2I,KAAKyS,gBAAgB7a,OAAQP,IAAK,CACpD,MAAMsf,EAAS3W,KAAKyS,gBAAgBpb,GAAGsb,GAClCgE,EAAOC,MACVjgB,QAAQS,MAAM,wDACR2e,EAAAY,EAAOC,MAAQD,EACZb,EAAAa,EAAOC,OAAQ,CAC3B,CACD,GAAIf,EAAKgB,eACP,IAAA,IAASxf,EAAI,EAAGA,EAAIwe,EAAKgB,eAAejf,SAAUP,EAAG,CAC7C,MAAAyf,EAAgBjB,EAAKgB,eAAexf,GACpC0f,EAAqBlB,EAAKkB,oBAAsB,GACtD,OAAQD,GACN,KAAKX,GAAWa,oBACHlB,EAAAgB,GAAiB,IAAIG,GAChC,MACF,KAAKd,GAAWe,2BACdpB,EAAWgB,GAAiB,IAAIK,GAAkCtB,EAAM7V,KAAKsS,aAC7E,MACF,KAAK6D,GAAWiB,sBACHtB,EAAAgB,GAAiB,IAAIO,GAChC,MACF,KAAKlB,GAAWmB,sBACHxB,EAAAgB,GAAiB,IAAIS,GAChC,MACF,QACMR,EAAmB9V,QAAQ6V,IAAkB,QAAgC,IAA3Bf,EAAQe,IACpDngB,QAAAC,KAAK,wCAA0CkgB,EAAgB,MAG9E,CAEHnE,EAAO6E,cAAc1B,GACrBnD,EAAO8E,WAAW1B,GACXpD,EAAAyC,MAAMrB,EAAQE,EACtB,CACD,UAAAyD,CAAW/Z,EAAMwW,GACf,MAAM5P,EAAQvE,KACd,OAAO,IAAI2X,SAAQ,SAASC,EAASC,GACnCtT,EAAM6Q,MAAMzX,EAAMwW,EAAMyD,EAASC,EACvC,GACG,EAEH,SAASC,KACP,IAAIC,EAAU,CAAA,EACP,MAAA,CACLC,IAAK,SAASzX,GACZ,OAAOwX,EAAQxX,EAChB,EACDnD,IAAK,SAASmD,EAAKgC,GACjBwV,EAAQxX,GAAOgC,CAChB,EACD0V,OAAQ,SAAS1X,UACRwX,EAAQxX,EAChB,EACD2X,UAAW,WACTH,EAAU,CAAA,CACX,EAEL,CACA,MAAM5B,GAAa,CACjBC,gBAAiB,kBACjBc,2BAA4B,6BAC5BiB,oBAAqB,sBACrBC,wBAAyB,0BACzBC,yBAA0B,2BAC1BC,kBAAmB,oBACnBC,oBAAqB,sBACrBC,uBAAwB,yBACxBC,2BAA4B,6BAC5BC,0BAA2B,4BAC3BC,yBAA0B,2BAC1B3B,oBAAqB,sBACrB4B,qBAAsB,uBACtBC,mBAAoB,qBACpBzB,sBAAuB,wBACvBE,sBAAuB,wBACvBwB,gCAAiC,kCACjCC,mBAAoB,qBACpBC,iBAAkB,mBAClBC,iBAAkB,mBAClBC,wBAAyB,0BACzBC,wBAAyB,2BAE3B,MAAMzF,GACJ,WAAAtV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWgC,oBACvBnY,KAAKoZ,MAAQ,CAAEC,KAAM,CAAA,EAAIC,KAAM,CAAA,EAChC,CACD,SAAAC,GACE,MAAM5G,EAAS3S,KAAK2S,OACd6G,EAAWxZ,KAAK2S,OAAOkD,KAAK4D,OAAS,GAC3C,IAAA,IAASC,EAAY,EAAGC,EAAaH,EAAS5hB,OAAQ8hB,EAAYC,EAAYD,IAAa,CACnF,MAAAE,EAAUJ,EAASE,GACrBE,EAAQ9D,YAAc8D,EAAQ9D,WAAW9V,KAAK4W,YAAiD,IAAxCgD,EAAQ9D,WAAW9V,KAAK4W,MAAMiD,OAChFlH,EAAAmH,YAAY9Z,KAAKoZ,MAAOQ,EAAQ9D,WAAW9V,KAAK4W,MAAMiD,MAEhE,CACF,CACD,UAAAE,CAAWC,GACT,MAAMrH,EAAS3S,KAAK2S,OACdsH,EAAW,SAAWD,EAC5B,IAAIE,EAAavH,EAAOyG,MAAMpB,IAAIiC,GAC9B,GAAAC,EACK,OAAAA,EACT,MAAMrE,EAAOlD,EAAOkD,KAGdsE,IAFatE,EAAKC,YAAcD,EAAKC,WAAW9V,KAAK4W,OAAS,IACvCwD,QAAU,IACZJ,GACvB,IAAAK,EACE,MAAAC,EAAQ,IAAIC,EAAM,eACD,IAAnBJ,EAASG,OACXA,EAAME,OAAOL,EAASG,MAAM,GAAIH,EAASG,MAAM,GAAIH,EAASG,MAAM,GAAIpI,IACxE,MAAMuI,OAA2B,IAAnBN,EAASM,MAAmBN,EAASM,MAAQ,EAC3D,OAAQN,EAASje,MACf,IAAK,cACSme,EAAA,IAAIK,EAAiBJ,GACjCD,EAAU7Y,OAAOtK,SAASqE,IAAI,EAAG,GAAK,GAC5B8e,EAAAjd,IAAIid,EAAU7Y,QACxB,MACF,IAAK,QACS6Y,EAAA,IAAIM,EAAWL,GAC3BD,EAAUlO,SAAWsO,EACrB,MACF,IAAK,OACSJ,EAAA,IAAIO,EAAUN,GAC1BD,EAAUlO,SAAWsO,EACZN,EAAAU,KAAOV,EAASU,MAAQ,CAAA,EACxBV,EAAAU,KAAKC,oBAAkD,IAAjCX,EAASU,KAAKC,eAA4BX,EAASU,KAAKC,eAAiB,EAC/FX,EAAAU,KAAKE,oBAAkD,IAAjCZ,EAASU,KAAKE,eAA4BZ,EAASU,KAAKE,eAAiBzf,KAAK4G,GAAK,EACxGmY,EAAAxO,MAAQsO,EAASU,KAAKE,eAChCV,EAAUW,SAAW,EAAIb,EAASU,KAAKC,eAAiBX,EAASU,KAAKE,eACtEV,EAAU7Y,OAAOtK,SAASqE,IAAI,EAAG,GAAK,GAC5B8e,EAAAjd,IAAIid,EAAU7Y,QACxB,MACF,QACE,MAAM,IAAIgU,MAAM,4CAA8C2E,EAASje,MAUpE,OARPme,EAAUnjB,SAASqE,IAAI,EAAG,EAAG,GAC7B8e,EAAUY,MAAQ,EAClBC,GAAuBb,EAAWF,QACP,IAAvBA,EAASgB,YACXd,EAAUc,UAAYhB,EAASgB,WACjCd,EAAUzD,KAAOjE,EAAOyI,iBAAiBjB,EAASvD,MAAQ,SAAWoD,GACxDE,EAAAvC,QAAQC,QAAQyC,GACtB1H,EAAAyG,MAAMhc,IAAI6c,EAAUC,GACpBA,CACR,CACD,aAAAmB,CAAcnf,EAAMnF,GAClB,GAAa,UAATmF,EAEG,OAAA8D,KAAK+Z,WAAWhjB,EACxB,CACD,oBAAAukB,CAAqB5B,GACnB,MAAM6B,EAAQvb,KACR2S,EAAS3S,KAAK2S,OAEdiH,EADOjH,EAAOkD,KACC4D,MAAMC,GAErBM,GADWJ,EAAQ9D,YAAc8D,EAAQ9D,WAAW9V,KAAK4W,OAAS,IAC5CiD,MAC5B,YAAmB,IAAfG,EACK,KACFha,KAAK+Z,WAAWC,GAAYwB,MAAK,SAAS3B,GAC/C,OAAOlH,EAAO8I,YAAYF,EAAMnC,MAAOY,EAAYH,EACzD,GACG,EAEH,MAAM5C,GACJ,WAAA7Y,GACE4B,KAAK4W,KAAOT,GAAWa,mBACxB,CACD,eAAA0E,GACS,OAAAC,CACR,CACD,YAAAC,CAAaC,EAAgBC,EAAanJ,GACxC,MAAMoJ,EAAU,GAChBF,EAAevB,MAAQ,IAAIC,EAAM,EAAG,EAAG,GACvCsB,EAAeG,QAAU,EACzB,MAAMC,EAAoBH,EAAYI,qBACtC,GAAID,EAAmB,CACrB,GAAIE,MAAMC,QAAQH,EAAkBI,iBAAkB,CACpD,MAAM5a,EAAQwa,EAAkBI,gBACjBR,EAAAvB,MAAME,OAAO/Y,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIyQ,IAC3C2J,EAAAG,QAAUva,EAAM,EAChC,MAC0C,IAAvCwa,EAAkBK,kBACZP,EAAAxkB,KAAKob,EAAO4J,cAAcV,EAAgB,MAAOI,EAAkBK,iBAAkBrK,IAEhG,CACM,OAAA0F,QAAQ6E,IAAIT,EACpB,EAEH,MAAM1I,GACJ,WAAAjV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAW2C,+BACxB,CACD,oBAAA2D,CAAqBC,EAAeb,GAClC,MACMC,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMgF,EAAmBd,EAAYhG,WAAW9V,KAAK4W,MAAMgG,iBAI3D,YAHyB,IAArBA,IACFf,EAAegB,kBAAoBD,GAE9BjF,QAAQC,SAChB,EAEH,MAAMhF,GACJ,WAAAxU,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWiC,uBACxB,CACD,eAAAsD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAa1C,QAZ8B,IAA9BmG,EAAUC,kBACZnB,EAAeoB,UAAYF,EAAUC,sBAEJ,IAA/BD,EAAUG,kBACZnB,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,eAAgBkB,EAAUG,wBAEnC,IAAvCH,EAAUI,2BACZtB,EAAeuB,mBAAqBL,EAAUI,+BAEJ,IAAxCJ,EAAUM,2BACZtB,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,wBAAyBkB,EAAUM,iCAE9C,IAArCN,EAAUO,yBACZvB,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,qBAAsBkB,EAAUO,8BACnC,IAA3CP,EAAUO,uBAAuB7V,OAAkB,CAC/C,MAAAA,EAAQsV,EAAUO,uBAAuB7V,MAC/CoU,EAAe0B,qBAAuB,IAAIvS,EAAQvD,EAAOA,EAC1D,CAEI,OAAAkQ,QAAQ6E,IAAIT,EACpB,EAEH,MAAMlJ,GACJ,WAAAzU,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWkC,wBACxB,CACD,eAAAqD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MACMC,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmF,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAE9C,OADAiF,EAAe2B,gBAAsC,IAAzBT,EAAUS,WAAwBT,EAAUS,WAAa,EAC9E7F,QAAQC,SAChB,EAEH,MAAMrE,GACJ,WAAAnV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWuC,yBACxB,CACD,eAAAgD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAwBvC,YAvB6B,IAAhCmG,EAAUU,oBACZ5B,EAAe6B,YAAcX,EAAUU,wBAEJ,IAAjCV,EAAUY,oBACZ5B,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,iBAAkBkB,EAAUY,0BAE/C,IAA7BZ,EAAUa,iBACZ/B,EAAegC,eAAiBd,EAAUa,qBAEK,IAA7C/B,EAAeiC,4BACFjC,EAAAiC,0BAA4B,CAAC,IAAK,WAEL,IAA1Cf,EAAUgB,8BACGlC,EAAAiC,0BAA0B,GAAKf,EAAUgB,kCAEZ,IAA1ChB,EAAUiB,8BACGnC,EAAAiC,0BAA0B,GAAKf,EAAUiB,kCAEZ,IAA1CjB,EAAUkB,6BACJlC,EAAAxkB,KACNob,EAAO4J,cAAcV,EAAgB,0BAA2BkB,EAAUkB,8BAGvEtG,QAAQ6E,IAAIT,EACpB,EAEH,MAAM9I,GACJ,WAAA7U,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWoC,mBACxB,CACD,eAAAmD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GAChBF,EAAeqC,WAAa,IAAI3D,EAAM,EAAG,EAAG,GAC5CsB,EAAesC,eAAiB,EAChCtC,EAAeuC,MAAQ,EACvB,MAAMrB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAC1C,QAA+B,IAA/BmG,EAAUsB,iBAA6B,CACzC,MAAMC,EAAcvB,EAAUsB,iBACfxC,EAAAqC,WAAW1D,OAAO8D,EAAY,GAAIA,EAAY,GAAIA,EAAY,GAAIpM,GAClF,CAUM,YATgC,IAAnC6K,EAAUwB,uBACZ1C,EAAesC,eAAiBpB,EAAUwB,2BAER,IAAhCxB,EAAUyB,mBACJzC,EAAAxkB,KAAKob,EAAO4J,cAAcV,EAAgB,gBAAiBkB,EAAUyB,kBAAmBvM,UAE1D,IAApC8K,EAAU0B,uBACZ1C,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,oBAAqBkB,EAAU0B,wBAE5E9G,QAAQ6E,IAAIT,EACpB,EAEH,MAAM7I,GACJ,WAAA9U,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWsC,0BACxB,CACD,eAAAiD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAOvC,YAN8B,IAAjCmG,EAAU2B,qBACZ7C,EAAe8C,aAAe5B,EAAU2B,yBAEJ,IAAlC3B,EAAU6B,qBACZ7C,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,kBAAmBkB,EAAU6B,sBAE1EjH,QAAQ6E,IAAIT,EACpB,EAEH,MAAM5I,GACJ,WAAA/U,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWyC,oBACxB,CACD,eAAA8C,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAC9CiF,EAAegD,eAA0C,IAA9B9B,EAAU+B,gBAA6B/B,EAAU+B,gBAAkB,OAC3D,IAA/B/B,EAAUgC,kBACZhD,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,eAAgBkB,EAAUgC,mBAE/DlD,EAAAmD,oBAAsBjC,EAAUiC,qBAAuBrc,IACtE,MAAMsc,EAAalC,EAAUmC,kBAAoB,CAAC,EAAG,EAAG,GAOjD,OANQrD,EAAAqD,kBAAmB,IAAI3E,GAAQC,OAC5CyE,EAAW,GACXA,EAAW,GACXA,EAAW,GACX/M,IAEKyF,QAAQ6E,IAAIT,EACpB,EAEH,MAAM3I,GACJ,WAAAhV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWmC,iBACxB,CACD,eAAAoD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MACMC,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmF,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAE9C,OADAiF,EAAesD,SAAwB,IAAlBpC,EAAUoC,IAAiBpC,EAAUoC,IAAM,IACzDxH,QAAQC,SAChB,EAEH,MAAMtE,GACJ,WAAAlV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWqC,sBACxB,CACD,eAAAkD,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAC9CiF,EAAeuD,uBAAiD,IAA7BrC,EAAUsC,eAA4BtC,EAAUsC,eAAiB,OAClE,IAA9BtC,EAAUuC,iBACZvD,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,uBAAwBkB,EAAUuC,kBAEtF,MAAML,EAAalC,EAAUwC,qBAAuB,CAAC,EAAG,EAAG,GAOpD,OANP1D,EAAe2D,eAAgB,IAAIjF,GAAQC,OAAOyE,EAAW,GAAIA,EAAW,GAAIA,EAAW,GAAI/M,SACxD,IAAnC6K,EAAU0C,sBACJ1D,EAAAxkB,KACNob,EAAO4J,cAAcV,EAAgB,mBAAoBkB,EAAU0C,qBAAsBxN,KAGtF0F,QAAQ6E,IAAIT,EACpB,EAEH,MAAMtI,GACJ,WAAArV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAW4C,kBACxB,CACD,eAAA2C,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAKvC,OAJPiF,EAAe6D,eAAqC,IAAzB3C,EAAU4C,WAAwB5C,EAAU4C,WAAa,OACtD,IAA1B5C,EAAU6C,aACZ7D,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,UAAWkB,EAAU6C,cAElEjI,QAAQ6E,IAAIT,EACpB,EAEH,MAAMvI,GACJ,WAAApV,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAWwC,wBACxB,CACD,eAAA+C,CAAgBgB,GACd,MACMZ,EADS9b,KAAK2S,OACOkD,KAAK8G,UAAUD,GAC1C,OAAKZ,EAAYhG,YAAegG,EAAYhG,WAAW9V,KAAK4W,MAErDkG,EADE,IAEV,CACD,oBAAAL,CAAqBC,EAAeb,GAClC,MAAMlJ,EAAS3S,KAAK2S,OACdmJ,EAAcnJ,EAAOkD,KAAK8G,UAAUD,GACtC,IAACZ,EAAYhG,aAAegG,EAAYhG,WAAW9V,KAAK4W,MAC1D,OAAOe,QAAQC,UAEjB,MAAMmE,EAAU,GACVgB,EAAYjB,EAAYhG,WAAW9V,KAAK4W,MAUvC,YAT8B,IAAjCmG,EAAU8C,qBACZhE,EAAeiE,WAAa/C,EAAU8C,yBAEH,IAAjC9C,EAAUgD,qBACZlE,EAAekE,mBAAqBhD,EAAUgD,yBAEZ,IAAhChD,EAAUiD,mBACZjE,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,gBAAiBkB,EAAUiD,oBAExErI,QAAQ6E,IAAIT,EACpB,EAEH,MAAMjJ,GACJ,WAAA1U,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAW0C,kBACxB,CACD,WAAAoH,CAAYC,GACV,MAAMvN,EAAS3S,KAAK2S,OACdkD,EAAOlD,EAAOkD,KACdsK,EAAatK,EAAKuK,SAASF,GAC7B,IAACC,EAAWrK,aAAeqK,EAAWrK,WAAW9V,KAAK4W,MACjD,OAAA,KAET,MAAMmG,EAAYoD,EAAWrK,WAAW9V,KAAK4W,MACvChC,EAASjC,EAAOrU,QAAQiU,WAC9B,IAAKqC,EAAQ,CACP,GAAAiB,EAAKkB,oBAAsBlB,EAAKkB,mBAAmB9V,QAAQjB,KAAK4W,OAAS,EACrE,MAAA,IAAIpB,MAAM,+EAET,OAAA,IAEV,CACD,OAAO7C,EAAO0N,iBAAiBH,EAAcnD,EAAUuD,OAAQ1L,EAChE,EAEH,MAAM7B,GACJ,WAAA3U,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAW6C,iBACvBhZ,KAAKugB,YAAc,IACpB,CACD,WAAAN,CAAYC,GACV,MAAMtJ,EAAO5W,KAAK4W,KACZjE,EAAS3S,KAAK2S,OACdkD,EAAOlD,EAAOkD,KACdsK,EAAatK,EAAKuK,SAASF,GACjC,IAAKC,EAAWrK,aAAeqK,EAAWrK,WAAWc,GAC5C,OAAA,KAEH,MAAAmG,EAAYoD,EAAWrK,WAAWc,GAClC0J,EAASzK,EAAK2K,OAAOzD,EAAUuD,QACrC,IAAI1L,EAASjC,EAAO8N,cACpB,GAAIH,EAAOI,IAAK,CACd,MAAMC,EAAUhO,EAAOrU,QAAQ+T,QAAQuO,WAAWN,EAAOI,KACzC,OAAZC,IACO/L,EAAA+L,EACZ,CACD,OAAO3gB,KAAK6gB,gBAAgBrF,MAAK,SAAS+E,GACpC,GAAAA,EACF,OAAO5N,EAAO0N,iBAAiBH,EAAcnD,EAAUuD,OAAQ1L,GACjE,GAAIiB,EAAKkB,oBAAsBlB,EAAKkB,mBAAmB9V,QAAQ2V,IAAS,EAChE,MAAA,IAAIpB,MAAM,6DAEX,OAAA7C,EAAOsN,YAAYC,EAChC,GACG,CACD,aAAAW,GAUE,OATK7gB,KAAKugB,cACRvgB,KAAKugB,YAAc,IAAI5I,SAAQ,SAASC,GAChC,MAAAhZ,EAAQ,IAAIkiB,MAClBliB,EAAMmiB,IAAM,kFACNniB,EAAAoiB,OAASpiB,EAAMqiB,QAAU,WACrBrJ,EAAiB,IAAjBhZ,EAAMY,OACxB,CACA,KAEWQ,KAAKugB,WACb,EAEH,MAAMvN,GACJ,WAAA5U,CAAYuU,GACV3S,KAAK2S,OAASA,EACd3S,KAAK4W,KAAOT,GAAW8C,iBACvBjZ,KAAKugB,YAAc,IACpB,CACD,WAAAN,CAAYC,GACV,MAAMtJ,EAAO5W,KAAK4W,KACZjE,EAAS3S,KAAK2S,OACdkD,EAAOlD,EAAOkD,KACdsK,EAAatK,EAAKuK,SAASF,GACjC,IAAKC,EAAWrK,aAAeqK,EAAWrK,WAAWc,GAC5C,OAAA,KAEH,MAAAmG,EAAYoD,EAAWrK,WAAWc,GAClC0J,EAASzK,EAAK2K,OAAOzD,EAAUuD,QACrC,IAAI1L,EAASjC,EAAO8N,cACpB,GAAIH,EAAOI,IAAK,CACd,MAAMC,EAAUhO,EAAOrU,QAAQ+T,QAAQuO,WAAWN,EAAOI,KACzC,OAAZC,IACO/L,EAAA+L,EACZ,CACD,OAAO3gB,KAAK6gB,gBAAgBrF,MAAK,SAAS+E,GACpC,GAAAA,EACF,OAAO5N,EAAO0N,iBAAiBH,EAAcnD,EAAUuD,OAAQ1L,GACjE,GAAIiB,EAAKkB,oBAAsBlB,EAAKkB,mBAAmB9V,QAAQ2V,IAAS,EAChE,MAAA,IAAIpB,MAAM,6DAEX,OAAA7C,EAAOsN,YAAYC,EAChC,GACG,CACD,aAAAW,GAUE,OATK7gB,KAAKugB,cACRvgB,KAAKugB,YAAc,IAAI5I,SAAQ,SAASC,GAChC,MAAAhZ,EAAQ,IAAIkiB,MAClBliB,EAAMmiB,IAAM,kbACNniB,EAAAoiB,OAASpiB,EAAMqiB,QAAU,WACrBrJ,EAAiB,IAAjBhZ,EAAMY,OACxB,CACA,KAEWQ,KAAKugB,WACb,EAEH,MAAM5M,GACJ,WAAAvV,CAAYuU,GACV3S,KAAK4W,KAAOT,GAAW+C,wBACvBlZ,KAAK2S,OAASA,CACf,CACD,cAAAuO,CAAenqB,GACP,MAAA8e,EAAO7V,KAAK2S,OAAOkD,KACnBsL,EAAatL,EAAKuL,YAAYrqB,GACpC,GAAIoqB,EAAWrL,YAAcqL,EAAWrL,WAAW9V,KAAK4W,MAAO,CAC7D,MAAMyK,EAAeF,EAAWrL,WAAW9V,KAAK4W,MAC1C0K,EAASthB,KAAK2S,OAAO0I,cAAc,SAAUgG,EAAaC,QAC1DC,EAAUvhB,KAAK2S,OAAOrU,QAAQkU,eACpC,IAAK+O,IAAYA,EAAQC,UAAW,CAC9B,GAAA3L,EAAKkB,oBAAsBlB,EAAKkB,mBAAmB9V,QAAQjB,KAAK4W,OAAS,EACrE,MAAA,IAAIpB,MAAM,sFAET,OAAA,IAEV,CACM,OAAA8L,EAAO9F,MAAK,SAASiG,GACpB,MAAAC,EAAaL,EAAaK,YAAc,EACxCC,EAAaN,EAAaM,YAAc,EACxCrqB,EAAQ+pB,EAAa/pB,MACrBsqB,EAASP,EAAaQ,WACtBvB,EAAS,IAAIroB,WAAWwpB,EAAKC,EAAYC,GAC/C,OAAIJ,EAAQO,sBACHP,EAAQO,sBAAsBxqB,EAAOsqB,EAAQtB,EAAQe,EAAaU,KAAMV,EAAaW,QAAQxG,MAAK,SAASyG,GAChH,OAAOA,EAAKX,MACxB,IAEiBC,EAAQW,MAAM1G,MAAK,WACxB,MAAM2G,EAAS,IAAIlM,YAAY3e,EAAQsqB,GAShC,OARCL,EAAAa,iBACN,IAAInqB,WAAWkqB,GACf7qB,EACAsqB,EACAtB,EACAe,EAAaU,KACbV,EAAaW,QAERG,CACnB,GAEA,GACA,CACa,OAAA,IAEV,EAEH,MAAMvO,GACJ,WAAAxV,CAAYuU,GACV3S,KAAK4W,KAAOT,GAAWgD,wBACvBnZ,KAAK2S,OAASA,CACf,CACD,cAAA0P,CAAe3I,GACP,MAAA7D,EAAO7V,KAAK2S,OAAOkD,KACnB+D,EAAU/D,EAAK4D,MAAMC,GACvB,IAACE,EAAQ9D,aAAe8D,EAAQ9D,WAAW9V,KAAK4W,YAA0B,IAAjBgD,EAAQ0I,KAC5D,OAAA,KAET,MAAMC,EAAU1M,EAAK2M,OAAO5I,EAAQ0I,MACzB,IAAA,MAAAG,KAAaF,EAAQG,WAC9B,GAAID,EAAUV,OAASY,GAAgBC,WAAaH,EAAUV,OAASY,GAAgBE,gBAAkBJ,EAAUV,OAASY,GAAgBG,mBAAmC,IAAnBL,EAAUV,KAC7J,OAAA,KAGX,MACMgB,EADenJ,EAAQ9D,WAAW9V,KAAK4W,MACVoM,WAC7BjH,EAAU,GACViH,EAAa,CAAA,EACnB,IAAA,MAAWziB,KAAOwiB,EACRhH,EAAAxkB,KACNyI,KAAK2S,OAAO0I,cAAc,WAAY0H,EAAcxiB,IAAMib,MAAMyH,IAC9DD,EAAWziB,GAAO0iB,EACXD,EAAWziB,OAIpB,OAAAwb,EAAQnkB,OAAS,EACZ,MAETmkB,EAAQxkB,KAAKyI,KAAK2S,OAAO0P,eAAe3I,IACjC/B,QAAQ6E,IAAIT,GAASP,MAAM0H,IAC1B,MAAAC,EAAaD,EAAQE,MACrBZ,EAASW,EAAWE,QAAUF,EAAWG,SAAW,CAACH,GACrD7rB,EAAQ4rB,EAAQ,GAAG5rB,MACnBisB,EAAkB,GACxB,IAAA,MAAWjB,KAAQE,EAAQ,CACnB,MAAAxoB,EAAI,IAAIwpB,EACR/oB,EAAI,IAAIiI,EACR+gB,EAAI,IAAI5d,EACRrM,EAAI,IAAIkJ,EAAQ,EAAG,EAAG,GACtBghB,EAAgB,IAAIC,EAAcrB,EAAK9rB,SAAU8rB,EAAKriB,SAAU3I,GACtE,IAAA,IAASD,EAAI,EAAGA,EAAIC,EAAOD,IACrB2rB,EAAWY,aACXnpB,EAAAopB,oBAAoBb,EAAWY,YAAavsB,GAE5C2rB,EAAWc,UACXL,EAAAI,oBAAoBb,EAAWc,SAAUzsB,GAEzC2rB,EAAWe,OACXvqB,EAAAqqB,oBAAoBb,EAAWe,MAAO1sB,GAE1CqsB,EAAcM,YAAY3sB,EAAG2C,EAAEiqB,QAAQxpB,EAAGgpB,EAAGjqB,IAE/C,IAAA,MAAW0qB,KAAiBlB,EAC1B,GAAsB,aAAlBkB,EAA8B,CAC1B,MAAAC,EAAOnB,EAAWkB,GACVR,EAAAU,cAAgB,IAAIC,EAAyBF,EAAK1iB,MAAO0iB,EAAKG,SAAUH,EAAKI,WACvG,KAAuC,gBAAlBL,GAAqD,aAAlBA,GAAkD,UAAlBA,GAC5E5B,EAAK9rB,SAASguB,aAAaN,EAAelB,EAAWkB,IAGzDO,EAASC,UAAUtf,KAAKzD,KAAK+hB,EAAepB,GACvCtiB,KAAA2S,OAAOgS,oBAAoBjB,GAChCH,EAAgBhsB,KAAKmsB,EACtB,CACD,OAAIP,EAAWE,SACbF,EAAWyB,QACAzB,EAAA/lB,OAAOmmB,GACXJ,GAEFI,EAAgB,EAAC,IAE3B,EAEH,MAAMrN,GAAgC,OAEhC2O,GAAuC,WAAvCA,GAAwD,QAC9D,MAAMxO,GACJ,WAAAjY,CAAYT,GACVqC,KAAK4W,KAAOT,GAAWC,gBACvBpW,KAAKsW,QAAU,KACftW,KAAK8kB,KAAO,KACZ,MAAMC,EAAa,IAAIC,SAASrnB,EAAM,EAPH,IAa/B,GALJqC,KAAKilB,OAAS,CACZC,MAAOvT,GAAW,IAAI1Z,WAAW0F,EAAK+D,MAAM,EAAG,KAC/CvL,QAAS4uB,EAAWI,UAAU,GAAG,GACjCvtB,OAAQmtB,EAAWI,UAAU,GAAG,IAE9BnlB,KAAKilB,OAAOC,QAAUhP,GAClB,MAAA,IAAIV,MAAM,qDACP,GAAAxV,KAAKilB,OAAO9uB,QAAU,EACzB,MAAA,IAAIqf,MAAM,kDAEZ,MAAA4P,EAAsBplB,KAAKilB,OAAOrtB,OAlBL,GAmB7BytB,EAAY,IAAIL,SAASrnB,EAnBI,IAoBnC,IAAI2nB,EAAa,EACjB,KAAOA,EAAaF,GAAqB,CACvC,MAAMG,EAAcF,EAAUF,UAAUG,GAAY,GACtCA,GAAA,EACd,MAAME,EAAYH,EAAUF,UAAUG,GAAY,GAE9C,GADUA,GAAA,EACVE,IAAcX,GAAmC,CACnD,MAAMY,EAAe,IAAIxtB,WAAW0F,EA3BL,GA2B4C2nB,EAAYC,GAClFvlB,KAAAsW,QAAU3E,GAAW8T,EAClC,MAAA,GAAiBD,IAAcX,GAAkC,CACzD,MAAMnD,EA9ByB,GA8BqB4D,EACpDtlB,KAAK8kB,KAAOnnB,EAAK+D,MAAMggB,EAAYA,EAAa6D,EACjD,CACaD,GAAAC,CACf,CACG,GAAiB,OAAjBvlB,KAAKsW,QACD,MAAA,IAAId,MAAM,4CAEnB,EAEH,MAAM2B,GACJ,WAAA/Y,CAAYyX,EAAMvD,GAChB,IAAKA,EACG,MAAA,IAAIkD,MAAM,uDAElBxV,KAAK4W,KAAOT,GAAWe,2BACvBlX,KAAK6V,KAAOA,EACZ7V,KAAKsS,YAAcA,EACnBtS,KAAKsS,YAAYoT,SAClB,CACD,eAAAC,CAAgBlD,EAAW9P,GACzB,MAAMkD,EAAO7V,KAAK6V,KACZvD,EAActS,KAAKsS,YACnBsT,EAAkBnD,EAAU3M,WAAW9V,KAAK4W,MAAMuK,WAClD0E,EAAmBpD,EAAU3M,WAAW9V,KAAK4W,MAAMoM,WACnD8C,EAAoB,CAAA,EACpBC,EAAyB,CAAA,EACzBC,EAAmB,CAAA,EACzB,IAAA,MAAW9B,KAAiB2B,EAAkB,CAC5C,MAAMI,EAAqBC,GAAWhC,IAAkBA,EAAciC,cACpDL,EAAAG,GAAsBJ,EAAiB3B,EAC1D,CACU,IAAA,MAAAA,KAAiBzB,EAAUO,WAAY,CAChD,MAAMiD,EAAqBC,GAAWhC,IAAkBA,EAAciC,cAClE,QAAoC,IAApCN,EAAiB3B,GAA2B,CAC9C,MAAMkC,EAAcvQ,EAAKwQ,UAAU5D,EAAUO,WAAWkB,IAClDoC,EAAgBC,GAAsBH,EAAYE,eACvCN,EAAAC,GAAsBK,EAAc1P,KAC9BmP,EAAAE,IAAiD,IAA3BG,EAAY7B,UAC1D,CACF,CACD,OAAO5R,EAAO0I,cAAc,aAAcuK,GAAiBpK,MAAK,SAAS2F,GACvE,OAAO,IAAIxJ,SAAQ,SAASC,EAASC,GACvBvF,EAAAkU,gBACVrF,GACA,SAAS3qB,GACI,IAAA,MAAA0tB,KAAiB1tB,EAASwsB,WAAY,CACzC,MAAAyD,EAAYjwB,EAASwsB,WAAWkB,GAChCK,EAAawB,EAAuB7B,QACvB,IAAfK,IACFkC,EAAUlC,WAAaA,EAC1B,CACD3M,EAAQphB,EACT,GACDsvB,EACAE,EACA9T,GACA2F,EAEV,GACA,GACG,EAEH,MAAMR,GACJ,WAAAjZ,GACE4B,KAAK4W,KAAOT,GAAWiB,qBACxB,CACD,aAAAsP,CAAcroB,EAASsoB,GACrB,YAA4B,IAAvBA,EAAUC,UAAuBD,EAAUC,WAAavoB,EAAQwoB,cAAiC,IAArBF,EAAUvkB,aAA4C,IAAvBukB,EAAUG,eAA2C,IAApBH,EAAUlf,OAG3JpJ,EAAUA,EAAQvG,aACS,IAAvB6uB,EAAUC,WACZvoB,EAAQwoB,QAAUF,EAAUC,eAEL,IAArBD,EAAUvkB,QACJ/D,EAAA+D,OAAO2kB,UAAUJ,EAAUvkB,aAEV,IAAvBukB,EAAUG,WACZzoB,EAAQyoB,SAAWH,EAAUG,eAEP,IAApBH,EAAUlf,OACJpJ,EAAA2oB,OAAOD,UAAUJ,EAAUlf,OAErCpJ,EAAQ+S,aAAc,EACf/S,GAhBEA,CAiBV,EAEH,MAAMkZ,GACJ,WAAAnZ,GACE4B,KAAK4W,KAAOT,GAAWmB,qBACxB,EAEH,MAAM2P,WAAmCC,GACvC,WAAA9oB,CAAY+oB,EAAoBC,EAAcC,EAAYC,GAClD5nB,MAAAynB,EAAoBC,EAAcC,EAAYC,EACrD,CACD,gBAAAC,CAAiBxwB,GACf,MAAMorB,EAASniB,KAAKsnB,aAAcE,EAASxnB,KAAKonB,aAAcK,EAAYznB,KAAKynB,UAAWrlB,EAASrL,EAAQ0wB,EAAY,EAAIA,EAC3H,IAAA,IAASpwB,EAAI,EAAGA,IAAMowB,EAAWpwB,IAC/B8qB,EAAO9qB,GAAKmwB,EAAOplB,EAAS/K,GAEvB,OAAA8qB,CACR,CACD,YAAAuF,CAAaC,EAAIC,EAAIzrB,EAAG0rB,GACtB,MAAM1F,EAASniB,KAAKsnB,aACdE,EAASxnB,KAAKonB,aACdxF,EAAS5hB,KAAKynB,UACdK,EAAmB,EAATlG,EACVmG,EAAmB,EAATnG,EACV9jB,EAAK+pB,EAAKD,EACVntB,GAAK0B,EAAIyrB,GAAM9pB,EACfkqB,EAAKvtB,EAAIA,EACTwtB,EAAMD,EAAKvtB,EACXytB,EAAUP,EAAKI,EACfI,EAAUD,EAAUH,EACpBK,GAAU,EAAAH,EAAM,EAAID,EACpBK,EAAKJ,EAAMD,EACXM,EAAK,EAAIF,EACTG,EAAKF,EAAKL,EAAKvtB,EACrB,IAAA,IAASpD,EAAI,EAAGA,IAAMuqB,EAAQvqB,IAAK,CACjC,MAAMmxB,EAAKhB,EAAOW,EAAU9wB,EAAIuqB,GAC1B6G,EAAKjB,EAAOW,EAAU9wB,EAAIywB,GAAWhqB,EACrC4qB,EAAKlB,EAAOU,EAAU7wB,EAAIuqB,GAC1B+G,EAAKnB,EAAOU,EAAU7wB,GAAKyG,EAC1BqkB,EAAA9qB,GAAKixB,EAAKE,EAAKD,EAAKE,EAAKL,EAAKM,EAAKL,EAAKM,CAChD,CACM,OAAAxG,CACR,EAEH,MAAMyG,OAAyB/iB,EAC/B,MAAMgjB,WAA6C5B,GACjD,YAAAS,CAAaC,EAAIC,EAAIzrB,EAAG0rB,GACtB,MAAM1F,EAASziB,MAAMgoB,aAAaC,EAAIC,EAAIzrB,EAAG0rB,GAEtC,OADPe,GAAG7B,UAAU5E,GAAQhU,YAAY2a,QAAQ3G,GAClCA,CACR,EAEH,MAAMQ,GAAkB,CACtBoG,MAAO,KAEPC,WAAY,MACZC,WAAY,MACZC,WAAY,MACZC,WAAY,MACZC,WAAY,MACZC,OAAQ,KACRC,OAAQ,MACRC,WAAY,MACZC,OAAQ,EACRC,MAAO,EACPC,UAAW,EACXC,WAAY,EACZ/G,UAAW,EACXC,eAAgB,EAChBC,aAAc,EACd8G,cAAe,KACfC,eAAgB,MAEZtD,GAAwB,CAC5B,KAAMuD,UACN,KAAM7xB,WACN,KAAM8xB,WACN,KAAM5xB,YACN,KAAME,YACN,KAAM2xB,cAEFC,GAAgB,CACpB,KAAMC,GACN,KAAMC,EACN,KAAMC,GACN,KAAMC,GACN,KAAMC,GACN,KAAMC,GAEFC,GAAkB,CACtB,MAAOC,GACP,MAAOC,GACP,MAAOC,GAEHC,GAAmB,CACvBC,OAAQ,EACRC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,IAEFjF,0HAAakF,CAAA,CACjBC,SAAU,WACVC,OAAQ,SACRC,QAAS,WAINp1B,IAAW,IAAM,CAClBq1B,WAAY,KACZC,WAAY,MACZC,WAAY,MACZC,WAAY,OACV,CACFH,WAAY,KACZC,WAAY,eAdG,CAgBjBG,QAAS,QACTC,UAAW,aACXC,SAAU,uBAEZ,MAAMC,GAAkB,CACtBtkB,MAAO,QACPukB,YAAa,WACblF,SAAU,aACVmF,QAAS,yBAELC,GAAgB,CACpBC,iBAAa,EAGb9C,OAAQ+C,GACRC,KAAMC,IAEFC,GACI,SADJA,GAEE,OAFFA,GAGG,QAgBT,SAASC,GAA+BC,EAAiBlqB,EAAQmqB,GACpD,IAAA,MAAA9V,KAAQ8V,EAAU5W,gBACG,IAA1B2W,EAAgB7V,KAClBrU,EAAOoqB,SAASC,eAAiBrqB,EAAOoqB,SAASC,gBAAkB,GACnErqB,EAAOoqB,SAASC,eAAehW,GAAQ8V,EAAU5W,WAAWc,GAGlE,CACA,SAASsE,GAAuB3Y,EAAQsqB,QACf,IAAnBA,EAAQC,SACoB,iBAAnBD,EAAQC,OACjB3sB,OAAO4sB,OAAOxqB,EAAOoqB,SAAUE,EAAQC,QAE/Bn2B,QAAAC,KAAK,sDAAwDi2B,EAAQC,QAGnF,CAsDA,SAASE,GAAmB1K,EAAMC,GAE5B,GADJD,EAAK0K,0BACmB,IAApBzK,EAAQ0J,QACD,IAAA,IAAA50B,EAAI,EAAGua,EAAK2Q,EAAQ0J,QAAQr0B,OAAQP,EAAIua,EAAIva,IACnDirB,EAAK2K,sBAAsB51B,GAAKkrB,EAAQ0J,QAAQ50B,GAGpD,GAAIkrB,EAAQuK,QAAU3Q,MAAMC,QAAQmG,EAAQuK,OAAOI,aAAc,CACzD,MAAAA,EAAc3K,EAAQuK,OAAOI,YACnC,GAAI5K,EAAK2K,sBAAsBr1B,SAAWs1B,EAAYt1B,OAAQ,CAC5D0qB,EAAK6K,sBAAwB,GAC7B,IAAA,IAAS91B,EAAI,EAAGua,EAAKsb,EAAYt1B,OAAQP,EAAIua,EAAIva,IAC/CirB,EAAK6K,sBAAsBD,EAAY71B,IAAMA,CAErD,MACMV,QAAQC,KAAK,uEAEhB,CACH,CACA,SAASw2B,GAAmBC,GACtB,IAAAC,EACJ,MAAMC,EAAiBF,EAAavX,YAAcuX,EAAavX,WAAWK,GAAWe,4BAMjF,GAJYoW,EADZC,EACY,SAAWA,EAAepM,WAAa,IAAMoM,EAAet2B,QAAU,IAAMu2B,GAAoBD,EAAevK,YAE/GqK,EAAap2B,QAAU,IAAMu2B,GAAoBH,EAAarK,YAAc,IAAMqK,EAAatL,UAElF,IAAzBsL,EAAaI,QACN,IAAA,IAAAp2B,EAAI,EAAGua,EAAKyb,EAAaI,QAAQ71B,OAAQP,EAAIua,EAAIva,IACxDi2B,GAAe,IAAME,GAAoBH,EAAaI,QAAQp2B,IAG3D,OAAAi2B,CACT,CACA,SAASE,GAAoBxK,GAC3B,IAAI0K,EAAgB,GACpB,MAAMpc,EAAOnR,OAAOmR,KAAK0R,GAAY2K,OACrC,IAAA,IAASt2B,EAAI,EAAGua,EAAKN,EAAK1Z,OAAQP,EAAIua,EAAIva,IACvBq2B,GAAApc,EAAKja,GAAK,IAAM2rB,EAAW1R,EAAKja,IAAM,IAElD,OAAAq2B,CACT,CACA,SAASE,GAA4BxvB,GACnC,OAAQA,GACN,KAAK0rB,UACH,OAAO,EAAI,IACb,KAAK7xB,WACH,OAAO,EAAI,IACb,KAAK8xB,WACH,OAAO,EAAI,MACb,KAAK5xB,YACH,OAAO,EAAI,MACb,QACQ,MAAA,IAAIqd,MAAM,qEAEtB,CAQA,MAAMqY,OAAsCrK,EAC5C,MAAMhN,GACJ,WAAApY,CAAYyX,EAAO,GAAIvX,EAAU,CAAA,GAC/B0B,KAAK6V,KAAOA,EACZ7V,KAAK8V,WAAa,GAClB9V,KAAK+V,QAAU,GACf/V,KAAK1B,QAAUA,EACV0B,KAAAoZ,MAAQ,IAAItB,GACZ9X,KAAA8tB,iBAAmCC,IACxC/tB,KAAKguB,eAAiB,GACtBhuB,KAAKiuB,UAAY,GACjBjuB,KAAKkuB,UAAY,CAAE7U,KAAM,CAAA,EAAIC,KAAM,CAAA,GACnCtZ,KAAKmuB,YAAc,CAAE9U,KAAM,CAAA,EAAIC,KAAM,CAAA,GACrCtZ,KAAKouB,WAAa,CAAE/U,KAAM,CAAA,EAAIC,KAAM,CAAA,GACpCtZ,KAAKquB,YAAc,GACnBruB,KAAKsuB,aAAe,GACpBtuB,KAAKuuB,cAAgB,GACrB,IAAIC,GAAW,EACXC,GAAY,EACZC,GAAiB,EACI,oBAAdC,gBAA4D,IAAxBA,UAAUC,YACvDJ,GAA0E,IAA/D,iCAAiCK,KAAKF,UAAUC,WAC3DH,EAAYE,UAAUC,UAAU3tB,QAAQ,YAAa,EACrDytB,EAAiBD,EAAYE,UAAUC,UAAUE,MAAM,uBAAuB,IAAK,GAEpD,oBAAtBC,mBAAqCP,GAAYC,GAAaC,EAAiB,GACxF1uB,KAAKygB,cAAgB,IAAIuO,EAAchvB,KAAK1B,QAAQ+T,SAEpDrS,KAAKygB,cAAgB,IAAIwO,EAAkBjvB,KAAK1B,QAAQ+T,SAE1DrS,KAAKygB,cAAcyO,eAAelvB,KAAK1B,QAAQmY,aAC/CzW,KAAKygB,cAAczL,iBAAiBhV,KAAK1B,QAAQ2W,eACjDjV,KAAK0W,WAAa,IAAI7B,EAAW7U,KAAK1B,QAAQ+T,SACzCrS,KAAA0W,WAAW3B,gBAAgB,eACC,oBAA7B/U,KAAK1B,QAAQmY,aACVzW,KAAA0W,WAAWxB,oBAAmB,EAEtC,CACD,aAAAsC,CAAc1B,GACZ9V,KAAK8V,WAAaA,CACnB,CACD,UAAA2B,CAAW1B,GACT/V,KAAK+V,QAAUA,CAChB,CACD,KAAAX,CAAMrB,EAAQE,GACZ,MAAMtB,EAAS3S,KACT6V,EAAO7V,KAAK6V,KACZC,EAAa9V,KAAK8V,WACxB9V,KAAKoZ,MAAMlB,YACXlY,KAAKiuB,UAAY,GACZjuB,KAAAmvB,YAAW,SAASC,GAChB,OAAAA,EAAI7V,WAAa6V,EAAI7V,WAClC,IACY5B,QAAA6E,IACNxc,KAAKmvB,YAAW,SAASC,GAChB,OAAAA,EAAIC,YAAcD,EAAIC,YACrC,KACM7T,MAAK,WACL,OAAO7D,QAAQ6E,IAAI,CACjB7J,EAAO2c,gBAAgB,SACvB3c,EAAO2c,gBAAgB,aACvB3c,EAAO2c,gBAAgB,WAE/B,IAAO9T,MAAK,SAAS+T,GACf,MAAMpN,EAAS,CACbqN,MAAOD,EAAa,GAAG1Z,EAAK2Z,OAAS,GACrCC,OAAQF,EAAa,GACrBG,WAAYH,EAAa,GACzBI,QAASJ,EAAa,GACtBhZ,MAAOV,EAAKU,MACZ5D,SACAga,SAAU,CAAE,GAId,OAF+BH,GAAA1W,EAAYqM,EAAQtM,GACnDqF,GAAuBiH,EAAQtM,GACxB8B,QAAQ6E,IACb7J,EAAOwc,YAAW,SAASC,GACzB,OAAOA,EAAIQ,WAAaR,EAAIQ,UAAUzN,EAChD,KACQ3G,MAAK,WACM,IAAA,MAAAgU,KAASrN,EAAOsN,OACzBD,EAAMlnB,oBAERyL,EAAOoO,EACf,GACA,IAAO0N,MAAM5b,EACV,CAID,SAAAsF,GACE,MAAMC,EAAWxZ,KAAK6V,KAAK4D,OAAS,GAC9BqW,EAAW9vB,KAAK6V,KAAKka,OAAS,GAC9BC,EAAWhwB,KAAK6V,KAAK2M,QAAU,GACrC,IAAA,IAASyN,EAAY,EAAGC,EAAaJ,EAASl4B,OAAQq4B,EAAYC,EAAYD,IAAa,CACnF,MAAAE,EAASL,EAASG,GAAWE,OACnC,IAAA,IAAS94B,EAAI,EAAGua,EAAKue,EAAOv4B,OAAQP,EAAIua,EAAIva,IAC1CmiB,EAAS2W,EAAO94B,IAAI+4B,QAAS,CAEhC,CACD,IAAA,IAAS1W,EAAY,EAAGC,EAAaH,EAAS5hB,OAAQ8hB,EAAYC,EAAYD,IAAa,CACnF,MAAAE,EAAUJ,EAASE,QACJ,IAAjBE,EAAQ0I,OACVtiB,KAAK8Z,YAAY9Z,KAAKkuB,UAAWtU,EAAQ0I,WACpB,IAAjB1I,EAAQyW,OACDL,EAAApW,EAAQ0I,MAAMgO,eAAgB,SAGpB,IAAnB1W,EAAQ2W,QACVvwB,KAAK8Z,YAAY9Z,KAAKmuB,YAAavU,EAAQ2W,OAE9C,CACF,CAUD,WAAAzW,CAAYV,EAAOriB,QACH,IAAVA,SAEsB,IAAtBqiB,EAAMC,KAAKtiB,KACbqiB,EAAMC,KAAKtiB,GAASqiB,EAAME,KAAKviB,GAAS,GAE1CqiB,EAAMC,KAAKtiB,KACZ,CAED,WAAA0kB,CAAYrC,EAAOriB,EAAOwL,GACpB,GAAA6W,EAAMC,KAAKtiB,IAAU,EAChB,OAAAwL,EACH,MAAAiuB,EAAMjuB,EAAOzK,QACb24B,EAAiB,CAACC,EAAU54B,KAChC,MAAM64B,EAAW3wB,KAAK8tB,aAAa9V,IAAI0Y,GACvB,MAAZC,GACG3wB,KAAA8tB,aAAavyB,IAAIzD,EAAO64B,GAE/B,IAAA,MAAYt5B,EAAGu5B,KAAUF,EAASpN,SAASuN,UACzCJ,EAAeG,EAAO94B,EAAMwrB,SAASjsB,GACtC,EAII,OAFPo5B,EAAeluB,EAAQiuB,GACvBA,EAAI5Z,MAAQ,aAAewC,EAAME,KAAKviB,KAC/By5B,CACR,CACD,UAAAM,CAAWC,GACT,MAAMjb,EAAa3V,OAAOqnB,OAAOxnB,KAAK+V,SACtCD,EAAWve,KAAKyI,MAChB,IAAA,IAAS3I,EAAI,EAAGA,EAAIye,EAAWle,OAAQP,IAAK,CAC1C,MAAM8qB,EAAS4O,EAAKjb,EAAWze,IAC3B,GAAA8qB,EACK,OAAAA,CACV,CACM,OAAA,IACR,CACD,UAAAgN,CAAW4B,GACT,MAAMjb,EAAa3V,OAAOqnB,OAAOxnB,KAAK+V,SACtCD,EAAWkb,QAAQhxB,MACnB,MAAM+b,EAAU,GAChB,IAAA,IAAS1kB,EAAI,EAAGA,EAAIye,EAAWle,OAAQP,IAAK,CAC1C,MAAM8qB,EAAS4O,EAAKjb,EAAWze,IAC3B8qB,GACFpG,EAAQxkB,KAAK4qB,EAChB,CACM,OAAApG,CACR,CAOD,aAAAV,CAAcnf,EAAMnF,GACZ,MAAAkjB,EAAW/d,EAAO,IAAMnF,EAC9B,IAAImjB,EAAala,KAAKoZ,MAAMpB,IAAIiC,GAChC,IAAKC,EAAY,CACf,OAAQhe,GACN,IAAK,QACUge,EAAAla,KAAKixB,UAAUl6B,GAC5B,MACF,IAAK,OACUmjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,EAAI8B,UAAY9B,EAAI8B,SAASn6B,EAChD,IACU,MACF,IAAK,OACUmjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,EAAI+B,UAAY/B,EAAI+B,SAASp6B,EAChD,IACU,MACF,IAAK,WACUmjB,EAAAla,KAAKoxB,aAAar6B,GAC/B,MACF,IAAK,aACUmjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,EAAIlO,gBAAkBkO,EAAIlO,eAAenqB,EAC5D,IACU,MACF,IAAK,SACUmjB,EAAAla,KAAKqxB,WAAWt6B,GAC7B,MACF,IAAK,WACUmjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,EAAIkC,cAAgBlC,EAAIkC,aAAav6B,EACxD,IACU,MACF,IAAK,UACUmjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,EAAInP,aAAemP,EAAInP,YAAYlpB,EACtD,IACU,MACF,IAAK,OACUmjB,EAAAla,KAAKuxB,SAASx6B,GAC3B,MACF,IAAK,YACUmjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,EAAIoC,eAAiBpC,EAAIoC,cAAcz6B,EAC1D,IACU,MACF,IAAK,SACUmjB,EAAAla,KAAKyxB,WAAW16B,GAC7B,MACF,QAIE,GAHamjB,EAAAla,KAAK8wB,YAAW,SAAS1B,GACpC,OAAOA,GAAOpvB,MAAQovB,EAAI/T,eAAiB+T,EAAI/T,cAAcnf,EAAMnF,EAC/E,KACemjB,EACG,MAAA,IAAI1E,MAAM,iBAAmBtZ,GAIpC8D,KAAAoZ,MAAMhc,IAAI6c,EAAUC,EAC1B,CACM,OAAAA,CACR,CAMD,eAAAoV,CAAgBpzB,GACd,IAAIqzB,EAAevvB,KAAKoZ,MAAMpB,IAAI9b,GAClC,IAAKqzB,EAAc,CACjB,MAAM5c,EAAS3S,KACT0xB,EAAO1xB,KAAK6V,KAAK3Z,GAAiB,SAATA,EAAkB,KAAO,OAAS,GACjEqzB,EAAe5X,QAAQ6E,IACrBkV,EAAKpyB,KAAI,SAASb,EAAK1H,GACd,OAAA4b,EAAO0I,cAAcnf,EAAMnF,EAC5C,KAEWiJ,KAAAoZ,MAAMhc,IAAIlB,EAAMqzB,EACtB,CACM,OAAAA,CACR,CAMD,UAAA8B,CAAWM,GACT,MAAMC,EAAY5xB,KAAK6V,KAAKgc,QAAQF,GAC9B/c,EAAS5U,KAAK0W,WACpB,GAAIkb,EAAU11B,MAA2B,gBAAnB01B,EAAU11B,KAC9B,MAAM,IAAIsZ,MAAM,qBAAuBoc,EAAU11B,KAAO,kCAE1D,QAAsB,IAAlB01B,EAAUlR,KAAkC,IAAhBiR,EAC9B,OAAOha,QAAQC,QAAQ5X,KAAK8V,WAAWK,GAAWC,iBAAiB0O,MAErE,MAAMxmB,EAAU0B,KAAK1B,QACrB,OAAO,IAAIqZ,SAAQ,SAASC,EAASC,GAC5BjD,EAAAf,KAAKQ,EAAYE,WAAWqd,EAAUlR,IAAKpiB,EAAQ6V,MAAOyD,OAAS,GAAQ,WAChFC,EAAO,IAAIrC,MAAM,4CAA8Coc,EAAUlR,IAAM,MACvF,GACA,GACG,CAMD,cAAAQ,CAAe0E,GACb,MAAMkM,EAAgB9xB,KAAK6V,KAAKuL,YAAYwE,GACrC,OAAA5lB,KAAKqb,cAAc,SAAUyW,EAAcxQ,QAAQ9F,MAAK,SAAS8F,GAChE,MAAAK,EAAamQ,EAAcnQ,YAAc,EACzCD,EAAaoQ,EAAcpQ,YAAc,EAC/C,OAAOJ,EAAO5f,MAAMggB,EAAYA,EAAaC,EACnD,GACG,CAMD,YAAAyP,CAAaW,GACX,MAAMpf,EAAS3S,KACT6V,EAAO7V,KAAK6V,KACZuQ,EAAcpmB,KAAK6V,KAAKwQ,UAAU0L,GACxC,QAA+B,IAA3B3L,EAAYjF,iBAAgD,IAAvBiF,EAAY4L,OAAmB,CAChE,MAAA1N,EAAWsG,GAAiBxE,EAAYlqB,MACxC+1B,EAAa1L,GAAsBH,EAAYE,eAC/C/B,GAAwC,IAA3B6B,EAAY7B,WACzB9iB,EAAQ,IAAIwwB,EAAW7L,EAAY9uB,MAAQgtB,GACjD,OAAO3M,QAAQC,QAAQ,IAAIsa,EAAgBzwB,EAAO6iB,EAAUC,GAC7D,CACD,MAAM4N,EAAqB,GAU3B,YAT+B,IAA3B/L,EAAYjF,WACdgR,EAAmB56B,KAAKyI,KAAKqb,cAAc,aAAc+K,EAAYjF,aAErEgR,EAAmB56B,KAAK,WAEC,IAAvB6uB,EAAY4L,SACKG,EAAA56B,KAAKyI,KAAKqb,cAAc,aAAc+K,EAAY4L,OAAO/6B,QAAQkqB,aACjEgR,EAAA56B,KAAKyI,KAAKqb,cAAc,aAAc+K,EAAY4L,OAAOxK,OAAOrG,cAE9ExJ,QAAQ6E,IAAI2V,GAAoB3W,MAAK,SAAS4F,GAC7C,MAAAD,EAAaC,EAAY,GACzBkD,EAAWsG,GAAiBxE,EAAYlqB,MACxC+1B,EAAa1L,GAAsBH,EAAYE,eAC/C8L,EAAeH,EAAWI,kBAC1BC,EAAYF,EAAe9N,EAC3B5C,EAAa0E,EAAY1E,YAAc,EACvCG,OAAwC,IAA3BuE,EAAYjF,WAAwBtL,EAAKuL,YAAYgF,EAAYjF,YAAYU,gBAAa,EACvG0C,GAAwC,IAA3B6B,EAAY7B,WAC/B,IAAI9iB,EAAO8wB,EACP,GAAA1Q,GAAcA,IAAeyQ,EAAW,CAC1C,MAAME,EAAUl3B,KAAKyD,MAAM2iB,EAAaG,GAClC4Q,EAAa,qBAAuBrM,EAAYjF,WAAa,IAAMiF,EAAYE,cAAgB,IAAMkM,EAAU,IAAMpM,EAAY9uB,MACvI,IAAIo7B,EAAK/f,EAAOyG,MAAMpB,IAAIya,GACrBC,IACKjxB,EAAA,IAAIwwB,EAAW9Q,EAAYqR,EAAU3Q,EAAYuE,EAAY9uB,MAAQuqB,EAAauQ,GAC1FM,EAAK,IAAIC,EAAkBlxB,EAAOogB,EAAauQ,GACxCzf,EAAAyG,MAAMhc,IAAIq1B,EAAYC,IAE/BH,EAAkB,IAAIK,GACpBF,EACApO,EACA5C,EAAaG,EAAauQ,EAC1B7N,EAEV,MAEU9iB,EADiB,OAAf0f,EACM,IAAI8Q,EAAW7L,EAAY9uB,MAAQgtB,GAEnC,IAAI2N,EAAW9Q,EAAYO,EAAY0E,EAAY9uB,MAAQgtB,GAErEiO,EAAkB,IAAIL,EAAgBzwB,EAAO6iB,EAAUC,GAErD,QAAuB,IAAvB6B,EAAY4L,OAAmB,CACjC,MAAMa,EAAkBjI,GAAiBC,OACnCiI,EAAoBvM,GAAsBH,EAAY4L,OAAO/6B,QAAQqvB,eACrEyM,EAAoB3M,EAAY4L,OAAO/6B,QAAQyqB,YAAc,EAC7DsR,EAAmB5M,EAAY4L,OAAOxK,OAAO9F,YAAc,EAC3DuR,EAAgB,IAAIH,EACxB1R,EAAY,GACZ2R,EACA3M,EAAY4L,OAAO16B,MAAQu7B,GAEvBK,EAAe,IAAIjB,EAAW7Q,EAAY,GAAI4R,EAAkB5M,EAAY4L,OAAO16B,MAAQgtB,GAC9E,OAAfnD,IACFoR,EAAkB,IAAIL,EACpBK,EAAgB9wB,MAAMC,QACtB6wB,EAAgBjO,SAChBiO,EAAgBhO,aAGpB,IAAA,IAASltB,EAAI,EAAGua,EAAKqhB,EAAcr7B,OAAQP,EAAIua,EAAIva,IAAK,CAChD,MAAAN,EAAQk8B,EAAc57B,GAQ5B,GAPAk7B,EAAgBY,KAAKp8B,EAAOm8B,EAAa77B,EAAIitB,IACzCA,GAAY,GACdiO,EAAgBa,KAAKr8B,EAAOm8B,EAAa77B,EAAIitB,EAAW,IACtDA,GAAY,GACdiO,EAAgBc,KAAKt8B,EAAOm8B,EAAa77B,EAAIitB,EAAW,IACtDA,GAAY,GACdiO,EAAgBe,KAAKv8B,EAAOm8B,EAAa77B,EAAIitB,EAAW,IACtDA,GAAY,EACR,MAAA,IAAI9O,MAAM,oEACnB,CACF,CACM,OAAA+c,CACb,GACG,CAMD,WAAAtS,CAAYC,GACV,MAAMrK,EAAO7V,KAAK6V,KACZvX,EAAU0B,KAAK1B,QAEfi1B,EADa1d,EAAKuK,SAASF,GACFI,OACzBkT,EAAY3d,EAAK2K,OAAO+S,GAC9B,IAAI3e,EAAS5U,KAAKygB,cAClB,GAAI+S,EAAU9S,IAAK,CACjB,MAAMC,EAAUriB,EAAQ+T,QAAQuO,WAAW4S,EAAU9S,KACrC,OAAZC,IACO/L,EAAA+L,EACZ,CACD,OAAO3gB,KAAKqgB,iBAAiBH,EAAcqT,EAAa3e,EACzD,CACD,gBAAAyL,CAAiBH,EAAcqT,EAAa3e,GAC1C,MAAMjC,EAAS3S,KACT6V,EAAO7V,KAAK6V,KACZsK,EAAatK,EAAKuK,SAASF,GAC3BsT,EAAY3d,EAAK2K,OAAO+S,GACxBtZ,GAAYuZ,EAAU9S,KAAO8S,EAAUrS,YAAc,IAAMhB,EAAWsT,QACxE,GAAAzzB,KAAKsuB,aAAarU,GACb,OAAAja,KAAKsuB,aAAarU,GAErB,MAAAyZ,EAAU1zB,KAAK2zB,gBAAgBJ,EAAa3e,GAAQ4G,MAAK,SAASnd,GACtEA,EAAQu1B,OAAQ,EAChBv1B,EAAQuY,KAAOuJ,EAAWvJ,MAAQ4c,EAAU5c,MAAQ,GAC/B,KAAjBvY,EAAQuY,MAAwC,iBAAlB4c,EAAU9S,MAAgE,IAA5C8S,EAAU9S,IAAImT,WAAW,iBACvFx1B,EAAQuY,KAAO4c,EAAU9S,KAErB,MACA+S,GADW5d,EAAKie,UAAY,IACT3T,EAAWsT,UAAY,CAAA,EAMzC,OALPp1B,EAAQ01B,UAAY9J,GAAcwJ,EAAQM,YAAc5J,EACxD9rB,EAAQ21B,UAAY/J,GAAcwJ,EAAQO,YAAczJ,EACxDlsB,EAAQ41B,MAAQzJ,GAAgBiJ,EAAQQ,QAAUtJ,EAClDtsB,EAAQ61B,MAAQ1J,GAAgBiJ,EAAQS,QAAUvJ,EAClDhY,EAAOmb,aAAavyB,IAAI8C,EAAS,CAAE+hB,SAAUF,IACtC7hB,CACb,IAAOwxB,OAAM,WACA,OAAA,IACb,IAEW,OADF7vB,KAAAsuB,aAAarU,GAAYyZ,EACvBA,CACR,CACD,eAAAC,CAAgBJ,EAAa3e,GAC3B,MAAMjC,EAAS3S,KACT6V,EAAO7V,KAAK6V,KACZvX,EAAU0B,KAAK1B,QACrB,QAAsC,IAAlC0B,KAAKquB,YAAYkF,GACZ,OAAAvzB,KAAKquB,YAAYkF,GAAa/X,MAAMnd,GAAYA,EAAQvG,UAE3D,MAAA07B,EAAY3d,EAAK2K,OAAO+S,GACxBY,EAAMC,KAAKD,KAAOC,KAAKC,UACzB,IAAAC,EAAYd,EAAU9S,KAAO,GAC7B6T,GAAc,EACd,QAAyB,IAAzBf,EAAUrS,WACAmT,EAAA3hB,EAAO0I,cAAc,aAAcmY,EAAUrS,YAAY3F,MAAK,SAAS2F,GACnEoT,GAAA,EACR,MAAAC,EAAO,IAAIC,KAAK,CAACtT,GAAa,CAAEjlB,KAAMs3B,EAAUkB,WAE/C,OADKP,EAAAA,EAAIQ,gBAAgBH,GACzBF,CACf,SACK,QAA4B,IAAlBd,EAAU9S,IACnB,MAAM,IAAIlL,MAAM,2BAA6B+d,EAAc,kCAE7D,MAAMG,EAAU/b,QAAQC,QAAQ0c,GAAW9Y,MAAK,SAASoZ,GACvD,OAAO,IAAIjd,SAAQ,SAASC,EAASC,GACnC,IAAI9D,EAAS6D,GACsB,IAA/BhD,EAAOigB,sBACT9gB,EAAS,SAAS+gB,GACV,MAAAz2B,EAAU,IAAI02B,GAAQD,GAC5Bz2B,EAAQ+S,aAAc,EACtBwG,EAAQvZ,EACpB,GAEeuW,EAAAf,KAAKQ,EAAYE,WAAWqgB,EAAYt2B,EAAQ6V,MAAOJ,OAAQ,EAAQ8D,EACtF,GACA,IAAO2D,MAAK,SAASnd,GAxdrB,IAA6BqiB,EA8dhB,OALa,IAAhB6T,GACFJ,EAAIa,gBAAgBV,GAEtBpZ,GAAuB7c,EAASm1B,GAChCn1B,EAAQsuB,SAAS+H,SAAWlB,EAAUkB,YA7dfhU,EA6d+C8S,EAAU9S,KA5d5EuU,OAAO,kBAAoB,GAA0C,IAArCvU,EAAIuU,OAAO,sBAC1C,aACLvU,EAAIuU,OAAO,iBAAmB,GAA0C,IAArCvU,EAAIuU,OAAO,sBACzC,aACF,aAydI52B,CACb,IAAOwxB,OAAM,SAASz4B,GAEV,MADET,QAAAS,MAAM,0CAA2Ck9B,GACnDl9B,CACZ,IAEW,OADF4I,KAAAquB,YAAYkF,GAAeG,EACzBA,CACR,CAQD,aAAAnX,CAAcV,EAAgBqZ,EAASC,EAAQC,GAC7C,MAAMziB,EAAS3S,KACR,OAAAA,KAAKqb,cAAc,UAAW8Z,EAAOp+B,OAAOykB,MAAK,SAASnd,GAC/D,IAAKA,EACI,OAAA,KAKT,QAJwB,IAApB82B,EAAOvO,UAAuBuO,EAAOvO,SAAW,KAClDvoB,EAAUA,EAAQvG,SACV+uB,QAAUsO,EAAOvO,UAEvBjU,EAAOmD,WAAWK,GAAWiB,uBAAwB,CACjD,MAAAuP,OAAkC,IAAtBwO,EAAOrf,WAAwBqf,EAAOrf,WAAWK,GAAWiB,4BAAyB,EACvG,GAAIuP,EAAW,CACb,MAAM0O,EAAgB1iB,EAAOmb,aAAa9V,IAAI3Z,GAC9CA,EAAUsU,EAAOmD,WAAWK,GAAWiB,uBAAuBsP,cAAcroB,EAASsoB,GAC9EhU,EAAAmb,aAAavyB,IAAI8C,EAASg3B,EAClC,CACF,CAUM,YATY,IAAfD,IACwB,iBAAfA,IACIA,EAp0DF,OAo0DEA,EAA8BnjB,GAAiBC,IAC1D,eAAgB7T,EAClBA,EAAQ+2B,WAAaA,EAEb/2B,EAAAi3B,SAAWF,IAAenjB,GAx0DvB,KACE,KAy0DjB4J,EAAeqZ,GAAW72B,EACnBA,CACb,GACG,CASD,mBAAAsmB,CAAoBrC,GAClB,MAAM9rB,EAAW8rB,EAAK9rB,SACtB,IAAIyJ,EAAWqiB,EAAKriB,SACd,MAAAs1B,OAAwD,IAAhC/+B,EAASwsB,WAAWwS,QAC5CC,OAAgD,IAA9Bj/B,EAASwsB,WAAW1I,MACtCob,OAAgD,IAA/Bl/B,EAASwsB,WAAW2S,OAC3C,GAAIrT,EAAKsT,SAAU,CACX,MAAA3b,EAAW,kBAAoBha,EAAS41B,KAC9C,IAAIC,EAAiB91B,KAAKoZ,MAAMpB,IAAIiC,GAC/B6b,IACHA,EAAiB,IAAIC,EACrBC,EAAStR,UAAUtf,KAAKzD,KAAKm0B,EAAgB71B,GAC9B61B,EAAAxb,MAAMlV,KAAKnF,EAASqa,OACnCwb,EAAex2B,IAAMW,EAASX,IAC9Bw2B,EAAeG,iBAAkB,EAC5Bj2B,KAAAoZ,MAAMhc,IAAI6c,EAAU6b,IAEhB71B,EAAA61B,CACjB,MAAA,GAAexT,EAAK4T,OAAQ,CAChB,MAAAjc,EAAW,qBAAuBha,EAAS41B,KACjD,IAAIM,EAAen2B,KAAKoZ,MAAMpB,IAAIiC,GAC7Bkc,IACHA,EAAe,IAAIC,EACnBJ,EAAStR,UAAUtf,KAAKzD,KAAKw0B,EAAcl2B,GAC9Bk2B,EAAA7b,MAAMlV,KAAKnF,EAASqa,OACjC6b,EAAa72B,IAAMW,EAASX,IACvBU,KAAAoZ,MAAMhc,IAAI6c,EAAUkc,IAEhBl2B,EAAAk2B,CACZ,CACG,GAAAZ,GAAyBE,GAAmBC,EAAgB,CAC1D,IAAAzb,EAAW,kBAAoBha,EAAS41B,KAAO,IAC/CN,IACUtb,GAAA,wBACVwb,IACUxb,GAAA,kBACVyb,IACUzb,GAAA,iBACd,IAAIoc,EAAiBr2B,KAAKoZ,MAAMpB,IAAIiC,GAC/Boc,IACHA,EAAiBp2B,EAASnI,QACtB29B,IACFY,EAAeC,cAAe,GAC5BZ,IACFW,EAAeE,aAAc,GAC3BhB,IACEc,EAAeG,cACjBH,EAAeG,YAAY/tB,IAAK,GAC9B4tB,EAAe9Y,uBACjB8Y,EAAe9Y,qBAAqB9U,IAAK,IAExCzI,KAAAoZ,MAAMhc,IAAI6c,EAAUoc,GACzBr2B,KAAK8tB,aAAavyB,IAAI86B,EAAgBr2B,KAAK8tB,aAAa9V,IAAI/X,KAEnDA,EAAAo2B,CACZ,CACD/T,EAAKriB,SAAWA,CACjB,CACD,eAAAyb,GACS,OAAA+a,CACR,CAMD,YAAAnF,CAAa5U,GACX,MAAM/J,EAAS3S,KACT6V,EAAO7V,KAAK6V,KACZC,EAAa9V,KAAK8V,WAClBgG,EAAcjG,EAAK8G,UAAUD,GAC/B,IAAAga,EACJ,MAAM7a,EAAiB,CAAA,EAEjBE,EAAU,GACZ,IAFuBD,EAAYhG,YAAc,IAE9BK,GAAWa,qBAAsB,CAChD,MAAA2f,EAAe7gB,EAAWK,GAAWa,qBAC3C0f,EAAeC,EAAajb,kBAC5BK,EAAQxkB,KAAKo/B,EAAa/a,aAAaC,EAAgBC,EAAanJ,GAC1E,KAAW,CACC,MAAAsJ,EAAoBH,EAAYI,sBAAwB,GAG9D,GAFAL,EAAevB,MAAQ,IAAIC,EAAM,EAAG,EAAG,GACvCsB,EAAeG,QAAU,EACrBG,MAAMC,QAAQH,EAAkBI,iBAAkB,CACpD,MAAM5a,EAAQwa,EAAkBI,gBACjBR,EAAAvB,MAAME,OAAO/Y,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIyQ,IAC3C2J,EAAAG,QAAUva,EAAM,EAChC,MAC0C,IAAvCwa,EAAkBK,kBACZP,EAAAxkB,KAAKob,EAAO4J,cAAcV,EAAgB,MAAOI,EAAkBK,iBAAkBrK,KAE/F4J,EAAe+a,eAAiD,IAArC3a,EAAkB4a,eAA4B5a,EAAkB4a,eAAiB,EAC5Ghb,EAAeib,eAAkD,IAAtC7a,EAAkB8a,gBAA6B9a,EAAkB8a,gBAAkB,OAC3D,IAA/C9a,EAAkB+a,2BACpBjb,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,eAAgBI,EAAkB+a,2BACpFjb,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,eAAgBI,EAAkB+a,4BAEvEN,EAAA12B,KAAK8wB,YAAW,SAAS1B,GACtC,OAAOA,EAAI1T,iBAAmB0T,EAAI1T,gBAAgBgB,EAC1D,IACcX,EAAAxkB,KACNogB,QAAQ6E,IACNxc,KAAKmvB,YAAW,SAASC,GACvB,OAAOA,EAAI3S,sBAAwB2S,EAAI3S,qBAAqBC,EAAeb,EACvF,KAGK,EAC+B,IAA5BC,EAAYmb,cACdpb,EAAe/b,KAAOC,GAElB,MAAAm3B,EAAYpb,EAAYob,WAAa3K,GAU3C,GATI2K,IAAc3K,IAChB1Q,EAAesb,aAAc,EAC7Btb,EAAeub,YAAa,IAE5Bvb,EAAesb,aAAc,EACzBD,IAAc3K,KAChB1Q,EAAewb,eAAwC,IAA5Bvb,EAAYwb,YAAyBxb,EAAYwb,YAAc,UAG5D,IAA9Bxb,EAAYyb,eAA4Bb,IAAiB/a,IAC3DI,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,YAAaC,EAAYyb,gBAC3E1b,EAAe2a,YAAc,IAAIxrB,EAAQ,EAAG,QACJ,IAApC8Q,EAAYyb,cAAc9vB,OAAkB,CACxC,MAAAA,EAAQqU,EAAYyb,cAAc9vB,MACzBoU,EAAA2a,YAAYj7B,IAAIkM,EAAOA,EACvC,CAQH,QANqC,IAAjCqU,EAAY0b,kBAA+Bd,IAAiB/a,IAC9DI,EAAQxkB,KAAKob,EAAO4J,cAAcV,EAAgB,QAASC,EAAY0b,wBACzB,IAA1C1b,EAAY0b,iBAAiBC,WAChB5b,EAAA6b,eAAiB5b,EAAY0b,iBAAiBC,gBAG9B,IAA/B3b,EAAY6b,gBAA6BjB,IAAiB/a,EAAmB,CAC/E,MAAMgc,EAAiB7b,EAAY6b,eACpB9b,EAAA+b,UAAW,IAAIrd,GAAQC,OACpCmd,EAAe,GACfA,EAAe,GACfA,EAAe,GACfzlB,GAEH,CAID,YAHoC,IAAhC4J,EAAY+b,iBAA8BnB,IAAiB/a,GACrDI,EAAAxkB,KAAKob,EAAO4J,cAAcV,EAAgB,cAAeC,EAAY+b,gBAAiB5lB,KAEzF0F,QAAQ6E,IAAIT,GAASP,MAAK,WACzB,MAAAvb,EAAW,IAAIy2B,EAAa7a,GAO3B,OANHC,EAAYlF,OACd3W,EAAS2W,KAAOkF,EAAYlF,MAC9BsE,GAAuBjb,EAAU6b,GACjCnJ,EAAOmb,aAAavyB,IAAI0E,EAAU,CAAE0c,UAAWD,IAC3CZ,EAAYhG,YACiB0W,GAAA1W,EAAY7V,EAAU6b,GAChD7b,CACb,GACG,CAED,gBAAAmb,CAAiB0c,GACf,MAAMC,EAAgBC,EAAgBC,iBAAiBH,GAAgB,IACnE,OAAAC,KAAiB/3B,KAAKuuB,cACjBwJ,EAAgB,OAAQ/3B,KAAKuuB,cAAcwJ,IAE7C/3B,KAAAuuB,cAAcwJ,GAAiB,EAC7BA,EAEV,CASD,cAAAG,CAAexV,GACb,MAAM/P,EAAS3S,KACT8V,EAAa9V,KAAK8V,WAClBsD,EAAQpZ,KAAKguB,eACnB,SAASmK,EAAqB1V,GACrB,OAAA3M,EAAWK,GAAWe,4BAA4ByO,gBAAgBlD,EAAW9P,GAAQ6I,MAAK,SAAShlB,GACjG,OAAA4hC,GAAuB5hC,EAAUisB,EAAW9P,EAC3D,GACK,CACD,MAAMoJ,EAAU,GAChB,IAAA,IAAS1kB,EAAI,EAAGua,EAAK8Q,EAAW9qB,OAAQP,EAAIua,EAAIva,IAAK,CAC7C,MAAAorB,EAAYC,EAAWrrB,GACvB4iB,EAAWmT,GAAmB3K,GAC9B4V,EAASjf,EAAMa,GACrB,GAAIoe,EACMtc,EAAAxkB,KAAK8gC,EAAO3E,aACf,CACD,IAAA4E,EAEFA,EADE7V,EAAU3M,YAAc2M,EAAU3M,WAAWK,GAAWe,4BACxCihB,EAAqB1V,GAErB2V,GAAuB,IAAIG,EAAkB9V,EAAW9P,GAE5EyG,EAAMa,GAAY,CAAEwI,YAAWiR,QAAS4E,GACxCvc,EAAQxkB,KAAK+gC,EACd,CACF,CACM,OAAA3gB,QAAQ6E,IAAIT,EACpB,CAMD,QAAAoV,CAASqH,GACP,MAAM7lB,EAAS3S,KACT6V,EAAO7V,KAAK6V,KACZC,EAAa9V,KAAK8V,WAClByM,EAAU1M,EAAK2M,OAAOgW,GACtB9V,EAAaH,EAAQG,WACrB3G,EAAU,GAChB,IAAA,IAAS1kB,EAAI,EAAGua,EAAK8Q,EAAW9qB,OAAQP,EAAIua,EAAIva,IAAK,CACnD,MAAM4I,OAAsC,IAA3ByiB,EAAWrrB,GAAG4I,eAv3BF,KADJmZ,EAw3BkDpZ,KAAKoZ,OAv3BzD,kBACnBA,EAAiB,gBAAI,IAAIqd,EAAqB,CAClDnc,MAAO,SACPsd,SAAU,EACVhB,UAAW,EACXE,UAAW,EACXK,aAAa,EACbsB,WAAW,EACX34B,KAAM44B,MAGHtf,EAAuB,iBA42B+DpZ,KAAKqb,cAAc,WAAYqH,EAAWrrB,GAAG4I,UACtI8b,EAAQxkB,KAAK0I,EACd,CA13BL,IAA+BmZ,EA43B3B,OADA2C,EAAQxkB,KAAKob,EAAOulB,eAAexV,IAC5B/K,QAAQ6E,IAAIT,GAASP,MAAK,SAAS0H,GACxC,MAAMvG,EAAYuG,EAAQxhB,MAAM,EAAGwhB,EAAQtrB,OAAS,GAC9C+gC,EAAazV,EAAQA,EAAQtrB,OAAS,GACtC4qB,EAAS,GACf,IAAA,IAASnrB,EAAI,EAAGua,EAAK+mB,EAAW/gC,OAAQP,EAAIua,EAAIva,IAAK,CAC7C,MAAAb,EAAWmiC,EAAWthC,GACtBorB,EAAYC,EAAWrrB,GACzB,IAAAirB,EACE,MAAAriB,EAAW0c,EAAUtlB,GAC3B,GAAIorB,EAAUV,OAASY,GAAgBC,WAAaH,EAAUV,OAASY,GAAgBE,gBAAkBJ,EAAUV,OAASY,GAAgBG,mBAAmC,IAAnBL,EAAUV,KAC7JO,GAA0B,IAA1BC,EAAQ+N,cAAyB,IAAIsI,EAAYpiC,EAAUyJ,GAAY,IAAI9B,EAAK3H,EAAUyJ,IACtE,IAAvBqiB,EAAKgO,eACPhO,EAAKuW,uBAEHpW,EAAUV,OAASY,GAAgBE,eACrCP,EAAK9rB,SAAWD,GAAoB+rB,EAAK9rB,SAAUM,GAC1C2rB,EAAUV,OAASY,GAAgBG,eAC5CR,EAAK9rB,SAAWD,GAAoB+rB,EAAK9rB,SAAUK,SAE5C,GAAA4rB,EAAUV,OAASY,GAAgB8G,MACrCnH,EAAA,IAAIwW,GAAatiC,EAAUyJ,QACzB,GAAAwiB,EAAUV,OAASY,GAAgBgH,WACrCrH,EAAA,IAAIyW,GAAKviC,EAAUyJ,QACjB,GAAAwiB,EAAUV,OAASY,GAAgB+G,UACrCpH,EAAA,IAAI0W,GAASxiC,EAAUyJ,OACrB,IAAAwiB,EAAUV,OAASY,GAAgB6G,OAG5C,MAAM,IAAIhU,MAAM,iDAAmDiN,EAAUV,MAFtEO,EAAA,IAAI2W,GAAOziC,EAAUyJ,EAG7B,CACGE,OAAOmR,KAAKgR,EAAK9rB,SAAS0iC,iBAAiBthC,OAAS,GACtDo1B,GAAmB1K,EAAMC,GAE3BD,EAAK1L,KAAOjE,EAAOyI,iBAAiBmH,EAAQ3L,MAAQ,QAAU4hB,GAC9Dtd,GAAuBoH,EAAMC,GACzBE,EAAU3M,YACmB0W,GAAA1W,EAAYwM,EAAMG,GACnD9P,EAAOgS,oBAAoBrC,GAC3BE,EAAOjrB,KAAK+qB,EACb,CACD,IAAA,IAASjrB,EAAI,EAAGua,EAAK4Q,EAAO5qB,OAAQP,EAAIua,EAAIva,IAC1Csb,EAAOmb,aAAavyB,IAAIinB,EAAOnrB,GAAI,CACjCmrB,OAAQgW,EACR9V,WAAYrrB,IAGZ,GAAkB,IAAlBmrB,EAAO5qB,OAGT,OAFI2qB,EAAQzM,YACV0W,GAA+B1W,EAAY0M,EAAO,GAAID,GACjDC,EAAO,GAEV,MAAA2W,EAAQ,IAAIC,GACd7W,EAAQzM,YACqB0W,GAAA1W,EAAYqjB,EAAO5W,GACpD5P,EAAOmb,aAAavyB,IAAI49B,EAAO,CAAE3W,OAAQgW,IACzC,IAAA,IAASnhC,EAAI,EAAGua,EAAK4Q,EAAO5qB,OAAQP,EAAIua,EAAIva,IACpC8hC,EAAA/7B,IAAIolB,EAAOnrB,IAEZ,OAAA8hC,CACb,GACG,CAMD,UAAA1H,CAAW4H,GACL,IAAA9I,EACJ,MAAM+I,EAAYt5B,KAAK6V,KAAK8Z,QAAQ0J,GAC9BE,EAASD,EAAUA,EAAUp9B,MACnC,GAAKq9B,EAiBE,MAbgB,gBAAnBD,EAAUp9B,KACZq0B,EAAS,IAAItoB,EACXuxB,GAAUC,SAASF,EAAOG,MAC1BH,EAAOI,aAAe,EACtBJ,EAAOK,OAAS,EAChBL,EAAOM,MAAQ,KAEW,iBAAnBP,EAAUp9B,OACnBq0B,EAAS,IAAIjnB,GAAoBiwB,EAAOO,KAAMP,EAAOO,KAAMP,EAAOQ,MAAOR,EAAOQ,KAAMR,EAAOK,MAAOL,EAAOM,OAEzGP,EAAU1iB,OACZ2Z,EAAO3Z,KAAO5W,KAAKob,iBAAiBke,EAAU1iB,OAChDsE,GAAuBqV,EAAQ+I,GACxB3hB,QAAQC,QAAQ2Y,GAhBrB55B,QAAQC,KAAK,+CAiBhB,CAMD,QAAA26B,CAAStB,GACP,MAAM+J,EAAUh6B,KAAK6V,KAAKka,MAAME,GAC1BlU,EAAU,GACP,IAAA,IAAA1kB,EAAI,EAAGua,EAAKooB,EAAQ7J,OAAOv4B,OAAQP,EAAIua,EAAIva,IAClD0kB,EAAQxkB,KAAKyI,KAAKi6B,iBAAiBD,EAAQ7J,OAAO94B,KAOpD,YALoC,IAAhC2iC,EAAQE,oBACVne,EAAQxkB,KAAKyI,KAAKqb,cAAc,WAAY2e,EAAQE,sBAEpDne,EAAQxkB,KAAK,MAERogB,QAAQ6E,IAAIT,GAASP,MAAK,SAAS0H,GAClC,MAAAgX,EAAsBhX,EAAQE,MAC9B+W,EAAajX,EACbkX,EAAQ,GACRC,EAAe,GACrB,IAAA,IAAShjC,EAAI,EAAGua,EAAKuoB,EAAWviC,OAAQP,EAAIua,EAAIva,IAAK,CAC7C,MAAAijC,EAAYH,EAAW9iC,GAC7B,GAAIijC,EAAW,CACbF,EAAM7iC,KAAK+iC,GACL,MAAAC,EAAM,IAAI/W,EACY,OAAxB0W,GACFK,EAAIxT,UAAUmT,EAAoBz4B,MAAW,GAAJpK,GAE3CgjC,EAAa9iC,KAAKgjC,EAC5B,MACU5jC,QAAQC,KAAK,mDAAoDojC,EAAQ7J,OAAO94B,GAEnF,CACM,OAAA,IAAImjC,GAASJ,EAAOC,EACjC,GACG,CAMD,aAAA7I,CAAciJ,GACZ,MAAM5kB,EAAO7V,KAAK6V,KACZlD,EAAS3S,KACT06B,EAAe7kB,EAAK6Z,WAAW+K,GAC/BE,EAAgBD,EAAa9jB,KAAO8jB,EAAa9jB,KAAO,aAAe6jB,EACvEG,EAAe,GACfC,EAAwB,GACxBC,EAAyB,GACzBC,EAAkB,GAClBC,EAAiB,GACd,IAAA,IAAA3jC,EAAI,EAAGua,EAAK8oB,EAAaO,SAASrjC,OAAQP,EAAIua,EAAIva,IAAK,CACxD,MAAAwvB,EAAU6T,EAAaO,SAAS5jC,GAChCo8B,EAAUiH,EAAa5G,SAASjN,EAAQ4M,SACxCjyB,EAASqlB,EAAQrlB,OACjBoV,EAAOpV,EAAO05B,KACdC,OAAoC,IAA5BT,EAAaU,WAAwBV,EAAaU,WAAW3H,EAAQ0H,OAAS1H,EAAQ0H,MAC9FE,OAAqC,IAA5BX,EAAaU,WAAwBV,EAAaU,WAAW3H,EAAQ4H,QAAU5H,EAAQ4H,YAClF,IAAhB75B,EAAO05B,OAEXN,EAAarjC,KAAKyI,KAAKqb,cAAc,OAAQzE,IAC7CikB,EAAsBtjC,KAAKyI,KAAKqb,cAAc,WAAY8f,IAC1DL,EAAuBvjC,KAAKyI,KAAKqb,cAAc,WAAYggB,IAC3DN,EAAgBxjC,KAAKk8B,GACrBuH,EAAezjC,KAAKiK,GACrB,CACD,OAAOmW,QAAQ6E,IAAI,CACjB7E,QAAQ6E,IAAIoe,GACZjjB,QAAQ6E,IAAIqe,GACZljB,QAAQ6E,IAAIse,GACZnjB,QAAQ6E,IAAIue,GACZpjB,QAAQ6E,IAAIwe,KACXxf,MAAK,SAAS+T,GACT,MAAA9V,EAAQ8V,EAAa,GACrB+L,EAAiB/L,EAAa,GAC9BgM,EAAkBhM,EAAa,GAC/BuE,EAAWvE,EAAa,GACxB9B,EAAU8B,EAAa,GACvBiM,EAAS,GACf,IAAA,IAASnkC,EAAI,EAAGua,EAAK6H,EAAM7hB,OAAQP,EAAIua,EAAIva,IAAK,CACxC,MAAA6jC,EAAOzhB,EAAMpiB,GACbokC,EAAgBH,EAAejkC,GAC/BqkC,EAAiBH,EAAgBlkC,GACjCo8B,EAAUK,EAASz8B,GACnBmK,EAASisB,EAAQp2B,GACvB,QAAa,IAAT6jC,EACF,SACEA,EAAKtzB,cACPszB,EAAKtzB,eAEP,MAAM+zB,EAAgBhpB,EAAOipB,uBAAuBV,EAAMO,EAAeC,EAAgBjI,EAASjyB,GAClG,GAAIm6B,EACF,IAAA,IAASE,EAAI,EAAGA,EAAIF,EAAc/jC,OAAQikC,IACjCL,EAAAjkC,KAAKokC,EAAcE,GAG/B,CACD,OAAO,IAAIC,GAAcnB,OAAe,EAAQa,EACtD,GACG,CACD,cAAAnZ,CAAe3I,GACb,MAAM7D,EAAO7V,KAAK6V,KACZlD,EAAS3S,KACT4Z,EAAU/D,EAAK4D,MAAMC,GAC3B,YAAqB,IAAjBE,EAAQ0I,KACH,KACF3P,EAAO0I,cAAc,OAAQzB,EAAQ0I,MAAM9G,MAAK,SAAS8G,GAC9D,MAAM4Y,EAAOvoB,EAAO8I,YAAY9I,EAAOub,UAAWtU,EAAQ0I,KAAMA,GAUzD,YATiB,IAApB1I,EAAQqS,SACLiP,EAAAa,UAAS,SAASrhC,GACrB,GAAKA,EAAEshC,OAEE,IAAA,IAAA3kC,EAAI,EAAGua,EAAKgI,EAAQqS,QAAQr0B,OAAQP,EAAIua,EAAIva,IACnDqD,EAAEuyB,sBAAsB51B,GAAKuiB,EAAQqS,QAAQ50B,EAEzD,IAEa6jC,CACb,GACG,CAMD,QAAAhK,CAASxX,GACP,MACM/G,EAAS3S,KACT4Z,EAFO5Z,KAAK6V,KAEG4D,MAAMC,GACrBuiB,EAActpB,EAAOsnB,iBAAiBvgB,GACtCwiB,EAAe,GACfC,EAAcviB,EAAQ0J,UAAY,GACxC,IAAA,IAASjsB,EAAI,EAAGua,EAAKuqB,EAAYvkC,OAAQP,EAAIua,EAAIva,IAC/C6kC,EAAa3kC,KAAKob,EAAO0I,cAAc,OAAQ8gB,EAAY9kC,KAE7D,MAAM+kC,OAAmC,IAAjBxiB,EAAQyW,KAAkB1Y,QAAQC,QAAQ,MAAQjF,EAAO0I,cAAc,OAAQzB,EAAQyW,MAC/G,OAAO1Y,QAAQ6E,IAAI,CAACyf,EAAatkB,QAAQ6E,IAAI0f,GAAeE,IAAkB5gB,MAAK,SAAS0H,GACpF,MAAAgY,EAAOhY,EAAQ,GACfI,EAAWJ,EAAQ,GACnBmZ,EAAWnZ,EAAQ,GACR,OAAbmZ,GACGnB,EAAAa,UAAS,SAASzZ,GAChBA,EAAKgO,eAELhO,EAAAga,KAAKD,EAAUxO,GAC9B,IAEM,IAAA,IAASx2B,EAAI,EAAGua,EAAK0R,EAAS1rB,OAAQP,EAAIua,EAAIva,IACvC6jC,EAAA99B,IAAIkmB,EAASjsB,IAEb,OAAA6jC,CACb,GACG,CAGD,gBAAAjB,CAAiBvgB,GACf,MAAM7D,EAAO7V,KAAK6V,KACZC,EAAa9V,KAAK8V,WAClBnD,EAAS3S,KACf,QAAkC,IAA9BA,KAAKiuB,UAAUvU,GACV,OAAA1Z,KAAKiuB,UAAUvU,GAElB,MAAAE,EAAU/D,EAAK4D,MAAMC,GACrB6iB,EAAW3iB,EAAQhD,KAAOjE,EAAOyI,iBAAiBxB,EAAQhD,MAAQ,GAClEmF,EAAU,GACVygB,EAAc7pB,EAAOme,YAAW,SAAS1B,GAC7C,OAAOA,EAAI/M,gBAAkB+M,EAAI/M,eAAe3I,EACtD,IA4DW,OA3DH8iB,GACFzgB,EAAQxkB,KAAKilC,QAEQ,IAAnB5iB,EAAQ2W,QACFxU,EAAAxkB,KACNob,EAAO0I,cAAc,SAAUzB,EAAQ2W,QAAQ/U,MAAK,SAAS+U,GAC3D,OAAO5d,EAAO8I,YAAY9I,EAAOwb,YAAavU,EAAQ2W,OAAQA,EACxE,KAGW5d,EAAAwc,YAAW,SAASC,GACzB,OAAOA,EAAI9T,sBAAwB8T,EAAI9T,qBAAqB5B,EAClE,IAAO+iB,SAAQ,SAAS/I,GAClB3X,EAAQxkB,KAAKm8B,EACnB,IACS1zB,KAAAiuB,UAAUvU,GAAa/B,QAAQ6E,IAAIT,GAASP,MAAK,SAASzD,GACzD,IAAAmjB,EAUA,GARFA,GADqB,IAAnBthB,EAAQwW,OACH,IAAIsM,GACF3kB,EAAQngB,OAAS,EACnB,IAAIwhC,GACiB,IAAnBrhB,EAAQngB,OACVmgB,EAAQ,GAER,IAAI0M,EAETyW,IAASnjB,EAAQ,GACnB,IAAA,IAAS1gB,EAAI,EAAGua,EAAKmG,EAAQngB,OAAQP,EAAIua,EAAIva,IACtC6jC,EAAA99B,IAAI2a,EAAQ1gB,IAUjB,GAPAuiB,EAAQhD,OACLskB,EAAAvO,SAAS/V,KAAOgD,EAAQhD,KAC7BskB,EAAKtkB,KAAO2lB,GAEdrhB,GAAuBggB,EAAMthB,GACzBA,EAAQ9D,YACqB0W,GAAA1W,EAAYolB,EAAMthB,QAC5B,IAAnBA,EAAQ5Q,OAAmB,CACvB,MAAAA,EAAS,IAAIwa,EACZxa,EAAA+d,UAAUnN,EAAQ5Q,QACzBkyB,EAAKyB,aAAa3zB,EAC1B,WACoC,IAAxB4Q,EAAQoS,aACLkP,EAAAhkC,SAAS6vB,UAAUnN,EAAQoS,kBAET,IAArBpS,EAAQkN,UACLoU,EAAAzxB,WAAWsd,UAAUnN,EAAQkN,eAEd,IAAlBlN,EAAQnS,OACLyzB,EAAAzzB,MAAMsf,UAAUnN,EAAQnS,OAO1B,OAJFkL,EAAOmb,aAAa8O,IAAI1B,IAC3BvoB,EAAOmb,aAAavyB,IAAI2/B,EAAM,CAAE,GAElCvoB,EAAOmb,aAAa9V,IAAIkjB,GAAMzhB,MAAQC,EAC/BwhB,CACb,IACWl7B,KAAKiuB,UAAUvU,EACvB,CAMD,SAAAuX,CAAU4L,GACR,MAAM/mB,EAAa9V,KAAK8V,WAClBgnB,EAAW98B,KAAK6V,KAAK4Z,OAAOoN,GAC5BlqB,EAAS3S,KACTwvB,EAAQ,IAAI4J,GACd0D,EAASlmB,OACX4Y,EAAM5Y,KAAOjE,EAAOyI,iBAAiB0hB,EAASlmB,OAChDsE,GAAuBsU,EAAOsN,GAC1BA,EAAShnB,YACoB0W,GAAA1W,EAAY0Z,EAAOsN,GAC9C,MAAAC,EAAUD,EAASrjB,OAAS,GAC5BsC,EAAU,GAChB,IAAA,IAAS1kB,EAAI,EAAGua,EAAKmrB,EAAQnlC,OAAQP,EAAIua,EAAIva,IAC3C0kB,EAAQxkB,KAAKob,EAAO0I,cAAc,OAAQ0hB,EAAQ1lC,KAEpD,OAAOsgB,QAAQ6E,IAAIT,GAASP,MAAK,SAAS/B,GACxC,IAAA,IAASpiB,EAAI,EAAGua,EAAK6H,EAAM7hB,OAAQP,EAAIua,EAAIva,IACnCm4B,EAAApyB,IAAIqc,EAAMpiB,IAkBX,OADAsb,EAAAmb,aAfoB,CAACoN,IACpB,MAAA8B,MAA0CjP,IAChD,IAAA,MAAYxtB,EAAKhB,KAAUoT,EAAOmb,cAC5BvtB,aAAey1B,GAAYz1B,aAAew0B,KACxBiI,EAAAzhC,IAAIgF,EAAKhB,GAS1B,OANF27B,EAAAa,UAAUkB,IACb,MAAMtM,EAAWhe,EAAOmb,aAAa9V,IAAIilB,GACzB,MAAZtM,GACkBqM,EAAAzhC,IAAI0hC,EAAOtM,EAChC,IAEIqM,CAAA,EAEaE,CAAmB1N,GAClCA,CACb,GACG,CACD,sBAAAoM,CAAuBV,EAAMO,EAAeC,EAAgBjI,EAASjyB,GACnE,MAAMg6B,EAAS,GACT2B,EAAajC,EAAKtkB,KAAOskB,EAAKtkB,KAAOskB,EAAKrF,KAC1C3I,EAAc,GAUhB,IAAAkQ,EACI,OAVJrR,GAAgBvqB,EAAO2S,QAAU4X,GAAgBE,QAC9CiP,EAAAa,UAAS,SAASx5B,GACjBA,EAAO0qB,uBACTC,EAAY31B,KAAKgL,EAAOqU,KAAOrU,EAAOqU,KAAOrU,EAAOszB,KAE9D,IAEM3I,EAAY31B,KAAK4lC,GAGXpR,GAAgBvqB,EAAO2S,OAC7B,KAAK4X,GAAgBE,QACEmR,EAAAC,GACrB,MACF,KAAKtR,GAAgBjF,SACEsW,EAAAE,GACrB,MACF,KAAKvR,GAAgB70B,SACrB,KAAK60B,GAAgBtkB,MACE21B,EAAAG,GACrB,MACF,QACE,GACO,IADC7B,EAAepX,SAEE8Y,EAAAC,QAKAD,EAAAG,GAK7B,MAAMC,OAA0C,IAA1B/J,EAAQ+J,cAA2BtR,GAAcuH,EAAQ+J,eAAiBpR,GAC1FqR,EAAcz9B,KAAK09B,sBAAsBhC,GAC/C,IAAA,IAAS5iC,EAAI,EAAG6kC,EAAKzQ,EAAYt1B,OAAQkB,EAAI6kC,EAAI7kC,IAAK,CACpD,MAAM8kC,EAAQ,IAAIR,EAChBlQ,EAAYp0B,GAAK,IAAMizB,GAAgBvqB,EAAO2S,MAC9CsnB,EAAch6B,MACdg8B,EACAD,GAE4B,gBAA1B/J,EAAQ+J,eACVx9B,KAAK69B,mCAAmCD,GAE1CpC,EAAOjkC,KAAKqmC,EACb,CACM,OAAApC,CACR,CACD,qBAAAkC,CAAsBza,GACpB,IAAIwa,EAAcxa,EAASxhB,MAC3B,GAAIwhB,EAASsB,WAAY,CACjB,MAAA9c,EAAQmmB,GAA4B6P,EAAYr/B,aAChD0/B,EAAS,IAAI9T,aAAayT,EAAY7lC,QAC5C,IAAA,IAASkB,EAAI,EAAG6kC,EAAKF,EAAY7lC,OAAQkB,EAAI6kC,EAAI7kC,IAC/CglC,EAAOhlC,GAAK2kC,EAAY3kC,GAAK2O,EAEjBg2B,EAAAK,CACf,CACM,OAAAL,CACR,CACD,kCAAAI,CAAmCD,GAC3BA,EAAAG,kBAAoB,SAAiD5b,GAElE,OAAA,IADiBniB,gBAAgBs9B,GAA0BzU,GAAuC5B,IAC9EjnB,KAAKg+B,MAAOh+B,KAAKwnB,OAAQxnB,KAAKi+B,eAAiB,EAAG9b,EACnF,EACIyb,EAAMG,kBAAkBG,2CAA4C,CACrE,EAuDH,SAAS9F,GAAuB5hC,EAAU62B,EAAc1a,GACtD,MAAMqQ,EAAaqK,EAAarK,WAC1BjH,EAAU,GACP,SAAAoiB,EAAwBpM,EAAe7N,GAC9C,OAAOvR,EAAO0I,cAAc,WAAY0W,GAAevW,MAAK,SAASyH,GAC1DzsB,EAAAguB,aAAaN,EAAejB,EAC3C,GACG,CACD,IAAA,MAAWmb,KAAqBpb,EAAY,CAC1C,MAAMiD,EAAqBC,GAAWkY,IAAsBA,EAAkBjY,cAC1EF,KAAsBzvB,EAASwsB,YAEnCjH,EAAQxkB,KAAK4mC,EAAwBnb,EAAWob,GAAoBnY,GACrE,CACD,QAA6B,IAAzBoH,EAAap2B,UAAuBT,EAASO,MAAO,CAChD,MAAAksB,EAAWtQ,EAAO0I,cAAc,WAAYgS,EAAap2B,SAASukB,MAAK,SAAS6iB,GACpF7nC,EAASgB,SAAS6mC,EACxB,IACItiB,EAAQxkB,KAAK0rB,EACd,CAGD,OAFA/H,GAAuB1kB,EAAU62B,GAzEnC,SAAuB72B,EAAU62B,EAAc1a,GAC7C,MAAMqQ,EAAaqK,EAAarK,WAC1Bsb,EAAM,IAAIC,GACZ,QAAwB,IAAxBvb,EAAWqI,SAgBb,OAhBkC,CAClC,MAAMpI,EAAWtQ,EAAOkD,KAAKwQ,UAAUrD,EAAWqI,UAC5CzkB,EAAMqc,EAASrc,IACfvM,EAAM4oB,EAAS5oB,IACjB,QAAQ,IAARuM,QAA0B,IAARvM,EASpB,YADA1D,QAAQC,KAAK,uEANb,GADI0nC,EAAA/iC,IAAI,IAAImH,EAAQkE,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAAK,IAAIlE,EAAQrI,EAAI,GAAIA,EAAI,GAAIA,EAAI,KACzE4oB,EAASsB,WAAY,CACvB,MAAMia,EAAW5Q,GAA4BrH,GAAsBtD,EAASqD,gBACxEgY,EAAA13B,IAAIkB,eAAe02B,GACnBF,EAAAjkC,IAAIyN,eAAe02B,EACxB,CAKP,CAGE,MAAM/Q,EAAUJ,EAAaI,QAC7B,QAAgB,IAAZA,EAAoB,CAChB,MAAAgR,EAAkB,IAAI/7B,EACtBg8B,EAAS,IAAIh8B,EACnB,IAAA,IAASrL,EAAI,EAAGua,EAAK6b,EAAQ71B,OAAQP,EAAIua,EAAIva,IAAK,CAC1C,MAAAmK,EAASisB,EAAQp2B,GACnB,QAAoB,IAApBmK,EAAO6pB,SAAqB,CAC9B,MAAMpI,EAAWtQ,EAAOkD,KAAKwQ,UAAU7kB,EAAO6pB,UACxCzkB,EAAMqc,EAASrc,IACfvM,EAAM4oB,EAAS5oB,IACjB,QAAQ,IAARuM,QAA0B,IAARvM,EAAgB,CAIpC,GAHAqkC,EAAOvL,KAAK73B,KAAKjB,IAAIiB,KAAK+I,IAAIuC,EAAI,IAAKtL,KAAK+I,IAAIhK,EAAI,MACpDqkC,EAAOtL,KAAK93B,KAAKjB,IAAIiB,KAAK+I,IAAIuC,EAAI,IAAKtL,KAAK+I,IAAIhK,EAAI,MACpDqkC,EAAOrL,KAAK/3B,KAAKjB,IAAIiB,KAAK+I,IAAIuC,EAAI,IAAKtL,KAAK+I,IAAIhK,EAAI,MAChD4oB,EAASsB,WAAY,CACvB,MAAMia,EAAW5Q,GAA4BrH,GAAsBtD,EAASqD,gBAC5EoY,EAAO52B,eAAe02B,EACvB,CACDC,EAAgBpkC,IAAIqkC,EAC9B,MACU/nC,QAAQC,KAAK,sEAEhB,CACF,CACD0nC,EAAIK,eAAeF,EACpB,CACDjoC,EAASooC,YAAcN,EACjB,MAAAO,EAAS,IAAIC,GACfR,EAAAS,UAAUF,EAAOG,QACrBH,EAAOp/B,OAAS6+B,EAAI13B,IAAI/B,WAAWy5B,EAAIjkC,KAAO,EAC9C7D,EAASyoC,eAAiBJ,CAC5B,CAsBgBK,CAAA1oC,EAAU62B,EAAc1a,GAC/BgF,QAAQ6E,IAAIT,GAASP,MAAK,WACxB,YAAyB,IAAzB6R,EAAaI,QA71CxB,SAAyBj3B,EAAUi3B,EAAS9a,GAC1C,IAAIwsB,GAAmB,EACnBC,GAAiB,EACjBC,GAAgB,EACpB,IAAA,IAAShoC,EAAI,EAAGua,EAAK6b,EAAQ71B,OAAQP,EAAIua,EAAIva,IAAK,CAC1C,MAAAmK,EAASisB,EAAQp2B,GAOvB,QANwB,IAApBmK,EAAO6pB,WACU8T,GAAA,QACC,IAAlB39B,EAAO8pB,SACQ8T,GAAA,QACI,IAAnB59B,EAAOoqB,UACOyT,GAAA,GACdF,GAAoBC,GAAkBC,EACxC,KACH,CACD,IAAKF,IAAqBC,IAAmBC,EACpC,OAAA1nB,QAAQC,QAAQphB,GACzB,MAAM8oC,EAA2B,GAC3BC,EAAyB,GACzBC,EAAwB,GAC9B,IAAA,IAASnoC,EAAI,EAAGua,EAAK6b,EAAQ71B,OAAQP,EAAIua,EAAIva,IAAK,CAC1C,MAAAmK,EAASisB,EAAQp2B,GACvB,GAAI8nC,EAAkB,CACd,MAAAM,OAAsC,IAApBj+B,EAAO6pB,SAAsB1Y,EAAO0I,cAAc,WAAY7Z,EAAO6pB,UAAY70B,EAASwsB,WAAW9rB,SAC7HooC,EAAyB/nC,KAAKkoC,EAC/B,CACD,GAAIL,EAAgB,CACZ,MAAAK,OAAoC,IAAlBj+B,EAAO8pB,OAAoB3Y,EAAO0I,cAAc,WAAY7Z,EAAO8pB,QAAU90B,EAASwsB,WAAW2S,OACzH4J,EAAuBhoC,KAAKkoC,EAC7B,CACD,GAAIJ,EAAe,CACX,MAAAI,OAAqC,IAAnBj+B,EAAOoqB,QAAqBjZ,EAAO0I,cAAc,WAAY7Z,EAAOoqB,SAAWp1B,EAASwsB,WAAW1I,MAC3HklB,EAAsBjoC,KAAKkoC,EAC5B,CACF,CACD,OAAO9nB,QAAQ6E,IAAI,CACjB7E,QAAQ6E,IAAI8iB,GACZ3nB,QAAQ6E,IAAI+iB,GACZ5nB,QAAQ6E,IAAIgjB,KACXhkB,MAAK,SAAS6K,GACT,MAAAqZ,EAAiBrZ,EAAU,GAC3BsZ,EAAetZ,EAAU,GACzBuZ,EAAcvZ,EAAU,GAQvB,OAPH8Y,IACF3oC,EAAS0iC,gBAAgBhiC,SAAWwoC,GAClCN,IACF5oC,EAAS0iC,gBAAgBvD,OAASgK,GAChCN,IACF7oC,EAAS0iC,gBAAgB5e,MAAQslB,GACnCppC,EAASqpC,sBAAuB,EACzBrpC,CACX,GACA,CAyyC6CspC,CAAgBtpC,EAAU62B,EAAaI,QAAS9a,GAAUnc,CACvG,GACA,CC3jFA,MAAMupC,WAAsBhL,GAC1B,WAAA32B,CAAYT,EAAO,KAAMkB,EAAQ,EAAGW,EAAS,EAAGwgC,EAAQ,GACtDtgC,MAAM,MACNM,KAAKigC,iBAAkB,EACvBjgC,KAAKpB,MAAQ,CAAEjB,OAAMkB,QAAOW,SAAQwgC,SACpChgC,KAAK+zB,UAAY7J,GACjBlqB,KAAKg0B,UAAY9J,GACjBlqB,KAAKkgC,MAAQzV,GACbzqB,KAAKmgC,iBAAkB,EACvBngC,KAAK4zB,OAAQ,EACb5zB,KAAKogC,gBAAkB,CACxB,ECZH,MAAMC,GACJ,WAAAjiC,CAAYkiC,EAAO,GACjBtgC,KAAKsgC,KAAOA,EACZtgC,KAAKugC,MAAQ,GACbvgC,KAAKwgC,QAAU,GACfxgC,KAAKygC,eAAiB,GACtBzgC,KAAK0gC,aAAe,CACrB,CACD,WAAAC,CAAYC,GACV,IAAK5gC,KAAKwgC,QAAQI,GAAW,CACrB,MAAAC,EAAS7gC,KAAK8gC,gBACpBD,EAAOhgC,iBAAiB,UAAWb,KAAK+gC,WAAWzE,KAAKt8B,KAAM4gC,IACzD5gC,KAAAwgC,QAAQI,GAAYC,CAC1B,CACF,CACD,cAAAG,GACE,IAAA,IAAS3pC,EAAI,EAAGA,EAAI2I,KAAKsgC,KAAMjpC,IACzB,KAAE2I,KAAK0gC,aAAe,GAAKrpC,GACtB,OAAAA,EACJ,OAAA,CACR,CACD,UAAA0pC,CAAWH,EAAUK,GACb,MAAArpB,EAAU5X,KAAKygC,eAAeG,GAEhC,GADJhpB,GAAWA,EAAQqpB,GACfjhC,KAAKugC,MAAM3oC,OAAQ,CACf,MAAEggB,QAASspB,EAAUD,IAAKE,WAAMC,GAAaphC,KAAKugC,MAAMc,QACzDrhC,KAAAygC,eAAeG,GAAYM,EAChClhC,KAAKwgC,QAAQI,GAAUU,YAAYH,EAAMC,EAC/C,MACMphC,KAAK0gC,cAAgB,GAAKE,CAE7B,CACD,gBAAAW,CAAiBT,GACf9gC,KAAK8gC,cAAgBA,CACtB,CACD,cAAAU,CAAelB,GACbtgC,KAAKsgC,KAAOA,CACb,CACD,WAAAgB,CAAYL,EAAKG,GACR,OAAA,IAAIzpB,SAASC,IACZ,MAAAgpB,EAAW5gC,KAAKghC,kBACD,IAAjBJ,GACF5gC,KAAK2gC,YAAYC,GACjB5gC,KAAK0gC,cAAgB,GAAKE,EACrB5gC,KAAAygC,eAAeG,GAAYhpB,EAChC5X,KAAKwgC,QAAQI,GAAUU,YAAYL,EAAKG,IAExCphC,KAAKugC,MAAMhpC,KAAK,CAAEqgB,UAASqpB,MAAKG,YACjC,GAEJ,CACD,OAAAn3B,GACEjK,KAAKwgC,QAAQ/D,SAASoE,GAAWA,EAAOY,cACxCzhC,KAAKygC,eAAe7oC,OAAS,EAC7BoI,KAAKwgC,QAAQ5oC,OAAS,EACtBoI,KAAKugC,MAAM3oC,OAAS,EACpBoI,KAAK0gC,aAAe,CACrB,ECzDH,MAQMgB,GAAuB,EACvBC,GAA+B,EAC/BC,GAAyB,EACzBC,GAA6B,GAiBnC,MAAMC,GACJ,WAAA1jC,GACE4B,KAAK+hC,SAjBmB,EAkBxB/hC,KAAKgiC,SAAW,EAChBhiC,KAAKiiC,WAAa,EAClBjiC,KAAKkiC,YAAc,EACnBliC,KAAKmiC,WAAa,EAClBniC,KAAKoiC,WAAa,EAClBpiC,KAAKqiC,UAAY,EACjBriC,KAAKsiC,uBArCyB,EAsC9BtiC,KAAKuiC,OAAS,GACdviC,KAAKwiC,qBAAuB,CAC1B,CACEC,SAtCwB,EAuCxBC,eAxCsC,EAyCtCC,oBAAqB,EACrBC,cAxCe,EAyCfC,WAxCyB,EAyCzBC,eAAgBlB,GAChBmB,iBAAkBrB,GAClBsB,MA1C2B,EA2C3BC,oBAAqB,CAAC,EAAG,EAAG,EAAG,GAC/BC,WAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAClCC,QAAS,KAGbnjC,KAAKojC,SAAW,GAChBpjC,KAAKqjC,WAAa,IACnB,EAEH,MAAMC,GACJ,WAAAllC,CAAYT,EAAM+jB,EAAYC,EAAY4hB,GACxCvjC,KAAKwjC,eAAY,EACjBxjC,KAAKyjC,mBAAgB,EACrBzjC,KAAK0jC,aAAU,EACV1jC,KAAAwjC,UAAY,IAAIxe,SAASrnB,EAAK2jB,OAAQ3jB,EAAK+jB,WAAaA,EAAYC,GACzE3hB,KAAKyjC,cAAgBF,EACrBvjC,KAAK0jC,QAAU,CAChB,CACD,UAAAC,GACE,MAAMpkC,EAAQS,KAAKwjC,UAAUI,SAAS5jC,KAAK0jC,SAEpC,OADP1jC,KAAK0jC,SAAW,EACTnkC,CACR,CACD,WAAAskC,GACE,MAAMtkC,EAAQS,KAAKwjC,UAAUM,UAAU9jC,KAAK0jC,QAAS1jC,KAAKyjC,eAEnD,OADPzjC,KAAK0jC,SAAW,EACTnkC,CACR,CACD,WAAAwkC,GACE,MAAMxkC,EAAQS,KAAKwjC,UAAUre,UAAUnlB,KAAK0jC,QAAS1jC,KAAKyjC,eAEnD,OADPzjC,KAAK0jC,SAAW,EACTnkC,CACR,CACD,WAAAykC,GACE,MAAM/2B,EAAOjN,KAAKwjC,UAAUre,UAAUnlB,KAAK0jC,QAAS1jC,KAAKyjC,eACnDz2B,EAAQhN,KAAKwjC,UAAUre,UAAUnlB,KAAK0jC,QAAU,EAAG1jC,KAAKyjC,eACxDlkC,EAAQ0N,EAAOg3B,EAAA,EAAK,IAAKj3B,EAExB,OADPhN,KAAK0jC,SAAW,EACTnkC,CACR,CACD,UAAA2kC,GACE,MAAM3kC,EAAQS,KAAKwjC,UAAUW,SAASnkC,KAAK0jC,QAAS1jC,KAAKyjC,eAElD,OADPzjC,KAAK0jC,SAAW,EACTnkC,CACR,CACD,eAAA6kC,CAAgBC,GACR,MAAA9kC,EAAQ,IAAItH,WAAW+H,KAAKwjC,UAAUliB,OAAQthB,KAAKwjC,UAAU9hB,WAAa1hB,KAAK0jC,QAASW,GAEvF,OADPrkC,KAAK0jC,SAAWW,EACT9kC,CACR,CACD,KAAA+kC,CAAMC,GAEG,OADPvkC,KAAK0jC,SAAWa,EACTvkC,IACR,CACD,KAAAwkC,CAAMC,EAAeC,QACN,IAATA,IACKA,EAAA,GAET,MAAMhjB,EAAa1hB,KAAK0jC,QACxB,IAAI/hB,EAAa,EACV,KAAA3hB,KAAKwjC,UAAUI,SAAS5jC,KAAK0jC,WAAagB,GAAQ/iB,EAAa8iB,GACpE9iB,IACK3hB,KAAA0jC,UAIA,OAFH/hB,EAAa8iB,GACVzkC,KAAA0jC,UACA,IAAIzrC,WAAW+H,KAAKwjC,UAAUliB,OAAQthB,KAAKwjC,UAAU9hB,WAAaA,EAAYC,EACtF,EAEH,MAAMgjB,GAAU,CAEd,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IAEF,SAAShzB,GAAW2P,GACd,MAAuB,oBAAhBvjB,aACF,IAAIA,aAAcC,OAAOsjB,GAE3BsjB,OAAOC,KAAKvjB,GAAQwjB,SAAS,OACtC,CC1IA,IAAIC,GACAC,GACAC,GACJ,MAAMC,GAAgB,CACpBC,IAAK,CACHC,gCAAiC,SAASruC,GACxCkuC,GAAO,IAAIhtC,WAAW+sC,GAASK,QAAQC,OAAOhkB,OAC/C,IAGL,MAAMikB,GACJ,IAAAR,GACM,OAAAA,KAGKA,GADY,oBAAVS,MACFA,MAAM,gCAAkCC,IAAMjqB,MAAMkqB,GAAaA,EAASC,gBAAenqB,MAAMmqB,GAAgBC,YAAYC,YAAYF,EAAaT,MAAgB1pB,KAAKxb,KAAK8lC,OAE9KF,YAAYC,YAAYjB,OAAOC,KAAKY,GAAM,UAAWP,IAAe1pB,KAAKxb,KAAK8lC,OAEhFf,GACR,CACD,KAAAe,CAAM3jB,GACJ6iB,GAAW7iB,EAAO6iB,SACJE,GAAAC,IAAIC,gCAAgC,EACnD,CACD,MAAApnC,CAAOyD,EAAOskC,EAAmB,GAC/B,IAAKf,GACG,MAAA,IAAIxvB,MAAM,+CAClB,MAAMwwB,EAAiBvkC,EAAMkgB,WACvBskB,EAAgBjB,GAASK,QAAQa,OAAOF,GACzCf,GAAA1pC,IAAIkG,EAAOwkC,GAChBF,EAAmBA,GAAoBI,OAAOnB,GAASK,QAAQe,0BAA0BH,EAAeD,IACxG,MAAMK,EAAkBrB,GAASK,QAAQa,OAAOH,GAC1CO,EAAatB,GAASK,QAAQkB,gBAClCF,EACAN,EACAE,EACAD,GAEIQ,EAAMvB,GAAKvjC,MAAM2kC,EAAiBA,EAAkBC,GAGnD,OAFEtB,GAAAK,QAAQoB,KAAKR,GACbjB,GAAAK,QAAQoB,KAAKJ,GACfG,CACR,EAEH,MAAMf,GAAO,mksCC5Cb,MAAMiB,WAA8BC,GAClC,WAAAvoC,CAAYoiB,EAAQomB,EAAQ1qC,GACpBwD,WAAA,EAAQ8gB,EAAO,GAAG3hB,MAAO2hB,EAAO,GAAGhhB,OAAQonC,EAAQ1qC,EAAM2qC,IAC/D7mC,KAAK8mC,yBAA0B,EAC/B9mC,KAAKtB,eAAgB,EACrBsB,KAAKpB,MAAQ4hB,CACd,ECNH,MAAMumB,WAA+BJ,GACnC,WAAAvoC,CAAY4oC,EAASnoC,EAAOW,EAAQwgC,EAAO4G,EAAQ1qC,GACjDwD,MAAMsnC,EAASnoC,EAAOW,EAAQonC,EAAQ1qC,GACtC8D,KAAKinC,0BAA2B,EAChCjnC,KAAKpB,MAAMohC,MAAQA,EACnBhgC,KAAKkgC,MAAQzV,EACd,ECPH,IAAIvqB,GAAYC,OAAOC,eAEnBC,GAAgB,CAACC,EAAKC,EAAKhB,KADT,EAACe,EAAKC,EAAKhB,KAAUgB,KAAOD,EAAMJ,GAAUI,EAAKC,EAAK,CAAEC,YAAY,EAAMC,cAAc,EAAMC,UAAU,EAAMnB,UAAWe,EAAIC,GAAOhB,CAAA,EAExJoB,CAAgBL,EAAoB,iBAARC,EAAmBA,EAAM,GAAKA,EAAKhB,GACxDA,GAST,MAAM2nC,GAAiB,IACjBC,GAAe,KACfC,GAAe,GACfC,GAAsB,aACtBC,GAA4B,oBAC5Bp1B,GAAuB,cACvBD,GAAiB,OACjBs1B,OAAiCC,QACvC,IACIC,GADAC,GAAiB,EAEhB,MAACC,GAAoC,MAClC,MAAAC,EAAc,cAAcx1B,EAChC,WAAAhU,CAAYiU,GACV3S,MAAM2S,GACNrS,KAAK6nC,eAAiB,GACtB7nC,KAAK8nC,iBAAmB,KACxB9nC,KAAK+nC,kBAAoB,KACpB/nC,KAAAgoC,WAAa,IAAI3H,GACtBrgC,KAAKioC,gBAAkB,GACvBjoC,KAAKkoC,aAAe,KACU,oBAAnBC,gBACDxxC,QAAAC,KACN,iIAGL,CACD,iBAAAwxC,CAAkBj0B,GAET,OADPnU,KAAK6nC,eAAiB1zB,EACfnU,IACR,CACD,cAAAwhC,CAAe6G,GAEN,OADFroC,KAAAgoC,WAAWxG,eAAe6G,GACxBroC,IACR,CACD,aAAA6gB,CAAcynB,GAYL,OAXPtoC,KAAKkoC,aAAe,CAClBK,cAAeD,EAASxyB,WAAW8mB,IAAI,iCACvC4L,cAAeF,EAASxyB,WAAW8mB,IAAI,iCACvC6L,cAAeH,EAASxyB,WAAW8mB,IAAI,gCACvC8L,aAAcJ,EAASxyB,WAAW8mB,IAAI,iCACtC+L,cAAeL,EAASxyB,WAAW8mB,IAAI,gCACvCgM,eAAgBN,EAASxyB,WAAW8mB,IAAI,mCAAqC0L,EAASxyB,WAAW8mB,IAAI,0CAEnG0L,EAASO,aAAaC,WACxB9oC,KAAKkoC,aAAaM,eAAgB,GAE7BxoC,IACR,CACD,IAAA+kC,GACM,IAAC/kC,KAAK+nC,kBAAmB,CAC3B,MAAMgB,EAAW,IAAIl0B,EAAW7U,KAAKqS,SAC5B02B,EAAAj0B,QAAQ9U,KAAK6nC,gBACbkB,EAAA7zB,mBAAmBlV,KAAKmV,iBAC3B,MAAA6zB,EAAYD,EAASE,UAAU,uBAC/BC,EAAe,IAAIr0B,EAAW7U,KAAKqS,SAC5B62B,EAAAp0B,QAAQ9U,KAAK6nC,gBAC1BqB,EAAan0B,gBAAgB,eAChBm0B,EAAAh0B,mBAAmBlV,KAAKmV,iBAC/B,MAAAg0B,EAAgBD,EAAaD,UAAU,yBAC7CjpC,KAAK+nC,kBAAoBpwB,QAAQ6E,IAAI,CAACwsB,EAAWG,IAAgB3tB,MAAK,EAAE4tB,EAAYC,MAC5E,MAAAC,EAAK1B,EAAY2B,YAAYzE,WAC7BhgB,EAAO,CACX,kBACA,uBAAyB9O,KAAKwzB,UAAU5B,EAAY6B,cACpD,2BAA6BzzB,KAAKwzB,UAAU5B,EAAY8B,kBACxD,sBAAwB1zB,KAAKwzB,UAAU5B,EAAY+B,aACnD,4BACAP,EACA,eACAE,EAAGM,UAAUN,EAAGroC,QAAQ,KAAO,EAAGqoC,EAAGO,YAAY,OACjDzqC,KAAK,MACFY,KAAAioC,gBAAkB9T,IAAIQ,gBAAgB,IAAIF,KAAK,CAAC3P,KACrD9kB,KAAK8nC,iBAAmBuB,EACnBrpC,KAAAgoC,WAAWzG,kBAAiB,KAC/B,MAAMV,EAAS,IAAIiJ,OAAO9pC,KAAKioC,iBACzBH,EAAmB9nC,KAAK8nC,iBAAiBpmC,MAAM,GAE9C,OADAm/B,EAAAS,YAAY,CAAEplC,KAAM,OAAQ6tC,OAAQ/pC,KAAKkoC,aAAcJ,oBAAoB,CAACA,IAC5EjH,CAAA,GACR,IAEC6G,GAAiB,GACX/wC,QAAAC,KACN,uJAGJ8wC,IACD,CACD,OAAO1nC,KAAK+nC,iBACb,CACD,IAAAl0B,CAAKC,EAAKC,EAAQC,EAAYC,GACxB,GAAsB,OAAtBjU,KAAKkoC,aACD,MAAA,IAAI1yB,MAAM,+EAElB,MAAMZ,EAAS,IAAIC,EAAW7U,KAAKqS,SACnCuC,EAAOG,gBAAgB,eAChBH,EAAAM,mBAAmBlV,KAAKmV,iBACxBP,EAAAf,KACLC,GACCwN,IACKimB,GAAAA,GAAW3K,IAAItb,GAAS,CAE1B,OADmBimB,GAAWvvB,IAAIsJ,GAChBoS,QAAQlY,KAAKzH,GAAQ8b,MAAM5b,EAC9C,CACDjU,KAAKgqC,eAAe1oB,GAAQ9F,MAAMnd,GAAY0V,EAASA,EAAO1V,GAAW,OAAMwxB,MAAM5b,EAAO,GAE9FD,EACAC,EAEH,CACD,kBAAAg2B,CAAmBC,EAAiBC,GAC5B,MAAAC,MAAEA,QAAOvrC,EAAOW,OAAAA,EAAAonC,OAAQA,OAAQ1qC,EAAM9E,MAAAA,EAAAizC,SAAOA,GAAaH,EAChE,GAAa,UAAThuC,EACK,OAAAyb,QAAQE,OAAOzgB,GACpB,IAAAiH,EACA,GAAwB,IAAxB8rC,EAAU9H,UACZhkC,EAAU,IAAIqoC,GAAsB0D,EAAOxD,EAAQ0D,QAC9C,CACC,MAAAtD,EAAUoD,EAAM,GAAGpD,QACzB3oC,EAAU8rC,EAAU/H,WAAa,EAAI,IAAI2E,GAAuBC,EAASnoC,EAAOW,EAAQ2qC,EAAU/H,WAAYwE,EAAQ0D,IAAoB,IAAI3D,GAAkBK,EAASnoC,EAAOW,EAAQonC,EAAQ0D,GACjM,CACDjsC,EAAQ21B,UAAwC,IAA5BoW,EAAM,GAAGpD,QAAQpvC,OAAeuyB,EAAeI,EACnElsB,EAAQ01B,UAAY5J,EACpB9rB,EAAQ8hC,iBAAkB,EAC1B9hC,EAAQ+S,aAAc,EAChB,MAAAgkB,EAAamV,GAAgBJ,GAM5B,MALH,eAAgB9rC,EAClBA,EAAQ+2B,WAAaA,EAEb/2B,EAAAi3B,SAAWF,IAAenjB,GA/HrB,KADE,IAiIT5T,EAAAmsC,oBJvI0B,EIuIJH,GACvBhsC,CACR,CAMK,cAAA2rC,CAAeS,GAAA,OAAAC,EAAA1qC,KAAA2qC,WAAA,UAAArpB,EAAQyoB,EAAS,IACpC,MAAMI,EJZZ,SAAcxsC,GACN,MAAAitC,EAAK,IAAI3yC,WAAW0F,EAAK2jB,OAAQ3jB,EAAK+jB,WAAYijB,GAAQ/sC,QAChE,GAAIgzC,EAAG,KAAOjG,GAAQ,IACtBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,KAAOjG,GAAQ,IAClBiG,EAAG,MAAQjG,GAAQ,KACnBiG,EAAG,MAAQjG,GAAQ,IACX,MAAA,IAAInvB,MAAM,+BAEZ,MAAA20B,EAAY,IAAIrI,GAChB+I,EAAmB,GAAKxyC,YAAYg6B,kBACpCyY,EAAe,IAAIxH,GAAa3lC,EAAMgnC,GAAQ/sC,OAAQizC,GAAkB,GACpEV,EAAApI,SAAW+I,EAAa/G,cACxBoG,EAAAnI,SAAW8I,EAAa/G,cACxBoG,EAAAlI,WAAa6I,EAAa/G,cAC1BoG,EAAAjI,YAAc4I,EAAa/G,cAC3BoG,EAAAhI,WAAa2I,EAAa/G,cAC1BoG,EAAA/H,WAAa0I,EAAa/G,cAC1BoG,EAAA9H,UAAYyI,EAAa/G,cAC7B,MAAAgH,EAAaD,EAAa/G,cACtBoG,EAAA7H,uBAAyBwI,EAAa/G,cAC1C,MAAAiH,EAAgBF,EAAa/G,cAC7BkH,EAAgBH,EAAa/G,cAC7BmH,EAAgBJ,EAAa/G,cAC7BoH,EAAgBL,EAAa/G,cAC7BqH,EAAgBN,EAAa9G,cAC7BqH,EAAgBP,EAAa9G,cAE7BsH,EAAc,IAAIhI,GAAa3lC,EAAMgnC,GAAQ/sC,OAASizC,EADvB,EAAbE,EAAiB,GACsD,GAC/F,IAAA,IAAS1zC,EAAI,EAAGA,EAAI0zC,EAAY1zC,IAC9B8yC,EAAU5H,OAAOhrC,KAAK,CACpBg0C,UAAW,IAAItzC,WAAW0F,EAAK2jB,OAAQ3jB,EAAK+jB,WAAa4pB,EAAYtH,cAAesH,EAAYtH,eAChGwH,uBAAwBF,EAAYtH,gBAGxC,MAAMyH,EAAY,IAAInI,GAAa3lC,EAAMqtC,EAAeC,GAAe,GACjES,EAAM,CACVjJ,SAAUgJ,EAAUnH,MAClB,GAEAT,cACFnB,eAAgB+I,EAAU5H,cAC1BjB,cAAe6I,EAAU5H,cACzBlB,oBAAqB8I,EAAU5H,cAC/BhB,WAAY4I,EAAU9H,aACtBb,eAAgB2I,EAAU9H,aAC1BZ,iBAAkB0I,EAAU9H,aAC5BX,MAAOyI,EAAU9H,aACjBV,oBAAqB,CACnBwI,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,cAEZT,WAAY,CACVuI,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,aACV8H,EAAU9H,cAEZR,QAAS,IAILwI,GAAcD,EAAI/I,oBAAsB,EAF1B,GACA,EAEpB,IAAA,IAAStrC,EAAI,EAAGA,EAAIs0C,EAAYt0C,IAAK,CACnC,MAAMu0C,EAAS,CACbC,UAAWJ,EAAU5H,cACrBiI,UAAWL,EAAU9H,aACrBoI,YAAaN,EAAU9H,aACvBqI,eAAgB,CAACP,EAAU9H,aAAc8H,EAAU9H,aAAc8H,EAAU9H,aAAc8H,EAAU9H,cACnGsI,aAAa,IACbC,YAAavpC,KAlNmB,GAoN9BipC,EAAOG,aACFH,EAAAK,YAAcR,EAAUvH,aACxB0H,EAAAM,YAAcT,EAAUvH,eAExB0H,EAAAK,YAAcR,EAAU1H,cACxB6H,EAAAM,YAAcT,EAAU1H,eAE7B2H,EAAAvI,QAAQ9rC,GAAKu0C,CAClB,CACDzB,EAAU3H,qBAAqB5qC,OAAS,EAC9BuyC,EAAA3H,qBAAqBjrC,KAAKm0C,GACpC,MAAMS,EAAY,IAAI7I,GAAa3lC,EAAMutC,EAAeC,GAAe,GAChE,KAAAgB,EAAUzI,QAAUyH,GAAe,CAClC,MAAAiB,EAAqBD,EAAUpI,cAC/BsI,EAAUF,EAAU3H,MAAM4H,GAC1B7rC,EAAMoR,GAAW06B,GAEnB,GADMlC,EAAA/G,SAAS7iC,GAAO4rC,EAAU/H,gBAAgBgI,EAAqBC,EAAQ1qB,WAAa,GAC1FphB,EAAIuuB,MAAM,SAAU,CACtB,MAAMwd,EAAO36B,GAAWw4B,EAAU/G,SAAS7iC,IACjC4pC,EAAA/G,SAAS7iC,GAAO+rC,EAAK1C,UAAU,EAAG0C,EAAKzC,YAAY,MAC9D,CACD,MAAM0C,EAAYH,EAAqB,EAAI,EAAIA,EAAqB,EAAI,EACxED,EAAU7H,MAAMiI,EACjB,CACD,GAAIlB,GAAiB,EACZ,OAAAlB,EACT,MAAMqC,EAAY,IAAIlJ,GAAa3lC,EAAMytC,EAAeC,GAAe,GACjEoB,EAAgBD,EAAU3I,cAC1B6I,EAAgBF,EAAU3I,cAC1B8I,EAAsBH,EAAUzI,cAChC6I,EAAsBJ,EAAUzI,cAChC8I,EAAmBL,EAAUzI,cAC7B+I,EAAqBN,EAAUzI,cAC/BgJ,EAAa,GACnB,IAAA,IAAS11C,EAAI,EAAGA,EAAI0zC,EAAY1zC,IAC9B01C,EAAWx1C,KAAK,CACdy1C,WAAYR,EAAUzI,cACtBkJ,mBAAoBT,EAAUzI,cAC9BmJ,mBAAoBV,EAAUzI,cAC9BoJ,qBAAsBX,EAAUzI,cAChCqJ,qBAAsBZ,EAAUzI,gBAG9B,MAAAsJ,EAAsBjC,EAAgBoB,EAAU9I,QAChD4J,EAAsBD,EAAsBV,EAC5CY,EAAmBD,EAAsBV,EACzCY,EAAqBD,EAAmBV,EACxCY,EAAgB,IAAIx1C,WAAW0F,EAAK2jB,OAAQ3jB,EAAK+jB,WAAa2rB,EAAqBV,GACnFe,EAAgB,IAAIz1C,WAAW0F,EAAK2jB,OAAQ3jB,EAAK+jB,WAAa4rB,EAAqBV,GACnFe,EAAa,IAAI11C,WAAW0F,EAAK2jB,OAAQ3jB,EAAK+jB,WAAa6rB,EAAkBV,GAC7Ee,EAAe,IAAI31C,WAAW0F,EAAK2jB,OAAQ3jB,EAAK+jB,WAAa8rB,EAAoBV,GAUhF,OATP3C,EAAU9G,WAAa,CACrBoJ,gBACAC,gBACAK,aACAU,gBACAC,gBACAC,aACAC,gBAEKzD,CACT,CItIwB0D,CAAK,IAAI51C,WAAWqpB,IAClC,GJ3IkB,II2IlB6oB,EAAUpI,SACZ,OA8SR,SAAgCoI,GAAW,OAAAO,EAAA1qC,KAAA,MAAA,YACnC,MAAA+hC,SAAEA,GAAaoI,EACjB,QAAyB,IAAzB2D,GAAW/L,GACP,MAAA,IAAIvsB,MAAM,2CAEd,IAAAu4B,EJ3c4B,II4c5B5D,EAAU7H,yBACPmF,KACKA,GAAA,IAAI9vB,SAAeC,GAAY8yB,EAAA1qC,KAAA,MAAA,YAC/B,MAAAguC,EAAQ,IAAIzI,SACZyI,EAAMjJ,OACZntB,EAAQo2B,EAChB,OAEID,QAAatG,IAEf,MAAMT,EAAU,GAChB,IAAA,IAASiH,EAAa,EAAGA,EAAa9D,EAAU5H,OAAO3qC,OAAQq2C,IAAc,CAC3E,MAAMC,EAAa5yC,KAAKjB,IAAI,EAAG8vC,EAAUlI,YAAcgM,GACjDE,EAAc7yC,KAAKjB,IAAI,EAAG8vC,EAAUjI,aAAe+L,GACnDG,EAAajE,EAAUhI,WAAa7mC,KAAKjB,IAAI,EAAG8vC,EAAUhI,YAAc8L,GAAc,EACtFI,EAAQlE,EAAU5H,OAAO0L,GAC3B,IAAA1C,EAQA5tC,EAPA,GJ9d0B,II8d1BwsC,EAAU7H,uBACZiJ,EAAY8C,EAAM9C,cACxB,IJ/dkC,II+dnBpB,EAAU7H,uBAGb,MAAA,IAAI9sB,MAAM,yDAFhB+1B,EAAYwC,EAAK/vC,OAAOqwC,EAAM9C,UAAW8C,EAAM7C,uBAGhD,CAGC7tC,EADE2wC,GAASvM,KAAcwM,GAClB,IAAIvkB,aACTuhB,EAAUjqB,OACViqB,EAAU7pB,WACV6pB,EAAU5pB,WAAaqI,aAAaqI,mBAE7Bic,GAASvM,KAAcyM,GACzB,IAAIr2C,YACTozC,EAAUjqB,OACViqB,EAAU7pB,WACV6pB,EAAU5pB,WAAaxpB,YAAYk6B,mBAG9BkZ,EAETvE,EAAQzvC,KAAK,CACXoG,OACAkB,MAAOqvC,EACP1uC,OAAQ2uC,EACRnO,MAAOoO,GAEV,CACG,IAAA/vC,EACJ,GAAIowC,GAAqB7R,IAAIkR,GAAW/L,IAC5B1jC,EAAyB,IAAzB8rC,EAAUhI,WAAmB,IAAIuM,GAAY1H,EAAQ,GAAGrpC,KAAMwsC,EAAUlI,WAAYkI,EAAUjI,aAAe,IAAInC,GAAciH,EAAQ,GAAGrpC,KAAMwsC,EAAUlI,WAAYkI,EAAUjI,YAAaiI,EAAUhI,gBAC5M,CACL,GAAIgI,EAAUhI,WAAa,EACnB,MAAA,IAAI3sB,MAAM,6CAClBnX,EAAU,IAAIsoC,GAAkBK,EAASmD,EAAUlI,WAAYkI,EAAUjI,YAC1E,CACD7jC,EAAQ2oC,QAAUA,EACV3oC,EAAAnC,KAAOoyC,GAASvM,GAChB1jC,EAAAuoC,OAASkH,GAAW/L,GAC5B1jC,EAAQ+S,aAAc,EAChB,MAAAgkB,EAAamV,GAAgBJ,GAK5B,MAJH,eAAgB9rC,EAClBA,EAAQ+2B,WAAaA,EAEb/2B,EAAAi3B,SAAWF,IAAenjB,GAAiBk1B,GAAeD,GAC7DvvB,QAAQC,QAAQvZ,EACzB,GAAA,CArXeswC,CAAiBxE,GAE1B,MAAMyE,EAAa7E,EACb8E,EAAiB7uC,KAAK+kC,OAAOvpB,MAAK,IAC/Bxb,KAAKgoC,WAAW1G,YAAY,CAAEplC,KAAM,YAAaolB,SAAQstB,cAAc,CAACttB,MAC9E9F,MAAMje,GAAMyC,KAAKiqC,mBAAmB1sC,EAAEI,KAAMwsC,KAExC,OADP5C,GAAWhsC,IAAI+lB,EAAQ,CAAEoS,QAASmb,IAC3BA,CACR,GAAA,CACD,OAAA5kC,GAKS,OAJPjK,KAAKgoC,WAAW/9B,UACZjK,KAAKioC,iBACH9T,IAAAa,gBAAgBh1B,KAAKioC,iBAC3BP,KACO1nC,IACR,GAEH,IAAI8uC,EAAclH,EA0PX,OAxPPvnC,GAAcyuC,EAAa,cAAe,CACxCC,MAAO,EACPC,UAAW,IAEb3uC,GAAcyuC,EAAa,mBAAoB,CAC7CG,KAAM,EACNC,KAAM,EACNC,IAAK,EACLC,IAAK,EACLC,IAAK,EACLC,IAAK,EACLC,mBAAoB,EACpBC,OAAQ,EACRC,aAAc,EACdC,cAAe,EACfC,SAAU,GACVC,QAAS,GACTC,4BAA6B,GAC7BC,OAAQ,GACRC,OAAQ,GACRC,OAAQ,GACRC,SAAU,KAEZ5vC,GAAcyuC,EAAa,eAAgB,CACzCoB,cACAC,wBACAC,oBACAC,wBACAC,4BACAC,yBACAC,mBACAC,mBACAC,2BACAC,0BAGYtwC,GAAAyuC,EAAa,eAAe,WACpC,IAAA/E,EACAhC,EACA6I,EACJ,MAAMnH,EAAeoH,cACfnH,EAAmBoH,kBACnBnH,EAAcoH,aACf3c,KAAAvzB,iBAAiB,WAAW,SAAStD,GACxC,MAAMyzC,EAAUzzC,EAAEI,KAClB,OAAQqzC,EAAQ90C,MACd,IAAK,OACH6tC,EAASiH,EAAQjH,OAmBTkH,EAlBHD,EAAQlJ,iBAmBGC,EAAA,IAAIpwB,SAASC,IACjBg5B,EAAA,CAAEK,aAAYC,qBAAsBt5B,GAClDu5B,MAAMP,EAAW,IAChBp1B,MAAK,KACNo1B,EAAYQ,uBACiB,IAAzBR,EAAYS,UACd16C,QAAQC,KAAK,8DACd,IAzBC,MACF,IAAK,YACHmxC,EAAkBvsB,MAAK,KACjB,IACI,MAAA4uB,MAAEA,EAAOvY,QAAAA,EAAAhzB,MAASA,EAAOW,OAAAA,EAAA8xC,SAAQA,EAAU1K,OAAAA,EAAAyD,SAAQA,GAwBnE,SAAmB/oB,GACjB,MAAMiwB,EAAW,IAAIX,EAAYS,SAAS,IAAIp5C,WAAWqpB,IACzD,SAASkwB,IACPD,EAASE,QACTF,EAASG,QACV,CACG,IAACH,EAASI,UAEN,UAAA,IAAIn8B,MAAM,wDAElB,MAAMo8B,EAAcL,EAASM,UAAYlI,EAAYqF,UAAYrF,EAAYoF,MACvElwC,EAAQ0yC,EAASO,WACjBtyC,EAAS+xC,EAASQ,YAClB3P,EAAamP,EAASS,aAAe,EACrCjH,EAAawG,EAASU,YACtB5P,EAAYkP,EAASW,WACrBZ,EAAWC,EAASY,cACpB9H,EAAWkH,EAASa,eACpBC,iBAAEA,eAAkBC,GA2G5B,SAA6BV,EAAa/yC,EAAOW,EAAQ8xC,GACnD,IAAAe,EACAC,EACJ,MAAMh0C,EAAUszC,IAAgBjI,EAAYoF,MAAQwD,EAAgBC,EACpE,IAAA,IAASn7C,EAAI,EAAGA,EAAIiH,EAAQ1G,OAAQP,IAAK,CACjC,MAAAo7C,EAAMn0C,EAAQjH,GAChB,GAAC0yC,EAAO0I,EAAIC,MAEXD,EAAIb,YAAYe,SAASf,MAE1BN,GAAYmB,EAAIJ,iBAAiBz6C,OAAS,MAE1C66C,EAAIG,iBAAqBC,EAAah0C,IAAUg0C,EAAarzC,KAI1D,OAFP6yC,EAAmBI,EAAIJ,iBAAiBf,EAAW,EAAI,GACvDgB,EAAeG,EAAIH,aAAahB,EAAW,EAAI,GACxC,CAAEe,mBAAkBC,eAC5B,CAIM,OAHP37C,QAAQC,KAAK,sFACby7C,EAAmB3I,EAAiBoG,OACpCwC,EAAe7I,EAAayG,WACrB,CAAEmC,mBAAkBC,eAC5B,CAjI4CQ,CAAoBlB,EAAa/yC,EAAOW,EAAQ8xC,GAC3F,IAAKzyC,IAAUW,IAAWurC,EAElB,UAAA,IAAIv1B,MAAM,sCAEd,IAAC+7B,EAASwB,mBAEN,UAAA,IAAIv9B,MAAM,8CAElB,MAAM40B,EAAQ,GACRvY,EAAU,GAChB,IAAA,IAASmhB,EAAO,EAAGA,EAAO3Q,EAAW2Q,IAAQ,CAC3C,MAAMhM,EAAU,GAChB,IAAA,IAASiM,EAAM,EAAGA,EAAMlI,EAAYkI,IAAO,CACzC,MAAMC,EAAY,GAClB,IAAIC,EAAUC,EACd,IAAA,IAASC,EAAQ,EAAGA,EAAQjR,EAAYiR,IAAS,CAC/C,MAAMC,EAAY/B,EAASgC,kBAAkBN,EAAKI,EAAOL,GAC5C,IAATA,GAAsB,IAARC,GAAuB,IAAVI,GAAgBC,EAAUE,UAAY,GAAM,GAAKF,EAAUG,WAAa,GAAM,GAC3G98C,QAAQC,KAAK,sFAEXm0C,EAAa,GACfoI,EAAWG,EAAUE,UACrBJ,EAAYE,EAAUG,aAEtBN,EAAWG,EAAUz0C,MACrBu0C,EAAYE,EAAU9zC,QAElB,MAAAk0C,EAAM,IAAIz7C,WAAWs5C,EAASoC,8BAA8BV,EAAKI,EAAO,EAAGhB,IAEjF,IADed,EAASqC,eAAeF,EAAKT,EAAKI,EAAOL,EAAMX,EAAkB,GAAG,GAAM,GAGjF,UAAA,IAAI78B,MAAM,6CAElB09B,EAAU37C,KAAKm8C,EAChB,CACK,MAAAG,EAAUC,EAAOZ,GACflM,EAAAzvC,KAAK,CAAEoG,KAAMk2C,EAASh1C,MAAOs0C,EAAU3zC,OAAQ4zC,IAC/CvhB,EAAAt6B,KAAKs8C,EAAQvyB,OACtB,CACD8oB,EAAM7yC,KAAK,CAAEyvC,UAASnoC,QAAOW,SAAQonC,OAAQ0L,GAC9C,CAEM,WAAA,CAAElI,QAAOvY,UAAShzB,QAAOW,SAAQ8xC,WAAU1K,OAAQ0L,EAAcjI,WACzE,CAtF+E0J,CAAU/C,EAAQ1vB,QACnF8S,KAAAkN,YACH,CAAEplC,KAAM,YAAa0uC,GAAIoG,EAAQpG,GAAIR,QAAOvrC,QAAOW,SAAQ8xC,WAAU1K,SAAQyD,YAC7ExY,EAEH,OAAQz6B,GACPT,QAAQS,MAAMA,GACTg9B,KAAAkN,YAAY,CAAEplC,KAAM,QAAS0uC,GAAIoG,EAAQpG,GAAIxzC,MAAOA,EAAM45C,SAChE,KAKT,IAAcC,CADlB,IA2EI,MAAM+C,EAAiB,CACrB,CACEtB,GAAI,gBACJd,YAAa,CAACjI,EAAYqF,WAC1BqD,iBAAkB,CAAC3I,EAAiBiG,SAAUjG,EAAiBiG,UAC/D2C,aAAc,CAAC7I,EAAa0G,qBAAsB1G,EAAa0G,sBAC/D8D,cAAetxC,IACfuxC,cAAe,EACftB,iBAAiB,GAEnB,CACEF,GAAI,gBACJd,YAAa,CAACjI,EAAYoF,MAAOpF,EAAYqF,WAC7CqD,iBAAkB,CAAC3I,EAAiB8F,OAAQ9F,EAAiB8F,QAC7D8C,aAAc,CAAC7I,EAAa2G,iBAAkB3G,EAAa2G,kBAC3D6D,cAAe,EACfC,cAAe,EACftB,iBAAiB,GAEnB,CACEF,GAAI,eACJd,YAAa,CAACjI,EAAYoF,MAAOpF,EAAYqF,WAC7CqD,iBAAkB,CAAC3I,EAAiByF,IAAKzF,EAAiB0F,KAC1DkD,aAAc,CAAC7I,EAAakH,qBAAsBlH,EAAa8G,uBAC/D0D,cAAe,EACfC,cAAe,EACftB,iBAAiB,GAEnB,CACEF,GAAI,gBACJd,YAAa,CAACjI,EAAYoF,MAAOpF,EAAYqF,WAC7CqD,iBAAkB,CAAC3I,EAAiBuF,KAAMvF,EAAiBwF,MAC3DoD,aAAc,CAAC7I,EAAagH,gBAAiBhH,EAAa4G,sBAC1D4D,cAAe,EACfC,cAAe,EACftB,iBAAiB,GAEnB,CACEF,GAAI,gBACJd,YAAa,CAACjI,EAAYoF,MAAOpF,EAAYqF,WAC7CqD,iBAAkB,CAAC3I,EAAiBuF,MACpCqD,aAAc,CAAC7I,EAAa+G,iBAC5ByD,cAAe,EACfC,cAAe,EACftB,iBAAiB,GAEnB,CACEF,GAAI,iBACJd,YAAa,CAACjI,EAAYoF,MAAOpF,EAAYqF,WAC7CqD,iBAAkB,CAAC3I,EAAiB+F,aAAc/F,EAAiBgG,eACnE4C,aAAc,CAAC7I,EAAaiH,wBAAyBjH,EAAa6G,0BAClE2D,cAAe,EACfC,cAAe,EACftB,iBAAiB,IAGfL,EAAgByB,EAAermB,MAAK,SAASrzB,EAAG1B,GAC7C,OAAA0B,EAAE25C,cAAgBr7C,EAAEq7C,aACjC,IACUzB,EAAgBwB,EAAermB,MAAK,SAASrzB,EAAG1B,GAC7C,OAAA0B,EAAE45C,cAAgBt7C,EAAEs7C,aACjC,IAwBI,SAASrB,EAAatzC,GACpB,OAAIA,GAAS,GAEkB,IAAvBA,EAAQA,EAAQ,IAAsB,IAAVA,CACrC,CACD,SAASu0C,EAAOK,GACd,GAAsB,IAAlBA,EAAOv8C,OACT,OAAOu8C,EAAO,GAChB,IAAIC,EAAkB,EACtB,IAAA,IAAS/8C,EAAI,EAAGA,EAAI88C,EAAOv8C,OAAQP,IAAK,CAEtC+8C,GADcD,EAAO98C,GACIsqB,UAC1B,CACK,MAAAQ,EAAS,IAAIlqB,WAAWm8C,GAC9B,IAAI1yB,EAAa,EACjB,IAAA,IAASrqB,EAAI,EAAGA,EAAI88C,EAAOv8C,OAAQP,IAAK,CAChC,MAAAoK,EAAQ0yC,EAAO98C,GACd8qB,EAAA5mB,IAAIkG,EAAOigB,GAClBA,GAAcjgB,EAAMkgB,UACrB,CACM,OAAAQ,CACR,CACL,IACS2sB,CACJ,EA9YqC,GA+YpCL,GAA2C,IAAA4F,IAAI,CAACnE,GAAYoE,GAAUC,KACtEzG,GAAa,CACjB,IAAiCoC,GACjC,GAAiCA,GACjC,GAA4BA,GAC5B,GAA2BA,GAC3B,IAA2BoE,GAC3B,GAA2BA,GAC3B,GAAwBA,GACxB,GAAuBA,GACvB,IAAwBC,GACxB,GAAwBA,GACxB,GAAqBA,GACrB,EAAsBA,GACtB,IAAiCC,GACjC,IAAkCA,IAE9BlG,GAAW,CACf,IAAiCC,GACjC,GAAiCC,GACjC,GAA4BlE,GAC5B,GAA2BA,GAC3B,IAA2BiE,GAC3B,GAA2BC,GAC3B,GAAwBlE,GACxB,GAAuBA,GACvB,IAAwBiE,GACxB,GAAwBC,GACxB,GAAqBlE,GACrB,EAAsBA,GACtB,IAAiCA,GACjC,IAAkCA,IA0EpC,SAASC,GAAgBJ,GACjB,MAAAuB,EAAMvB,EAAU3H,qBAAqB,GACvC,OAAAkJ,EAAI5I,iBAAmBlB,GAClB8J,EAAI3I,mBAAqBrB,GAAuBzvB,GAAiBC,GAC/Dw5B,EAAI5I,iBAAmBjB,GACzB6J,EAAI3I,mBAAqBrB,GAAuB2F,GAAsBC,IACpEoE,EAAI5I,iBAAmBnB,IAGhChrC,QAAQC,KAAK,mDAAmD80C,EAAI5I,mBAF7DsE,GAKX,CC1hBA,MAAMqN,WAAmBC,GACvB,WAAAt2C,CAAYiU,GACV3S,MAAM2S,GACNrS,KAAK9D,KAAOsyC,EACb,CAED,KAAAp5B,CAAMkM,GACE,MAAyFqzB,EAAa,SAASC,EAAiB3T,GACpI,OAAQ2T,GACN,KAFoB,EAGlB,MAAM,IAAIp/B,MAAM,kCAAoCyrB,GAAO,KAC7D,KAJ0C,EAKxC,MAAM,IAAIzrB,MAAM,mCAAqCyrB,GAAO,KAC9D,KANiE,EAO/D,MAAM,IAAIzrB,MAAM,uCAAyCyrB,GAAO,KAClE,QAEE,MAAM,IAAIzrB,MAAM,oCAAsCyrB,GAAO,KAElE,EAAgG4T,EAAQ,SAASC,EAASC,EAAWC,GAExHD,EAACA,GAAY,KACrB,IAAAt6C,EAAIq6C,EAAQp5C,IAAKrE,KAAQgtC,EAAM,EAAG7qC,EAAI,GAAIy7C,EAAQpjC,OAAOC,aAAaojC,MAAM,KAAM,IAAI/8C,YAAY28C,EAAQ14C,SAAS3B,EAAGA,EAFxG,OAGX,KAAA,GAAKpD,EAAI49C,EAAMh0C,QAJmE,QAI9CojC,EAAM0Q,GAAat6C,EAAIq6C,EAAQnzB,YACnEnoB,GAAAy7C,EACL5Q,GAAO4Q,EAAMr9C,OACR6C,GANW,IAOhBw6C,GAASpjC,OAAOC,aAAaojC,MAAM,KAAM,IAAI/8C,YAAY28C,EAAQ14C,SAAS3B,EAAGA,EAP7D,OASlB,SAASpD,KACH,IAAU29C,IACJF,EAAAp5C,KAAO2oC,EAAMhtC,EAAI,GACpBmC,EAAIy7C,EAAMvzC,MAAM,EAAGrK,GAGlC,EA4HU89C,EAAqB,SAASC,EAAaC,EAAcC,EAAWC,GAClE,MAAAh4C,EAAI63C,EAAYC,EAAe,GAC/B5tC,EAAQnM,KAAK4D,IAAI,EAAG3B,EAAI,KAAO,IACrC+3C,EAAUC,EAAa,GAAKH,EAAYC,EAAe,GAAK5tC,EAC5D6tC,EAAUC,EAAa,GAAKH,EAAYC,EAAe,GAAK5tC,EAC5D6tC,EAAUC,EAAa,GAAKH,EAAYC,EAAe,GAAK5tC,EAClD6tC,EAAAC,EAAa,GAAK,CAClC,EACUC,EAAoB,SAASJ,EAAaC,EAAcC,EAAWC,GACjE,MAAAh4C,EAAI63C,EAAYC,EAAe,GAC/B5tC,EAAQnM,KAAK4D,IAAI,EAAG3B,EAAI,KAAO,IACrC+3C,EAAUC,EAAa,GAAKE,GAAUC,YAAYp6C,KAAKsL,IAAIwuC,EAAYC,EAAe,GAAK5tC,EAAO,QAClG6tC,EAAUC,EAAa,GAAKE,GAAUC,YAAYp6C,KAAKsL,IAAIwuC,EAAYC,EAAe,GAAK5tC,EAAO,QAClG6tC,EAAUC,EAAa,GAAKE,GAAUC,YAAYp6C,KAAKsL,IAAIwuC,EAAYC,EAAe,GAAK5tC,EAAO,QAClG6tC,EAAUC,EAAa,GAAKE,GAAUC,YAAY,EACxD,EACUC,EAAY,IAAI19C,WAAWqpB,GACjCq0B,EAAUj6C,IAAM,EACV,MAAAk6C,EA9Ie,SAASd,GACtB,MAA8Be,EAAW,oCAAqCC,EAAc,uCAAwCC,EAAY,uBAAwBC,EAAgB,oCAAqC/wB,EAAS,CAC1OgxB,MAAO,EACPC,OAAQ,GACRC,SAAU,GACVC,YAAa,OACbxP,OAAQ,GACRyP,MAAO,EACPC,SAAU,EACVz3C,MAAO,EACPW,OAAQ,GAEV,IAAI+2C,EAAMznB,EAUV,KATIgmB,EAAQp5C,KAAOo5C,EAAQnzB,cAAgB40B,EAAO1B,EAAMC,MACtDH,EA1CoB,EA0CQ,oBAExB7lB,EAAQynB,EAAKznB,MAfI,eAgBrB6lB,EA7CiE,EA6CnC,qBAEhC1vB,EAAOgxB,OAnCmB,EAoCnBhxB,EAAAmxB,YAActnB,EAAM,GAC3B7J,EAAOixB,QAAUK,EAAO,KAEtBA,EAAO1B,EAAMC,IACT,IAAUyB,GAGd,GADAtxB,EAAOixB,QAAUK,EAAO,KACpB,MAAQA,EAAKC,OAAO,IAmBxB,IAfI1nB,EAAQynB,EAAKznB,MAAM+mB,MACrB5wB,EAAOoxB,MAAQI,WAAW3nB,EAAM,MAE9BA,EAAQynB,EAAKznB,MAAMgnB,MACrB7wB,EAAOqxB,SAAWG,WAAW3nB,EAAM,MAEjCA,EAAQynB,EAAKznB,MAAMinB,MACrB9wB,EAAOgxB,OAtDsC,EAuDtChxB,EAAA2hB,OAAS9X,EAAM,KAEpBA,EAAQynB,EAAKznB,MAAMknB,MACrB/wB,EAAOgxB,OA1DiE,EA2DxEhxB,EAAOzlB,OAASpJ,SAAS04B,EAAM,GAAI,IACnC7J,EAAOpmB,MAAQzI,SAAS04B,EAAM,GAAI,KA5DW,EA8D3C7J,EAAOgxB,OA9D+D,EA8DlChxB,EAAOgxB,MAC7C,WAnBAhxB,EAAOkxB,UAAYI,EAAO,KA2BvB,OAvE0C,EAiE3CtxB,EAAOgxB,OACXtB,EA9EiE,EA8EnC,4BAlE4C,EAoEtE1vB,EAAOgxB,OACXtB,EAjFiE,EAiFnC,gCAEzB1vB,CACR,CAsFwByxB,CAAgBf,GACnC1nC,EAAI2nC,EAAiB/2C,MAAOqP,EAAI0nC,EAAiBp2C,OAAQm3C,EAvFtC,SAAS7B,EAAS8B,EAAIC,GAC7C,MAAMC,EAAiBF,EACvB,GAEEE,EAAiB,GAAKA,EAAiB,OACvC,IAAMhC,EAAQ,IAAM,IAAMA,EAAQ,IAAmB,IAAbA,EAAQ,GAEzC,OAAA,IAAI78C,WAAW68C,GAEpBgC,KAAoBhC,EAAQ,IAAM,EAAIA,EAAQ,KAChDH,EA9FiE,EA8FnC,wBAEhC,MAAMoC,EAAY,IAAI9+C,WAAW,EAAI2+C,EAAKC,GACrCE,EAAUn/C,QACb+8C,EAlGwF,EAkG1D,mCAE5B,IAAAvyC,EAAS,EAAG1G,EAAM,EACtB,MAAMs7C,EAAU,EAAIF,EACdG,EAAY,IAAIh/C,WAAW,GAC3Bi/C,EAAkB,IAAIj/C,WAAW++C,GACvC,IAAIG,EAAgBN,EACpB,KAAOM,EAAgB,GAAKz7C,EAAMo5C,EAAQnzB,YAAY,CAChDjmB,EAAM,EAAIo5C,EAAQnzB,YACpBgzB,EA3GkB,GA6GVsC,EAAA,GAAKnC,EAAQp5C,KACbu7C,EAAA,GAAKnC,EAAQp5C,KACbu7C,EAAA,GAAKnC,EAAQp5C,KACbu7C,EAAA,GAAKnC,EAAQp5C,KACnB,GAAKu7C,EAAU,IAAM,GAAKA,EAAU,KAAOA,EAAU,IAAM,EAAIA,EAAU,KAAOH,GAClFnC,EAlH+D,EAkHjC,4BAEhC,IAAar9C,EAAT8/C,EAAM,EACV,KAAOA,EAAMJ,GAAWt7C,EAAMo5C,EAAQnzB,YAAY,CAChDrqB,EAAQw9C,EAAQp5C,KAChB,MAAM27C,EAAe//C,EAAQ,IAM7B,GALI+/C,IACO//C,GAAA,MACP,IAAMA,GAAS8/C,EAAM9/C,EAAQ0/C,IAC/BrC,EA3H6D,EA2H/B,qBAE5B0C,EAAc,CACV,MAAAC,EAAYxC,EAAQp5C,KAC1B,IAAA,IAASrE,EAAI,EAAGA,EAAIC,EAAOD,IACzB6/C,EAAgBE,KAASE,CAEvC,MACYJ,EAAgB37C,IAAIu5C,EAAQ14C,SAASV,EAAKA,EAAMpE,GAAQ8/C,GACjDA,GAAA9/C,EACAoE,GAAApE,CAEV,CACD,MAAMmC,EAAIq9C,EACV,IAAA,IAASz/C,EAAI,EAAGA,EAAIoC,EAAGpC,IAAK,CAC1B,IAAIkgD,EAAM,EACVR,EAAU30C,GAAU80C,EAAgB7/C,EAAIkgD,GACjCA,GAAAT,EACPC,EAAU30C,EAAS,GAAK80C,EAAgB7/C,EAAIkgD,GACrCA,GAAAT,EACPC,EAAU30C,EAAS,GAAK80C,EAAgB7/C,EAAIkgD,GACrCA,GAAAT,EACPC,EAAU30C,EAAS,GAAK80C,EAAgB7/C,EAAIkgD,GAClCn1C,GAAA,CACX,CACD+0C,GACD,CACM,OAAAJ,CACb,CAoBqFS,CAAoB7B,EAAUv5C,SAASu5C,EAAUj6C,KAAMuS,EAAGC,GAC3I,IAAIvQ,EAAMzB,EACNu7C,EACJ,OAAQz3C,KAAK9D,MACX,KAAKqyC,GACHkJ,EAAcd,EAAgB/+C,OAAS,EACvC,MAAM8/C,EAAa,IAAI1tB,aAA2B,EAAdytB,GACpC,IAAA,IAAS3+C,EAAI,EAAGA,EAAI2+C,EAAa3+C,IAC/Bq8C,EAAmBwB,EAAqB,EAAJ79C,EAAO4+C,EAAgB,EAAJ5+C,GAElD6E,EAAA+5C,EACAx7C,EAAAqyC,GACP,MACF,KAAKC,GACHiJ,EAAcd,EAAgB/+C,OAAS,EACvC,MAAM+/C,EAAY,IAAIx/C,YAA0B,EAAds/C,GAClC,IAAA,IAAS3+C,EAAI,EAAGA,EAAI2+C,EAAa3+C,IAC/B08C,EAAkBmB,EAAqB,EAAJ79C,EAAO6+C,EAAe,EAAJ7+C,GAEhD6E,EAAAg6C,EACAz7C,EAAAsyC,GACP,MACF,QACE,MAAM,IAAIh5B,MAAM,uCAAyCxV,KAAK9D,MAE3D,MAAA,CACL2C,MAAOoP,EACPzO,OAAQ0O,EACRvQ,OACAsnB,OAAQ2wB,EAAiBM,OACzBG,MAAOT,EAAiBS,MACxBC,SAAUV,EAAiBU,SAC3Bp6C,OAEH,CACD,WAAA07C,CAAYr4C,GAEH,OADPS,KAAK9D,KAAOqD,EACLS,IACR,CACD,IAAA6T,CAAKC,EAAKC,EAAQC,EAAYC,GAkB5B,OAAOvU,MAAMmU,KAAKC,GAjBT,SAAezV,EAASw5C,GAC/B,OAAQx5C,EAAQnC,MACd,KAAKqyC,GACL,KAAKC,GACC,eAAgBnwC,EAClBA,EAAQ+2B,WAAa,cAErB/2B,EAAQi3B,SAAW,IACrBj3B,EAAQ21B,UAAY7J,EACpB9rB,EAAQ01B,UAAY5J,EACpB9rB,EAAQ8hC,iBAAkB,EAC1B9hC,EAAQu1B,OAAQ,EAGhB7f,GACFA,EAAO1V,EAASw5C,EACnB,GACsC7jC,EAAYC,EACpD,EC1OH,MAAM6jC,GAAgB3hD,IAAW,IACjC,MAAM4hD,WAAkBrD,GACtB,WAAAt2C,CAAYiU,GACV3S,MAAM2S,GACNrS,KAAK9D,KAAOsyC,EACb,CACD,KAAAp5B,CAAMkM,GACJ,MAAM02B,EAAe,MAGfC,EAAc,GACdC,EAAA,MACAC,EAAc,MAkBdC,EAAU98C,KAAK4D,IAAI,UAAW,KAqBpC,MAAMm5C,EAAgB,CAAE5+C,EAAG,EAAGoD,EAAG,EAAGy7C,GAAI,GACxC,SAASC,EAAQC,EAAO37C,EAAGy7C,EAAIG,EAAaC,GAC1C,KAAOJ,EAAKE,GACV37C,EAAIA,GAAK,EAAI87C,EAAgBF,EAAaC,GACpCJ,GAAA,EAEFA,GAAAE,EACNH,EAAc5+C,EAAIoD,GAAKy7C,GAAM,GAAKE,GAAS,EAC3CH,EAAcx7C,EAAIA,EAClBw7C,EAAcC,GAAKA,CACpB,CACK,MAAAM,EAAiB,IAAIz8B,MAAM,IAkBjC,SAAS08B,EAAkBJ,EAAaK,EAAYJ,EAAUK,EAAIC,EAAIC,EAAIC,GAIjE,IAHP,IAAIz+C,EAAIi+C,EACJ77C,EAAI,EACJy7C,EAAK,EACFU,GAAMC,EAAID,IAAM,CACjB,GAAAv+C,EAAE8E,MAAQm5C,EAASn5C,MAAQw5C,EACtB,OAAA,EACTR,EAAQ,EAAG17C,EAAGy7C,EAAIG,EAAah+C,GAC/B,IAAIhB,EAAI4+C,EAAc5+C,EAItB,GAHAoD,EAAIw7C,EAAcx7C,EAClBy7C,EAAKD,EAAcC,GACnBY,EAAMF,GAAMv/C,EAzEU,IA0ElBA,EAAwB,CAC1B,GAAIgB,EAAE8E,MAAQm5C,EAASn5C,MAAQw5C,EACvB,KAAA,yCAERR,EAAQ,EAAG17C,EAAGy7C,EAAIG,EAAah+C,GAC3B,IAAA0+C,EAAQd,EAAc5+C,EA9EN,EAiFhB,GAFJoD,EAAIw7C,EAAcx7C,EAClBy7C,EAAKD,EAAcC,GACfU,EAAKG,EAAQF,EAAK,EACd,KAAA,yCAED,KAAAE,KACLD,EAAMF,KAAQ,EAChBA,GACV,MAAA,GAAmBv/C,GAzFY,GAyFa,CAE9B,GAAAu/C,GADAG,EAAQ1/C,EA1FS,GA0FgB,GACpBw/C,EAAK,EACd,KAAA,yCAED,KAAAE,KACLD,EAAMF,KAAQ,EAChBA,GACD,CACF,EApDH,SAA+BE,GAC7B,IAAA,IAAS7hD,EAAI,EAAGA,GAAK,KAAMA,EACzBuhD,EAAevhD,GAAK,EACtB,IAASA,EAAI,EAAGA,EAAI6gD,IAAe7gD,EAClBuhD,EAAAM,EAAM7hD,KAAO,EAC9B,IAAIwF,EAAI,EACR,IAASxF,EAAI,GAAIA,EAAI,IAAKA,EAAG,CAC3B,IAAI+hD,EAAKv8C,EAAI+7C,EAAevhD,IAAM,EAClCuhD,EAAevhD,GAAKwF,EAChBA,EAAAu8C,CACL,CACD,IAAS/hD,EAAI,EAAGA,EAAI6gD,IAAe7gD,EAAG,CAChC,IAAAoC,EAAIy/C,EAAM7hD,GACVoC,EAAI,IACNy/C,EAAM7hD,GAAKoC,EAAIm/C,EAAen/C,MAAQ,EACzC,CACF,CAqCC4/C,CAAsBH,EACvB,CACD,SAASI,EAAUjoC,GACjB,OAAc,GAAPA,CACR,CACD,SAASkoC,EAAQloC,GACf,OAAOA,GAAQ,CAChB,CAuCD,MAAMmoC,EAAgB,CAAE38C,EAAG,EAAGy7C,GAAI,GAClC,SAASmB,EAAQ58C,EAAGy7C,EAAIG,EAAaC,GACnC77C,EAAIA,GAAK,EAAI87C,EAAgBF,EAAaC,GACpCJ,GAAA,EACNkB,EAAc38C,EAAIA,EAClB28C,EAAclB,GAAKA,CACpB,CACD,MAAMoB,EAAgB,CAAE78C,EAAG,EAAGy7C,GAAI,GACzB,SAAAqB,EAAQC,EAAIC,EAAKh9C,EAAGy7C,EAAIG,EAAaK,EAAYJ,EAAUoB,EAAWC,EAAiBC,GAC9F,GAAIJ,GAAMC,EAAK,CACTvB,EAAK,IACCmB,EAAA58C,EAAGy7C,EAAIG,EAAaC,GAC5B77C,EAAI28C,EAAc38C,EAClBy7C,EAAKkB,EAAclB,IAGrB,IAAI2B,EAAKp9C,IADHy7C,GAAA,GAEF2B,EAAK,IAAIhiD,WAAW,CAACgiD,IAAK,GAC1B,GAAAF,EAAgBx6C,MAAQ06C,EAAKD,EACxB,OAAA,EAGT,IADA,IAAIxgD,EAAIsgD,EAAUC,EAAgBx6C,MAAQ,GACnC06C,KAAO,GACFH,EAAAC,EAAgBx6C,SAAW/F,CAE/C,KAAA,MAAiBugD,EAAgBx6C,MAAQy6C,GAG1B,OAAA,EAFGF,EAAAC,EAAgBx6C,SAAWq6C,CAGtC,CACDF,EAAc78C,EAAIA,EAClB68C,EAAcpB,GAAKA,CACpB,CACD,SAAS4B,EAAO36C,GACd,OAAe,MAARA,CACR,CACD,SAAS46C,EAAM56C,GACT,IAAAixB,EAAM0pB,EAAO36C,GACV,OAAAixB,EAAM,MAAQA,EAAM,MAAQA,CACpC,CACD,MAAM4pB,EAAe,CAAE9/C,EAAG,EAAG1B,EAAG,GACvB,SAAAyhD,EAAO5gD,EAAGyU,GACb,IAAAosC,EAAKH,EAAM1gD,GACX8gD,EAAKJ,EAAMjsC,GAEXssC,EAAKF,GAAW,EADXC,OACuB,GAC5BE,EAAKD,EACLE,EAAKF,EAHAD,EAITH,EAAa9/C,EAAImgD,EACjBL,EAAaxhD,EAAI8hD,CAClB,CACQ,SAAAC,EAAOlhD,EAAGyU,GACb,IAAAlU,EAAIkgD,EAAOzgD,GACXe,EAAI0/C,EAAOhsC,GACX0sC,EAAK5gD,GAAKQ,GAAK,GAxMf,MAyMAqgD,EAAKrgD,EAAIogD,EA1ME,MACX,MA0MJR,EAAa9/C,EAAIugD,EACjBT,EAAaxhD,EAAIgiD,CAClB,CACD,SAASE,EAAWhG,EAASh8C,EAAGiiD,EAAIC,EAAIC,EAAIC,EAAIC,GAK9C,IAJI,IAGAC,EAHAC,EAAMF,EAAK,MACXn/C,EAAI++C,EAAKE,EAAKA,EAAKF,EACnBtgD,EAAI,EAEDA,GAAKuB,GACJvB,IAAA,EAIR,IAFK2gD,EADC3gD,IAAA,EAEAA,IAAA,EACCA,GAAK,GAAG,CAQN,IAPP,IAMI6gD,EAAKC,EAAKC,EAAKC,EANfC,EAAK,EACLC,EAAKD,EAAKR,GAAMD,EAAKG,GACrBQ,EAAMV,EAAKzgD,EACXohD,EAAMX,EAAKE,EACXU,EAAMd,EAAKvgD,EACXshD,EAAMf,EAAKI,EAERM,GAAMC,EAAID,GAAMG,EAAK,CAGnB,IAFP,IAAIG,EAAKN,EACLO,EAAKP,EAAKV,GAAMD,EAAKK,GAClBY,GAAMC,EAAID,GAAMD,EAAK,CAC1B,IAAIG,EAAMF,EAAKF,EAEXK,GADAC,EAAMJ,EAAKJ,GACCE,EACZT,GACFhB,EAAOvF,EAAQkH,EAAKljD,GAAIg8C,EAAQsH,EAAMtjD,IACtCwiD,EAAMlB,EAAa9/C,EACnBkhD,EAAMpB,EAAaxhD,EACnByhD,EAAOvF,EAAQoH,EAAMpjD,GAAIg8C,EAAQqH,EAAMrjD,IACvCyiD,EAAMnB,EAAa9/C,EACnBmhD,EAAMrB,EAAaxhD,EACnByhD,EAAOiB,EAAKC,GACJzG,EAAAkH,EAAKljD,GAAKshD,EAAa9/C,EACvBw6C,EAAAoH,EAAMpjD,GAAKshD,EAAaxhD,EAChCyhD,EAAOmB,EAAKC,GACJ3G,EAAAsH,EAAMtjD,GAAKshD,EAAa9/C,EACxBw6C,EAAAqH,EAAMrjD,GAAKshD,EAAaxhD,IAEhC+hD,EAAO7F,EAAQkH,EAAKljD,GAAIg8C,EAAQsH,EAAMtjD,IACtCwiD,EAAMlB,EAAa9/C,EACnBkhD,EAAMpB,EAAaxhD,EACnB+hD,EAAO7F,EAAQoH,EAAMpjD,GAAIg8C,EAAQqH,EAAMrjD,IACvCyiD,EAAMnB,EAAa9/C,EACnBmhD,EAAMrB,EAAaxhD,EACnB+hD,EAAOW,EAAKC,GACJzG,EAAAkH,EAAKljD,GAAKshD,EAAa9/C,EACvBw6C,EAAAoH,EAAMpjD,GAAKshD,EAAaxhD,EAChC+hD,EAAOa,EAAKC,GACJ3G,EAAAsH,EAAMtjD,GAAKshD,EAAa9/C,EACxBw6C,EAAAqH,EAAMrjD,GAAKshD,EAAaxhD,EAEnC,CACD,GAAImiD,EAAKtgD,EAAG,CACV,IAAI2hD,EAAMJ,EAAKJ,EACXP,EACFhB,EAAOvF,EAAQkH,EAAKljD,GAAIg8C,EAAQsH,EAAMtjD,IAEtC6hD,EAAO7F,EAAQkH,EAAKljD,GAAIg8C,EAAQsH,EAAMtjD,IACxCwiD,EAAMlB,EAAa9/C,EACXw6C,EAAAsH,EAAMtjD,GAAKshD,EAAaxhD,EACxBk8C,EAAAkH,EAAKljD,GAAKwiD,CACnB,CACF,CACD,GAAIL,EAAKxgD,EAGA,IAFHuhD,EAAKN,EACLO,EAAKP,EAAKV,GAAMD,EAAKK,GAClBY,GAAMC,EAAID,GAAMD,EAAK,CACtBG,EAAMF,EAAKF,EACXT,EACFhB,EAAOvF,EAAQkH,EAAKljD,GAAIg8C,EAAQoH,EAAMpjD,IAEtC6hD,EAAO7F,EAAQkH,EAAKljD,GAAIg8C,EAAQoH,EAAMpjD,IACxCwiD,EAAMlB,EAAa9/C,EACXw6C,EAAAoH,EAAMpjD,GAAKshD,EAAaxhD,EACxBk8C,EAAAkH,EAAKljD,GAAKwiD,CACnB,CAEEF,EAAA3gD,EACCA,IAAA,CACP,CACM,OAAAihD,CACR,CAyED,SAASW,EAAc5D,EAAaK,EAAYJ,EAAU4D,EAAaxC,EAAWyC,GAC5E,IACAC,EAAkB9D,EAASn5C,MAC3By5C,EAAKyD,EAAY3D,EAAYJ,GAC7BO,EAAKwD,EAAY3D,EAAYJ,GACjCA,EAASn5C,OAAS,EACd,IAAAi5C,EAAQiE,EAAY3D,EAAYJ,GAEpC,GADAA,EAASn5C,OAAS,EACdy5C,EAAK,GAAKA,GAAMd,GAAee,EAAK,GAAKA,GAAMf,EAC3C,KAAA,mCAEJ,IAAAwE,EAAO,IAAIvgC,MAAM+7B,GACjByE,EAAO,IAAIxgC,MAAMg8B,GAIrB,GA7VF,SAA0BwE,GACxB,IAAA,IAAStlD,EAAI,EAAGA,EAAI8gD,EAAa9gD,IAC1BslD,EAAAtlD,GAAK,GACLslD,EAAAtlD,GAAGgtC,IAAM,EACTsY,EAAAtlD,GAAGulD,IAAM,EACTD,EAAAtlD,GAAGoD,EAAI,IAEf,CAmVCoiD,CAAiBF,GAEjB9D,EAAkBJ,EAAaK,EAAYJ,EADlC4D,GAAe5D,EAASn5C,MAAQi9C,GACgBxD,EAAIC,EAAIyD,GAC7DlE,EAAQ,GAAK8D,GAAe5D,EAASn5C,MAAQi9C,IACzC,KAAA,sCA7QV,SAA0BtD,EAAOF,EAAIC,EAAI6D,GAChC,KAAA9D,GAAMC,EAAID,IAAM,CACrB,IAAIn8C,EAAI08C,EAAQL,EAAMF,IAClBv/C,EAAI6/C,EAAUJ,EAAMF,IACxB,GAAIn8C,GAAKpD,EACD,KAAA,sBAER,GAAIA,EAAIw+C,EAAa,CAEnB,IADI8E,EAAKD,EAAOjgD,GAAKpD,EAAIw+C,IAClB5T,IACC,KAAA,sBAGR,GADG0Y,EAAAH,MACCG,EAAGtiD,EAAG,CACR,IAAIA,EAAIsiD,EAAGtiD,EACXsiD,EAAGtiD,EAAI,IAAI0hB,MAAM4gC,EAAGH,KACpB,IAAA,IAASvlD,EAAI,EAAGA,EAAI0lD,EAAGH,IAAM,IAAKvlD,EAChC0lD,EAAGtiD,EAAEpD,GAAKoD,EAAEpD,EAE1B,MACe0lD,EAAAtiD,EAAI,IAAI0hB,MAAM,GAEnB4gC,EAAGtiD,EAAEsiD,EAAGH,IAAM,GAAK5D,CACpB,SAAUv/C,EACT,KAAIujD,EAAW,EACf,IAAS3lD,EAAI,GAAK4gD,EAAcx+C,EAAGpC,EAAI,EAAGA,IAAK,CAC7C,IAAI0lD,EACA,IADAA,EAAKD,GAAQjgD,GAAKo7C,EAAcx+C,GAAKujD,IAClC3Y,KAAO0Y,EAAGtiD,EACT,KAAA,sBAERsiD,EAAG1Y,IAAM5qC,EACTsjD,EAAGH,IAAM5D,EACTgE,GACD,CATc,CAWlB,CAEF,CA0OkBC,CAAAP,EAAM1D,EAAIC,EAAI0D,GA3FxB,SAAUO,EAAeC,EAAe1E,EAAaK,EAAYJ,EAAUK,EAAIc,EAAKuD,EAAItD,EAAWuD,GAKnG,IAJP,IAAIxgD,EAAI,EACJy7C,EAAK,EACL0B,EAAqBoD,EACrBE,EAAchiD,KAAKiiD,MAAM7E,EAASn5C,OAASw5C,EAAK,GAAK,GAClDL,EAASn5C,MAAQ+9C,GAItB,IAHQ7D,EAAA58C,EAAGy7C,EAAIG,EAAaC,GAC5B77C,EAAI28C,EAAc38C,EAClBy7C,EAAKkB,EAAclB,GACZA,GAAML,GAGX,IADI8E,EAAKI,EADGtgD,GAAKy7C,EAAKL,EA7SRE,QA+SP9T,IACLiU,GAAMyE,EAAG1Y,IACDsV,EAAAoD,EAAGH,IAAK/C,EAAKh9C,EAAGy7C,EAAIG,EAAaK,EAAYJ,EAAUoB,EAAWuD,EAAWrD,GACrFn9C,EAAI68C,EAAc78C,EAClBy7C,EAAKoB,EAAcpB,OACd,CACD,IAACyE,EAAGtiD,EACA,KAAA,mBAEJ,IAAA3B,EACJ,IAAKA,EAAI,EAAGA,EAAIikD,EAAGH,IAAK9jD,IAAK,CAE3B,IADA,IAAIW,EAAI6/C,EAAU4D,EAAcH,EAAGtiD,EAAE3B,KAC9Bw/C,EAAK7+C,GAAKi/C,EAASn5C,MAAQ+9C,GACxB7D,EAAA58C,EAAGy7C,EAAIG,EAAaC,GAC5B77C,EAAI28C,EAAc38C,EAClBy7C,EAAKkB,EAAclB,GAErB,GAAIA,GAAM7+C,GACJ8/C,EAAQ2D,EAAcH,EAAGtiD,EAAE3B,OAAS+D,GAAKy7C,EAAK7+C,GAAK,GAAKA,GAAK,GAAI,CAC7D6+C,GAAA7+C,EACNkgD,EACEoD,EAAGtiD,EAAE3B,GACL+gD,EACAh9C,EACAy7C,EACAG,EACAK,EACAJ,EACAoB,EACAuD,EACArD,GAEFn9C,EAAI68C,EAAc78C,EAClBy7C,EAAKoB,EAAcpB,GACnB,KACD,CAEJ,CACG,GAAAx/C,GAAKikD,EAAGH,IACJ,KAAA,kBAET,CAGD,IAAAvlD,EAAI,EAAI0hD,EAAK,EAGjB,IAFMl8C,IAAAxF,EACAihD,GAAAjhD,EACCihD,EAAK,GAAG,CACb,IAAIyE,EACJ,KADIA,EAAKI,EAActgD,GAAKo7C,EAAcK,EA/V1BH,QAgWT9T,IAMC,KAAA,mBALNiU,GAAMyE,EAAG1Y,IACDsV,EAAAoD,EAAGH,IAAK/C,EAAKh9C,EAAGy7C,EAAIG,EAAaK,EAAYJ,EAAUoB,EAAWuD,EAAWrD,GACrFn9C,EAAI68C,EAAc78C,EAClBy7C,EAAKoB,EAAcpB,EAItB,CAEF,CAqBWkF,CAAAd,EAAMC,EAAMlE,EAAaK,EAAYJ,EAAUF,EAAOS,EAAIsD,EAAMzC,EAnB1D,CAAEv6C,MAAO,GAoB1B,CAMD,SAASk+C,EAAUn9B,GACjB,IAAA,IAASnkB,EAAI,EAAGA,EAAImkB,EAAO1oB,OAAQuE,IAAK,CACtC,IAAI3B,EAAI8lB,EAAOnkB,EAAI,GAAKmkB,EAAOnkB,GAAK,IACpCmkB,EAAOnkB,GAAK3B,CACb,CACF,CACQ,SAAAkjD,EAAiBp9B,EAAQ1iB,GAKhC,IAJA,IAAIiqB,EAAK,EACL81B,EAAKriD,KAAKyD,OAAOuhB,EAAO1oB,OAAS,GAAK,GACtC4B,EAAI,EACJokD,EAAOt9B,EAAO1oB,OAAS,IAErB4B,EAAIokD,IAEJhgD,EAAApE,KAAO8mB,EAAOuH,KACdruB,EAAIokD,KAEJhgD,EAAApE,KAAO8mB,EAAOq9B,IAErB,CACD,SAASE,EAAgBv9B,GAKvB,IAJA,IAAIw9B,EAAOx9B,EAAOqB,WACd/jB,EAAM,IAAIue,MACV1hB,EAAI,EACJsjD,EAAS,IAAI/4B,SAAS1E,GACnBw9B,EAAO,GAAG,CACX,IAAArkD,EAAIskD,EAAOC,QAAQvjD,KACvB,GAAIhB,EAAI,EAAG,CAETqkD,IADIxmD,GAASmC,GACG,EAChB,IAAA,IAASpC,EAAI,EAAGA,EAAIC,EAAOD,IACzBuG,EAAIrG,KAAKwmD,EAAOna,SAASnpC,KAErC,KAAe,CACL,IAAInD,EAAQmC,EACJqkD,GAAA,EACJ,IAAAv+C,EAAQw+C,EAAOna,SAASnpC,KAC5B,IAASpD,EAAI,EAAGA,EAAIC,EAAQ,EAAGD,IAC7BuG,EAAIrG,KAAKgI,EAEZ,CACF,CACM,OAAA3B,CACR,CA6FQ,SAAAqgD,EAAQC,EAAYC,EAAUC,GAGrC,IAFI,IAAAC,EACAC,EAAU,EACPA,EAAU,IAEA,QADLD,EAAAF,EAASD,EAAW3+C,QAElB++C,EAAA,GACDD,GAAW,GAAK,IACzBC,GAAqB,IAAVD,GAEXD,EAAaE,GAAWD,EACxBC,KAESJ,EAAA3+C,OAEd,CACQ,SAAAg/C,EAASx9B,EAAK2yB,GACrBA,EAAI,GAAK8K,EAAcz9B,EAAI,IAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,IAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,IAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,IAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,KAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,KAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,KAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,KAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,IAC3B2yB,EAAI,GAAK8K,EAAcz9B,EAAI,IAC3B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,IAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,IAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,IAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,IAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,KAC5B2yB,EAAI,IAAM8K,EAAcz9B,EAAI,IAC7B,CACD,SAAS09B,EAAW9gD,GAClB,MAAMrD,EAAI,GAAMgB,KAAK2G,IAAI,UACnBrJ,EAAI,GAAM0C,KAAK2G,IAAI,QAAU,IAC7BpF,EAAI,GAAMvB,KAAK2G,IAAI,QAAU,GAC7BzH,EAAI,GAAMc,KAAK2G,IAAI,EAAI,QAAU,IACjC1E,EAAI,GAAMjC,KAAK2G,IAAI,YACnBxG,EAAI,GAAMH,KAAK2G,IAAI,EAAI,QAAU,GACjCy8C,EAAI,GAAMpjD,KAAK2G,IAAI,aAKzB,IAJI,IAAA08C,EAAQ,IAAIxiC,MAAM,GAClByiC,EAAO,IAAIziC,MAAM,GACjBlY,EAAQ,IAAIkY,MAAM,GAClBk6B,EAAQ,IAAIl6B,MAAM,GACb0iC,EAAM,EAAGA,EAAM,IAAKA,EAAK,CAChC,IAAIC,EAAe,EAAND,EACbF,EAAM,GAAK9hD,EAAIc,EAAKmhD,EAAS,GAC7BH,EAAM,GAAKljD,EAAIkC,EAAKmhD,EAAS,GAC7BH,EAAM,GAAK9hD,EAAIc,EAAKmhD,EAAS,GAC7BH,EAAM,GAAKljD,EAAIkC,EAAKmhD,EAAS,GACxBF,EAAA,GAAKhmD,EAAI+E,EAAKmhD,EAAS,GAAKtkD,EAAImD,EAAKmhD,EAAS,GAAKvhD,EAAII,EAAKmhD,EAAS,GAAKJ,EAAI/gD,EAAKmhD,EAAS,GAC5FF,EAAA,GAAKpkD,EAAImD,EAAKmhD,EAAS,GAAKJ,EAAI/gD,EAAKmhD,EAAS,GAAKlmD,EAAI+E,EAAKmhD,EAAS,GAAKvhD,EAAII,EAAKmhD,EAAS,GAC5FF,EAAA,GAAKrhD,EAAII,EAAKmhD,EAAS,GAAKlmD,EAAI+E,EAAKmhD,EAAS,GAAKJ,EAAI/gD,EAAKmhD,EAAS,GAAKtkD,EAAImD,EAAKmhD,EAAS,GAC5FF,EAAA,GAAKF,EAAI/gD,EAAKmhD,EAAS,GAAKvhD,EAAII,EAAKmhD,EAAS,GAAKtkD,EAAImD,EAAKmhD,EAAS,GAAKlmD,EAAI+E,EAAKmhD,EAAS,GAC3F76C,EAAA,GAAK3J,GAAKqD,EAAKmhD,EAAS,GAAKnhD,EAAKmhD,EAAS,IAC3C76C,EAAA,GAAK3J,GAAKqD,EAAKmhD,EAAS,GAAKnhD,EAAKmhD,EAAS,IACjD76C,EAAM,GAAK06C,EAAM,GAAKA,EAAM,GAC5B16C,EAAM,GAAK06C,EAAM,GAAKA,EAAM,GAC5BtI,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BoyC,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BoyC,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BoyC,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BtG,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,GACnCjhD,EAAKmhD,EAAS,GAAKzI,EAAM,GAAKuI,EAAK,EACpC,CACD,IAAA,IAASG,EAAS,EAAGA,EAAS,IAAKA,EACjCJ,EAAM,GAAK9hD,EAAIc,EAAK,GAAKohD,GACzBJ,EAAM,GAAKljD,EAAIkC,EAAK,GAAKohD,GACzBJ,EAAM,GAAK9hD,EAAIc,EAAK,GAAKohD,GACzBJ,EAAM,GAAKljD,EAAIkC,EAAK,GAAKohD,GACpBH,EAAA,GAAKhmD,EAAI+E,EAAK,EAAIohD,GAAUvkD,EAAImD,EAAK,GAAKohD,GAAUxhD,EAAII,EAAK,GAAKohD,GAAUL,EAAI/gD,EAAK,GAAKohD,GAC1FH,EAAA,GAAKpkD,EAAImD,EAAK,EAAIohD,GAAUL,EAAI/gD,EAAK,GAAKohD,GAAUnmD,EAAI+E,EAAK,GAAKohD,GAAUxhD,EAAII,EAAK,GAAKohD,GAC1FH,EAAA,GAAKrhD,EAAII,EAAK,EAAIohD,GAAUnmD,EAAI+E,EAAK,GAAKohD,GAAUL,EAAI/gD,EAAK,GAAKohD,GAAUvkD,EAAImD,EAAK,GAAKohD,GAC1FH,EAAA,GAAKF,EAAI/gD,EAAK,EAAIohD,GAAUxhD,EAAII,EAAK,GAAKohD,GAAUvkD,EAAImD,EAAK,GAAKohD,GAAUnmD,EAAI+E,EAAK,GAAKohD,GACzF96C,EAAA,GAAK3J,GAAKqD,EAAKohD,GAAUphD,EAAK,GAAKohD,IACnC96C,EAAA,GAAK3J,GAAKqD,EAAKohD,GAAUphD,EAAK,GAAKohD,IACzC96C,EAAM,GAAK06C,EAAM,GAAKA,EAAM,GAC5B16C,EAAM,GAAK06C,EAAM,GAAKA,EAAM,GAC5BtI,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BoyC,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BoyC,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BoyC,EAAM,GAAKpyC,EAAM,GAAKA,EAAM,GAC5BtG,EAAK,EAAIohD,GAAU1I,EAAM,GAAKuI,EAAK,GACnCjhD,EAAK,EAAIohD,GAAU1I,EAAM,GAAKuI,EAAK,GACnCjhD,EAAK,GAAKohD,GAAU1I,EAAM,GAAKuI,EAAK,GACpCjhD,EAAK,GAAKohD,GAAU1I,EAAM,GAAKuI,EAAK,GACpCjhD,EAAK,GAAKohD,GAAU1I,EAAM,GAAKuI,EAAK,GACpCjhD,EAAK,GAAKohD,GAAU1I,EAAM,GAAKuI,EAAK,GACpCjhD,EAAK,GAAKohD,GAAU1I,EAAM,GAAKuI,EAAK,GACpCjhD,EAAK,GAAKohD,GAAU1I,EAAM,GAAKuI,EAAK,EAEvC,CACD,SAASI,EAAcrhD,GACrB,IAAA,IAAStG,EAAI,EAAGA,EAAI,KAAMA,EAAG,CAC3B,IAAIoR,EAAI9K,EAAK,GAAGtG,GACZ4nD,EAAKthD,EAAK,GAAGtG,GACb6nD,EAAKvhD,EAAK,GAAGtG,GACjBsG,EAAK,GAAGtG,GAAKoR,EAAI,OAASy2C,EAC1BvhD,EAAK,GAAGtG,GAAKoR,EAAI,MAASw2C,EAAK,MAASC,EACxCvhD,EAAK,GAAGtG,GAAKoR,EAAI,OAASw2C,CAC3B,CACF,CACQ,SAAAE,EAAcp+B,EAAK2yB,EAAK0L,GAC/B,IAAA,IAAS/nD,EAAI,EAAGA,EAAI,KAAMA,EACpBq8C,EAAA0L,EAAM/nD,GAAKo+C,GAAUC,YAAY2J,EAASt+B,EAAI1pB,IAErD,CACD,SAASgoD,EAASC,GAChB,OAAIA,GAAS,EACJhkD,KAAKikD,KAAKD,GAAShkD,KAAK4D,IAAI5D,KAAK+I,IAAIi7C,GAAQ,KAE7ChkD,KAAKikD,KAAKD,GAAShkD,KAAK4D,IAAIk5C,EAAS98C,KAAK+I,IAAIi7C,GAAS,EAEjE,CACD,SAASE,EAAcC,GACd,OAAA,IAAIz6B,SAASy6B,EAAKh+C,MAAM6f,OAAQm+B,EAAKr9C,OAAO7C,MAAOkgD,EAAK3B,KAChE,CACD,SAAS4B,EAAcD,GACrB,IAAIE,EAAaF,EAAKG,OAAOt+B,OAAO5f,MAAM+9C,EAAKr9C,OAAO7C,MAAOkgD,EAAKr9C,OAAO7C,MAAQkgD,EAAK3B,MAClF+B,EAAY,IAAI5nD,WAAW4lD,EAAgB8B,IAC3CG,EAAY,IAAI7nD,WAAW4nD,EAAUjoD,QAGlC,OAFP6lD,EAAUoC,GACVnC,EAAiBmC,EAAWC,GACrB,IAAI96B,SAAS86B,EAAUx+B,OAC/B,CACD,SAASy+B,EAAcN,GACjB,IACAI,EAAYniD,GADC+hD,EAAKh+C,MAAMC,MAAM+9C,EAAKr9C,OAAO7C,MAAOkgD,EAAKr9C,OAAO7C,MAAQkgD,EAAK3B,OAE1EgC,EAAY,IAAI7nD,WAAW4nD,EAAUjoD,QAGlC,OAFP6lD,EAAUoC,GACVnC,EAAiBmC,EAAWC,GACrB,IAAI96B,SAAS86B,EAAUx+B,OAC/B,CACD,SAAS0+B,EAAcP,GAOrB,IANA,IAAI3G,EAAa2G,EAAKG,OAClBlH,EAAW,CAAEn5C,MAAOkgD,EAAKr9C,OAAO7C,OAChCu6C,EAAY,IAAI3hD,YAAYsnD,EAAK5gD,MAAQ4gD,EAAKQ,mBAAqBR,EAAKxkB,SAAWwkB,EAAKvjD,OACxFgkD,EAAS,IAAIjoD,WAptBC+/C,MAqtBdmI,EAAe,EACfC,EAAiB,IAAIjkC,MAAMsjC,EAAKxkB,UAC3B5jC,EAAI,EAAGA,EAAIooD,EAAKxkB,SAAU5jC,IAClB+oD,EAAA/oD,GAAK,GACL+oD,EAAA/oD,GAAU,MAAI8oD,EAC7BC,EAAe/oD,GAAQ,IAAI+oD,EAAe/oD,GAAU,MACpD+oD,EAAe/oD,GAAO,GAAIooD,EAAK5gD,MAC/BuhD,EAAe/oD,GAAO,GAAIooD,EAAKY,MAC/BD,EAAe/oD,GAAS,KAAIooD,EAAKvjD,KACjBikD,GAAAC,EAAe/oD,GAAG0jD,GAAKqF,EAAe/oD,GAAG4jD,GAAKmF,EAAe/oD,GAAGymD,KAE9E,IAAAwC,EAAaC,EAAYzH,EAAYJ,GACrC8H,EAAaD,EAAYzH,EAAYJ,GACzC,GAAI8H,GAluBcxI,KAmuBV,KAAA,sDAER,GAAIsI,GAAcE,EAChB,IAASnpD,EAAI,EAAGA,EAAImpD,EAAaF,EAAa,EAAGjpD,IAC/C6oD,EAAO7oD,EAAIipD,GAAcG,EAAW3H,EAAYJ,GAGhD,IAAAgI,EAAM,IAAIvoD,YAAY6/C,GACtB2I,EAptBG,SAAqBT,EAAQQ,GAEpC,IADA,IAAI7kB,EAAI,EACCxkC,EAAI,EAAGA,EAAI2gD,IAAgB3gD,GACzB,GAALA,GAAU6oD,EAAO7oD,GAAK,GAAK,IAAU,EAAJA,MACnCqpD,EAAI7kB,KAAOxkC,GAIf,IADA,IAAI2E,EAAI6/B,EAAI,EACLA,EAAImc,GACT0I,EAAI7kB,KAAO,EACN,OAAA7/B,CACR,CAysBgB4kD,CAAqBV,EAAQQ,GACxC9oD,EAAS6kD,EAAY3D,EAAYJ,GACrC2D,EAAcoD,EAAKh+C,MAAOq3C,EAAYJ,EAAU9gD,EAAQkiD,EAAWqG,GACnE,IAAS9oD,EAAI,EAAGA,EAAIooD,EAAKxkB,WAAY5jC,EAE1B,IADL,IAAAiC,EAAK8mD,EAAe/oD,GACfyB,EAAI,EAAGA,EAAIsnD,EAAe/oD,GAAGymD,OAAQhlD,EAC5CgiD,EAAWhB,EAAWxgD,EAAGX,MAAQG,EAAGQ,EAAGyhD,GAAIzhD,EAAGwkD,KAAMxkD,EAAG2hD,GAAI3hD,EAAGyhD,GAAKzhD,EAAGwkD,KAAM6C,IA3WzE,SAASD,EAAK/iD,EAAMkjD,GAC3B,IAAA,IAASxpD,EAAI,EAAGA,EAAIwpD,IAASxpD,EAC3BsG,EAAKtG,GAAKqpD,EAAI/iD,EAAKtG,GAEtB,CA0WUypD,CAAAJ,EAAK5G,EAAWqG,GAGzB,IAFA,IAAIY,EAAa,EACbjB,EAAY,IAAI7nD,WAAW6hD,EAAUx4B,OAAOK,YACvClZ,EAAI,EAAGA,EAAIg3C,EAAKY,MAAO53C,IAC9B,IAAA,IAAS5L,EAAI,EAAGA,EAAI4iD,EAAKxkB,SAAUp+B,IAAK,CAClC,IACAb,GADA1C,EAAK8mD,EAAevjD,IACbk+C,GAAKzhD,EAAGwkD,KACfkD,EAAK,IAAI/oD,WAAW6hD,EAAUx4B,OA5uBrB,EA4uB6BhoB,EAAGgE,IA5uBhC,EA4uBkDtB,GACrD8jD,EAAAvkD,IAAIylD,EAAID,GAClBA,GA9uBa,EA8uBC/kD,EACd1C,EAAGgE,KAAOtB,CACX,CAEI,OAAA,IAAIgpB,SAAS86B,EAAUx+B,OAC/B,CACD,SAAS2/B,EAAcxB,GACjB,IACAI,EAAYniD,GADC+hD,EAAKh+C,MAAMC,MAAM+9C,EAAKr9C,OAAO7C,MAAOkgD,EAAKr9C,OAAO7C,MAAQkgD,EAAK3B,OAE9E,MAAMoD,EAAKzB,EAAKY,MAAQZ,EAAKxkB,SAAWwkB,EAAK5gD,MACvCihD,EAAyB,GAAbL,EAAKvjD,KAAY,IAAI/D,YAAY+oD,GAAM,IAAI7oD,YAAY6oD,GACzE,IAAIC,EAAe,EACfC,EAAW,EACT,MAAAhK,EAAM,IAAIj7B,MAAM,GACtB,IAAA,IAAS1T,EAAI,EAAGA,EAAIg3C,EAAKY,MAAO53C,IAC9B,IAAA,IAAS5L,EAAI,EAAGA,EAAI4iD,EAAKxkB,SAAUp+B,IAAK,CACtC,IAAIwkD,EAAQ,EACZ,OAAQ5B,EAAKvjD,MACX,KAAK,EACHk7C,EAAI,GAAK+J,EACT/J,EAAI,GAAKA,EAAI,GAAKqI,EAAK5gD,MACRsiD,EAAA/J,EAAI,GAAKqI,EAAK5gD,MAC7B,IAAA,IAAS/F,EAAI,EAAGA,EAAI2mD,EAAK5gD,QAAS/F,EAAG,CAE1BuoD,GADIxB,EAAUzI,EAAI,OAAS,EAAIyI,EAAUzI,EAAI,MAEtD0I,EAAUsB,GAAYC,EACtBD,GACD,CACD,MACF,KAAK,EACHhK,EAAI,GAAK+J,EACT/J,EAAI,GAAKA,EAAI,GAAKqI,EAAK5gD,MACvBu4C,EAAI,GAAKA,EAAI,GAAKqI,EAAK5gD,MACRsiD,EAAA/J,EAAI,GAAKqI,EAAK5gD,MAC7B,IAAA,IAAS/F,EAAI,EAAGA,EAAI2mD,EAAK5gD,QAAS/F,EAAG,CAE1BuoD,GADIxB,EAAUzI,EAAI,OAAS,GAAKyI,EAAUzI,EAAI,OAAS,GAAKyI,EAAUzI,EAAI,OAAS,EAE5F0I,EAAUsB,GAAYC,EACtBD,GACD,EAGN,CAEI,OAAA,IAAIp8B,SAAS86B,EAAUx+B,OAC/B,CACD,SAASggC,EAAc7B,GACrB,IAAI3G,EAAa2G,EAAKG,OAClBlH,EAAW,CAAEn5C,MAAOkgD,EAAKr9C,OAAO7C,OAChCu6C,EAAY,IAAI7hD,WAAWwnD,EAAK5gD,MAAQ4gD,EAAKY,OAASZ,EAAKxkB,SAAWwkB,EAAKvjD,KA/xB9D,IAgyBbqlD,EAAY,CACdprD,QAASqrD,EAAW1I,EAAYJ,GAChC+I,wBAAyBD,EAAW1I,EAAYJ,GAChDgJ,sBAAuBF,EAAW1I,EAAYJ,GAC9CiJ,iBAAkBH,EAAW1I,EAAYJ,GACzCkJ,iBAAkBJ,EAAW1I,EAAYJ,GACzCmJ,kBAAmBL,EAAW1I,EAAYJ,GAC1CoJ,oBAAqBN,EAAW1I,EAAYJ,GAC5CqJ,WAAYP,EAAW1I,EAAYJ,GACnCsJ,yBAA0BR,EAAW1I,EAAYJ,GACjDuJ,yBAA0BT,EAAW1I,EAAYJ,GACjDwJ,cAAeV,EAAW1I,EAAYJ,IAEpC,GAAA6I,EAAUprD,QAAU,EACtB,KAAM,oBAAsBgsD,EAAUC,YAAc,YAAcb,EAAUprD,QAAU,kBAIxF,IAFI,IAAAksD,EAAe,IAAIlmC,MACnBmmC,EAAW/B,EAAYzH,EAAYJ,GAjzBtB,EAkzBV4J,EAAW,GAAG,CACnB,IAAI1rC,EAAO2rC,EAA0BzJ,EAAWx3B,OAAQo3B,GACpDn5C,EAAQkhD,EAAW3H,EAAYJ,GAC/B0J,EAAc7iD,GAAS,EAAI,EAE3BxI,EAAQ,IAAI+yB,UAAU,EADfvqB,GAAS,GAAK,IACQ,GAC7BrD,EAAOukD,EAAW3H,EAAYJ,GAClC2J,EAAa9qD,KAAK,CAChBqf,OACA7f,QACAmF,OACAkmD,gBAEFE,GAAY1rC,EAAKhf,OAAS,CAC3B,CAGD,IAFA,IAAIqjC,EAAWknB,EAAUlnB,SACrBunB,EAAc,IAAIrmC,MAAMsjC,EAAKxkB,UACxB5jC,EAAI,EAAGA,EAAIooD,EAAKxkB,WAAY5jC,EAAG,CACtC,IAAIiC,EAAKkpD,EAAYnrD,GAAK,CAAA,EACtBwvB,EAAUoU,EAAS5jC,GACvBiC,EAAGsd,KAAOiQ,EAAQjQ,KAClBtd,EAAG8oD,YAn0BS,EAo0BZ9oD,EAAGmpD,SAAU,EACbnpD,EAAG4C,KAAO2qB,EAAQ67B,UAClBppD,EAAGqpD,QAAU97B,EAAQ87B,QACrBrpD,EAAGuF,MAAQ4gD,EAAK5gD,MAChBvF,EAAGkG,OAASigD,EAAKY,KAClB,CAID,IAHA,IAAIuC,EAAS,CACXxD,IAAK,IAAIjjC,MAAM,IAER0mC,EAAU,EAAGA,EAAUpD,EAAKxkB,WAAY4nB,EAE/C,IADIvpD,EAAKkpD,EAAYK,GACZxrD,EAAI,EAAGA,EAAIgrD,EAAazqD,SAAUP,EAAG,CACxC,IAAAyrD,EAAOT,EAAahrD,GACpBiC,EAAGsd,MAAQksC,EAAKlsC,OAClBtd,EAAG8oD,YAAcU,EAAKV,YAClBU,EAAK/rD,OAAS,IACT6rD,EAAAxD,IAAI0D,EAAK/rD,OAAS8rD,GAE3BvpD,EAAG8I,OAASygD,EAEf,CAEC,GAAAtB,EAAUI,iBAAmB,EAC/B,OAAQJ,EAAUW,eAChB,KA91BiB,EA+1Bf,IAAI/D,EAAW,IAAIhmD,YAAYopD,EAAUS,0BACzC3F,EACEoD,EAAKh+C,MACLq3C,EACAJ,EACA6I,EAAUI,iBACVxD,EACAoD,EAAUS,0BAEZ,MACF,KAx2BU,EAy2BJ,IACArkD,EAAOD,GADM+hD,EAAKh+C,MAAMC,MAAMg3C,EAASn5C,MAAOm5C,EAASn5C,MAAQgiD,EAAUS,2BAEzE7D,EAAW,IAAIhmD,YAAYwF,EAAK2jB,QACpCo3B,EAASn5C,OAASgiD,EAAUS,yBAI9B,GAAAT,EAAUK,iBAAmB,EAAG,CAClC,IAAImB,EAAW,CACbthD,MAAOg+C,EAAKh+C,MACZW,OAAQs2C,EACRoF,KAAMyD,EAAUK,kBAEdoB,EAAW,IAAI7qD,YAAY4nD,EAAcgD,GAAUzhC,QACvDo3B,EAASn5C,OAASgiD,EAAUK,gBAC7B,CACG,GAAAL,EAAUQ,WAAa,EAAG,CACxB,IAEAkB,EAAYpF,GADZlgD,EAAOD,GADM+hD,EAAKh+C,MAAMC,MAAMg3C,EAASn5C,MAAOm5C,EAASn5C,MAAQgiD,EAAUM,qBAExCvgC,QACrCo3B,EAASn5C,OAASgiD,EAAUM,iBAC7B,CACD,IAAI1B,EAAe,EACf+C,EAAa,IAAI/mC,MAAMqmC,EAAY5qD,QACvC,IAASP,EAAI,EAAGA,EAAI6rD,EAAWtrD,SAAUP,EAC5B6rD,EAAA7rD,GAAK,IAAI8kB,MAEtB,IAAA,IAAS1T,EAAI,EAAGA,EAAIg3C,EAAKY,QAAS53C,EAChC,IAAA,IAAS06C,EAAO,EAAGA,EAAOX,EAAY5qD,SAAUurD,EACnCD,EAAAC,GAAM5rD,KAAK4oD,GACtBA,GAAgBqC,EAAYW,GAAMtkD,MAAQ4gD,EAAKvjD,KA14BlC,GAwanB,SAAwB0mD,EAAQQ,EAASZ,EAAarE,EAAU6E,EAAUlJ,GACxE,IAAIuJ,EAAW,IAAIr+B,SAAS80B,EAAUx4B,QAClCziB,EAAQ2jD,EAAYI,EAAOxD,IAAI,IAAIvgD,MACnCW,EAASgjD,EAAYI,EAAOxD,IAAI,IAAI5/C,OAEpC8jD,EAAiBhoD,KAAKyD,MAAMF,EAAQ,GACpC0kD,EAAajoD,KAAKkoD,KAAK3kD,EAAQ,GAC/B4kD,EAAanoD,KAAKkoD,KAAKhkD,EAAS,GAChCkkD,EAAY7kD,EAA2B,GAAlB0kD,EAAa,GAClCI,EAAYnkD,EAA4B,GAAlBikD,EAAa,GACnCvF,EAAa,CAAE3+C,MAAO,GACtBqkD,EAAa,IAAIznC,MAPP,GAQV0nC,EAAU,IAAI1nC,MARJ,GASViiC,EAAe,IAAIjiC,MATT,GAUV2nC,EAAW,IAAI3nC,MAVL,GAWV+mC,EAAa,IAAI/mC,MAXP,GAYd,IAAA,IAAS4nC,EAAQ,EAAGA,EAZN,IAYyBA,EACrCb,EAAWa,GAASX,EAAQR,EAAOxD,IAAI2E,IAC5BH,EAAAG,GAASA,EAAQ,EAAI,EAAIH,EAAWG,EAAQ,GAAKR,EAAaE,EACzEI,EAAQE,GAAS,IAAI/5B,aAAa,IAClCo0B,EAAa2F,GAAS,IAAI5rD,YAAY,IACtC2rD,EAASC,GAAS,IAAI5rD,YAAyB,GAAborD,GAEpC,IAAA,IAASS,EAAS,EAAGA,EAASP,IAAcO,EAAQ,CAClD,IAAIC,EAAO,EACPD,GAAUP,EAAa,IAClBQ,EAAAN,GACT,IAAIO,EAAO,EACX,IAAA,IAASC,EAAS,EAAGA,EAASZ,IAAcY,EAAQ,CAC9CA,GAAUZ,EAAa,IAClBW,EAAAR,GACT,IAAA,IAASK,EAAQ,EAAGA,EA3BV,IA2B6BA,EACxB3F,EAAA2F,GAAOK,KAAK,GACzBhG,EAAa2F,GAAO,GAAKf,EAASY,EAAWG,MAC7C9F,EAAQC,EAAYC,EAAUC,EAAa2F,IAC3CxF,EAASH,EAAa2F,GAAQF,EAAQE,IAC3BtF,EAAAoF,EAAQE,IAGnB/E,EAAc6E,GAEhB,IAAA,IAASE,EAAQ,EAAGA,EArCV,IAqC6BA,EACrC5E,EAAc0E,EAAQE,GAAQD,EAASC,GAAiB,GAATI,EAElD,CACD,IAAItB,EAAU,EACd,IAAA,IAASkB,EAAQ,EAAGA,EA1CR,IA0C2BA,EAAO,CAC5C,MAAMM,EAAQ7B,EAAYI,EAAOxD,IAAI2E,IAAQ7nD,KACpC,IAAA,IAAAooD,EAAK,EAAIN,EAAQM,EAAK,EAAIN,EAASC,IAAQK,EAAI,CAC5CzB,EAAAK,EAAWa,GAAOO,GAC5B,IAAA,IAASH,EAAS,EAAGA,EAASb,IAAkBa,EAAQ,CACtD,MAAMpjC,EAAe,GAATojC,EAAyB,GAAL,EAALG,GAClBjB,EAAAkB,UAAU1B,EAAU,EAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,EAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,EAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,EAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,EAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,GAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,GAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GACtEsiC,EAAAkB,UAAU1B,EAAU,GAAiBwB,EAAOP,EAASC,GAAOhjC,EAAM,IAAI,GAC/E8hC,GAAW,GAAiBwB,CAC7B,CACF,CACD,GAAIf,GAAkBC,EACX,IAAA,IAAAe,EAAK,EAAIN,EAAQM,EAAK,EAAIN,EAASC,IAAQK,EAAI,CAChD,MAAAE,EAAUtB,EAAWa,GAAOO,GAAM,EAAIhB,EAzenC,EAyeiEe,EACpEtjC,EAAuB,GAAjBuiC,EAAiC,GAAL,EAALgB,GACnC,IAAA,IAASG,EAAK,EAAGA,EAAKP,IAAQO,EACnBpB,EAAAkB,UAAUC,EA5eZ,EA4esBC,EAAkBJ,EAAOP,EAASC,GAAOhjC,EAAM0jC,IAAK,EAEpF,CAEJ,CACF,CAGD,IAFI,IAAAC,EAAU,IAAIvsD,YAAY0G,GAErB8lD,GADLtB,EAAW,IAAIr+B,SAAS80B,EAAUx4B,QACtB,GAAGqjC,EAxEL,IAwEuBA,EAAM,CACzCnC,EAAYI,EAAOxD,IAAIuF,IAAOlC,SAAU,EACxC,IAAIvmD,EAAOsmD,EAAYI,EAAOxD,IAAIuF,IAAOzoD,KACrC,GAA0B,GAA1BsmD,EAAYmC,GAAMzoD,KAEtB,IAAA,IAASuM,EAAI,EAAGA,EAAIjJ,IAAUiJ,EAAG,CAC/B,MAAMo6C,EAAUK,EAAWyB,GAAMl8C,GACjC,IAAA,IAASrP,EAAI,EAAGA,EAAIyF,IAASzF,EACnBsrD,EAAAtrD,GAAKiqD,EAASvf,UAAU+e,EA5frB,EA4f+BzpD,EAAiB8C,GAAM,GAEnE,IAAS9C,EAAI,EAAGA,EAAIyF,IAASzF,EAClBiqD,EAAAuB,WAAW/B,EA/fT,EA+fmBzpD,EAAiB8C,EAAMsiD,EAAckG,EAAQtrD,KAAK,EAEnF,CACF,CACF,CA0YCyrD,CAAejC,EAAQM,EAAYV,EAAarE,EAAU6E,EAAUlJ,GACpE,IAASziD,EAAI,EAAGA,EAAImrD,EAAY5qD,SAAUP,EAAG,CAE3C,KADIiC,EAAKkpD,EAAYnrD,IACdorD,QAAP,CAEA,GA54BQ,IA44BAnpD,EAAG8oD,YAiBD,KAAA,mDAfN,IAAIvD,EAAM,EACNiG,EAAY,EAChB,IAASr8C,EAAI,EAAGA,EAAIg3C,EAAKY,QAAS53C,EAAG,CAEnC,IADA,IAAIs8C,EAAiB7B,EAAW7rD,GAAGwnD,GAC1BzlD,EAAI,EAAGA,EAAIE,EAAGuF,QAASzF,EAAG,CACjC,IAAA,IAAS4rD,EAAO,EAAGA,EAz5BZ,EAy5BgC1rD,EAAG4C,OAAQ8oD,EACtClL,EAAAiL,KAAoB9B,EAAU6B,EAAYE,EAAO1rD,EAAGuF,MAAQvF,EAAGkG,QAE3EslD,GACD,CACDjG,GACD,CAdH,CAoBH,CACM,OAAA,IAAI75B,SAAS80B,EAAUx4B,OAC/B,CACQ,SAAAihC,EAA0BzN,EAAS+N,GAG1C,IAFI,IAAAoC,EAAa,IAAIhtD,WAAW68C,GAC5BoQ,EAAY,EACgC,GAAzCD,EAAWpC,EAAQtjD,MAAQ2lD,IACnBA,GAAA,EAEf,IAAIC,GAAc,IAAIpnD,aAAcC,OAAOinD,EAAWvjD,MAAMmhD,EAAQtjD,MAAOsjD,EAAQtjD,MAAQ2lD,IAEpF,OADCrC,EAAAtjD,MAAQsjD,EAAQtjD,MAAQ2lD,EAAY,EACrCC,CACR,CAgBQ,SAAAC,EAAW/B,EAAUR,GAC5B,IAAIwC,EAAQhC,EAASlf,SAAS0e,EAAQtjD,OAAO,GAEtC,OADCsjD,EAAAtjD,MAAQsjD,EAAQtjD,MAp8BP,EAq8BV8lD,CACR,CACQ,SAAA5I,EAAY4G,EAAUR,GAC7B,IAAIyC,EAASjC,EAASl+B,UAAU09B,EAAQtjD,OAAO,GAExC,OADCsjD,EAAAtjD,MAAQsjD,EAAQtjD,MAz8BP,EA08BV+lD,CACR,CACQ,SAAA3M,EAAgBF,EAAaoK,GAChC,IAAA0C,EAAQ9M,EAAYoK,EAAQtjD,OAEzB,OADCsjD,EAAAtjD,MAAQsjD,EAAQtjD,MA58BR,EA68BTgmD,CACR,CACQ,SAAA9E,EAAW4C,EAAUR,GAC5B,IAAI0C,EAAQlC,EAASzf,SAASif,EAAQtjD,OAE/B,OADCsjD,EAAAtjD,MAAQsjD,EAAQtjD,MAj9BR,EAk9BTgmD,CACR,CACK,MAAA/D,EAAa,SAAS6B,EAAUR,GAChC,IAAA2C,EAOG,OALLA,EADE,gBAAiBxgC,SAASN,UACtByhB,OAAOkd,EAASoC,YAAY5C,EAAQtjD,OAAO,IAE3C8jD,EAASl+B,UAAU09B,EAAQtjD,MAAQ,GAAG,GAAQ4mC,OAAOkd,EAASl+B,UAAU09B,EAAQtjD,OAAO,IAAS,IAExGsjD,EAAQtjD,OA/9BS,EAg+BVimD,CACb,EACa,SAAAE,EAAarC,EAAUR,GAC9B,IAAIvD,EAAQ+D,EAASsC,WAAW9C,EAAQtjD,OAAO,GAExC,OADPsjD,EAAQtjD,OAn+BW,EAo+BZ+/C,CACR,CACQ,SAAAsG,EAAcvC,EAAUR,GAC/B,OAAOpN,GAAUC,YAAYgQ,EAAarC,EAAUR,GACrD,CACD,SAASrE,EAAcqH,GACrB,IAAIC,GAAqB,MAATD,IAAmB,GAAIE,EAAoB,KAATF,EAC1C,OAAAA,GAAU,IAAU,EAAA,IAAMC,EAAwB,KAAbA,EAAkBC,EAAWC,IAAMrjD,IAAWrH,KAAK4D,IAAI,EAAG4mD,EAAW,KAAO,EAAIC,EAAW,MAA0BA,EAAW,KAA7B,eACjJ,CACQ,SAAAxF,EAAY8C,EAAUR,GAC7B,IAAIoD,EAAS5C,EAASvf,UAAU+e,EAAQtjD,OAAO,GAExC,OADPsjD,EAAQtjD,OA7+BS,EA8+BV0mD,CACR,CACQ,SAAAC,EAAapR,EAAS+N,GAC7B,OAAOrE,EAAc+B,EAAYzL,EAAS+N,GAC3C,CAiFD,SAASsD,EAAW9C,EAAUvO,EAAS+N,EAAS3mD,EAAM4hD,GACpD,MAAa,WAAT5hD,GAA8B,iBAATA,GAAoC,eAATA,EAlJ7C,SAAuB44C,EAAS+N,EAAS/E,GAChD,IAAIqH,GAAc,IAAIpnD,aAAcC,OAAO,IAAI/F,WAAW68C,GAASpzC,MAAMmhD,EAAQtjD,MAAOsjD,EAAQtjD,MAAQu+C,IAEjG,OADC+E,EAAAtjD,MAAQsjD,EAAQtjD,MAAQu+C,EACzBqH,CACR,CA+IUiB,CAAuBtR,EAAS+N,EAAS/E,GAC9B,WAAT5hD,EAnFb,SAAqBmnD,EAAUvO,EAAS+N,EAAS/E,GAG/C,IAFA,IAAIuI,EAAcxD,EAAQtjD,MACtB07B,EAAW,GACR4nB,EAAQtjD,MAAQ8mD,EAAcvI,EAAO,GAAG,CACzC,IAAAlnC,EAAO2rC,EAA0BzN,EAAS+N,GAC1CH,EAAY0C,EAAW/B,EAAUR,GACjCF,EAAUlC,EAAW4C,EAAUR,GACnCA,EAAQtjD,OAAS,EACb,IAAA+mD,EAAYlB,EAAW/B,EAAUR,GACjC0D,EAAYnB,EAAW/B,EAAUR,GACrC5nB,EAAS1jC,KAAK,CACZqf,OACA8rC,YACAC,UACA2D,YACAC,aAEH,CAEM,OADP1D,EAAQtjD,OAAS,EACV07B,CACR,CAgEUurB,CAAYnD,EAAUvO,EAAS+N,EAAS/E,GAC7B,mBAAT5hD,EAhEJ,SAAoBmnD,EAAUR,GAS9B,MAAA,CACL4D,KATSf,EAAarC,EAAUR,GAUhC6D,KATShB,EAAarC,EAAUR,GAUhC8D,OATWjB,EAAarC,EAAUR,GAUlC+D,OATWlB,EAAarC,EAAUR,GAUlCgE,MATUnB,EAAarC,EAAUR,GAUjCiE,MATUpB,EAAarC,EAAUR,GAUjCkE,OATWrB,EAAarC,EAAUR,GAUlCmE,OATWtB,EAAarC,EAAUR,GAWrC,CA8CUoE,CAAoB5D,EAAUR,GACnB,gBAAT3mD,EA9CJ,SAAiBmnD,EAAUR,GAclC,MAbuB,CACrB,iBACA,kBACA,mBACA,kBACA,kBACA,oBACA,kBACA,mBACA,mBACA,oBAEgBpC,EAAW4C,EAAUR,GAExC,CAgCUqE,CAAiB7D,EAAUR,GAChB,UAAT3mD,EAhCJ,SAAWmnD,EAAUR,GAK5B,MAAO,CAAEsE,KAJE1K,EAAY4G,EAAUR,GAIlBuE,KAHJ3K,EAAY4G,EAAUR,GAGZwE,KAFV5K,EAAY4G,EAAUR,GAENyE,KADhB7K,EAAY4G,EAAUR,GAElC,CA2BU0E,CAAWlE,EAAUR,GACV,cAAT3mD,EA3BJ,SAAemnD,EAAUR,GAGhC,MAFiB,CAAC,gBACFpC,EAAW4C,EAAUR,GAEtC,CAwBU2E,CAAenE,EAAUR,GACd,UAAT3mD,EACFwpD,EAAarC,EAAUR,GACZ,QAAT3mD,EA1BJ,SAASmnD,EAAUR,GAGnB,MAAA,CAFC6C,EAAarC,EAAUR,GACvB6C,EAAarC,EAAUR,GAEhC,CAuBU4E,CAASpE,EAAUR,GACR,QAAT3mD,EAvBJ,SAASmnD,EAAUR,GAInB,MAAA,CAHC6C,EAAarC,EAAUR,GACvB6C,EAAarC,EAAUR,GACvB6C,EAAarC,EAAUR,GAEhC,CAmBU6E,CAASrE,EAAUR,GACR,QAAT3mD,EACFkpD,EAAW/B,EAAUR,GACV,aAAT3mD,EAjKJ,SAAcmnD,EAAUR,GAGxB,MAAA,CAFCuC,EAAW/B,EAAUR,GACrBpG,EAAY4G,EAAUR,GAE/B,CA8JU8E,CAActE,EAAUR,GACb,aAAT3mD,EA9JJ,SAAcmnD,EAAUR,GAGxB,MAAA,CAFCpG,EAAY4G,EAAUR,GACtBpG,EAAY4G,EAAUR,GAE/B,CA2JU+E,CAAcvE,EAAUR,GACb,YAAT3mD,GACT2mD,EAAQtjD,OAASu+C,EACV,gBAEP+E,EAAQtjD,OAASu+C,EAGpB,CAmJK,MAAA+J,EAAiB,IAAI7iC,SAAS1D,GAC9BwmC,EAAa,IAAI7vD,WAAWqpB,GAC5Blf,EAAS,CAAE7C,MAAO,GAClB4iD,EArJG,SAAYkB,EAAUvO,EAAS+N,GACtC,MAAMkF,EAAa,CAAA,EACnB,GAAmC,UAA/B1E,EAASl+B,UAAU,GAAG,GAClB,KAAA,yEAEG4iC,EAAA5xD,QAAUktD,EAASzf,SAAS,GACjC,MAAAokB,EAAO3E,EAASzf,SAAS,GAC/BmkB,EAAWC,KAAO,CAChBC,cAAsB,EAAPD,GACfE,YAAoB,EAAPF,GACbG,cAAsB,EAAPH,GACfI,aAAqB,GAAPJ,IAEhBnF,EAAQtjD,MAAQ,EAEhB,IADA,IAAI8oD,GAAc,EACXA,GAAa,CACd,IAAAnkC,EAAgBq+B,EAA0BzN,EAAS+N,GACvD,GAAqB,GAAjB3+B,EACYmkC,GAAA,MACT,CACD,IAAAC,EAAgB/F,EAA0BzN,EAAS+N,GAEnD0F,EAAiBpC,EAAW9C,EAAUvO,EAAS+N,EAASyF,EADxC7L,EAAY4G,EAAUR,SAEnB,IAAnB0F,EACM5xD,QAAAC,KAAK,2DAA2D0xD,OAExEP,EAAW7jC,GAAiBqkC,CAE/B,CACF,CACI,GAAc,KAAP,EAAPP,GAEG,MADErxD,QAAAS,MAAM,aAAc2wD,GACtB,2DAED,OAAAA,CACR,CAkHiBS,CAAYX,EAAgBvmC,EAAQlf,GAChDqmD,GAlHN,SAAsBV,EAAY1E,EAAU5K,EAAaoK,EAAS6F,GAChE,MAAMC,EAAc,CAClB7K,KAAM,EACN8B,OAAQyD,EACR5hD,MAAOg3C,EACPr2C,OAAQygD,EACRhkD,MAAOkpD,EAAWa,WAAWvB,KAAOU,EAAWa,WAAWzB,KAAO,EACjE3nD,OAAQuoD,EAAWa,WAAWtB,KAAOS,EAAWa,WAAWxB,KAAO,EAClEnsB,SAAU8sB,EAAW9sB,SAASrjC,OAC9BixD,aAAc,KACdxI,MAAO,KACPyI,UAAW,KACX5sD,KAAM6rD,EAAW9sB,SAAS,GAAGynB,UAC7BqG,WAAY,KACZC,OAAQ,KACRpiB,OAAQ,KACR,CAACkR,GAAgB,aAAe,YAAa,MAE/C,OAAQiQ,EAAW3F,aACjB,IAAK,iBACHuG,EAAYtI,MAAQ,EACpBsI,EAAYI,WAAavJ,EACzB,MACF,IAAK,kBACHmJ,EAAYtI,MAAQ,EACpBsI,EAAYI,WAAarJ,EACzB,MACF,IAAK,mBACHiJ,EAAYtI,MAAQ,EACpBsI,EAAYI,WAAahJ,EACzB,MACF,IAAK,kBACH4I,EAAYtI,MAAQ,GACpBsI,EAAYI,WAAahJ,EACzB,MACF,IAAK,kBACH4I,EAAYtI,MAAQ,GACpBsI,EAAYI,WAAa/I,EACzB,MACF,IAAK,oBACH2I,EAAYtI,MAAQ,GACpBsI,EAAYI,WAAa9H,EACzB,MACF,IAAK,mBACH0H,EAAYtI,MAAQ,GACpBsI,EAAYI,WAAazH,EACzB,MACF,IAAK,mBACHqH,EAAYtI,MAAQ,IACpBsI,EAAYI,WAAazH,EACzB,MACF,QACQ,KAAA,oBAAsByG,EAAW3F,YAAc,kBAGrD,GADJuG,EAAY1I,kBAAoB0I,EAAYtI,MACpB,GAApBsI,EAAYzsD,KACd,OAAQwsD,GACN,KAAKna,GACHoa,EAAYK,OAAS9C,EACrByC,EAAYG,UAnsCD,EAosCX,MACF,KAAKta,GACHma,EAAYK,OAASzI,EACrBoI,EAAYG,UAvsCD,MA0sCvB,IAAqC,GAApBH,EAAYzsD,KAWrB,KAAM,0CAA4CysD,EAAYzsD,KAAO,QAAU6rD,EAAW3F,YAAc,IAVxG,OAAQsG,GACN,KAAKna,GACHoa,EAAYK,OAAStD,EACrBiD,EAAYG,UAhtCC,EAitCb,MACF,KAAKta,GACHma,EAAYK,OAASpD,EACrB+C,EAAYG,UAptCC,EAwtClB,CACDH,EAAYM,YAAclB,EAAWa,WAAWtB,KAAO,GAAKqB,EAAY1I,kBACxE,IAAA,IAAS5oD,EAAI,EAAGA,EAAIsxD,EAAYM,WAAY5xD,IAC1CmqD,EAAW6B,EAAUR,GACvB8F,EAAYO,eAAyC,GAAxBP,EAAY1tB,SAAgB,EAAI0tB,EAAY1tB,SACzE,MAAM6iB,EAAO6K,EAAY9pD,MAAQ8pD,EAAYnpD,OAASmpD,EAAYO,eAClE,OAAQR,GACN,KAAKna,GACSoa,EAAAhT,UAAY,IAAI3rB,aAAa8zB,GACrC6K,EAAY1tB,SAAW0tB,EAAYO,gBACrCP,EAAYhT,UAAUyO,KAAK,EAAG,EAAGtG,GACnC,MACF,KAAKtP,GACSma,EAAAhT,UAAY,IAAIx9C,YAAY2lD,GACpC6K,EAAY1tB,SAAW0tB,EAAYO,gBACrCP,EAAYhT,UAAUyO,KAAK,MAAO,EAAGtG,GACvC,MACF,QACUnnD,QAAAS,MAAM,sCAAuCsxD,GAYlD,OATPC,EAAYE,aAAeF,EAAY9pD,MAAQ8pD,EAAYG,UAAYH,EAAY1tB,SACjD,GAA9B0tB,EAAYO,eACdP,EAAY/hB,OAASsJ,GAErByY,EAAY/hB,OAAS2N,GACnBuD,GACF6Q,EAAYvzB,WAAa,cAEzBuzB,EAAYrzB,SAAW,IAClBqzB,CACR,CAKkBQ,CAAahH,EAAW0F,EAAgBC,EAAY1lD,EAAQpC,KAAK9D,MAC9EktD,GAAY,CAAE7pD,MAAO,GACrB8pD,GAAiB,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GACpD,IAAA,IAASC,GAAmB,EAAGA,GAAmBlB,GAAWjpD,OAASipD,GAAWxI,kBAAmB0J,KAAoB,CAChH,MAAApT,EAAOkG,EAAYoL,EAAgBzlD,GAC9BqmD,GAAA3K,KAAOrB,EAAYoL,EAAgBzlD,GACnCqmD,GAAApI,MAAQ9J,EAAOkS,GAAWxI,kBAAoBwI,GAAWjpD,OAASipD,GAAWjpD,OAAS+2C,EAAOkS,GAAWxI,kBACnH,MACML,EADe6I,GAAW3K,KAAO2K,GAAWpI,MAAQoI,GAAWI,aACvCJ,GAAWM,WAAWN,IAAcjJ,EAAciJ,IAChFrmD,EAAO7C,OAASkpD,GAAW3K,KAC3B,IAAA,IAAS8L,EAAS,EAAGA,EAASnB,GAAWxI,kBAAmB2J,IAAU,CAC9D,MAAAC,EAASD,EAASD,GAAmBlB,GAAWxI,kBACtD,GAAI4J,GAAUpB,GAAWjpD,OACvB,MACF,IAAA,IAASsqD,EAAY,EAAGA,EAAYrB,GAAWxtB,SAAU6uB,IAAa,CACpE,MAAMC,EAAOV,GAAelH,EAAUlnB,SAAS6uB,GAAWlzC,MAC1D,IAAA,IAASxd,EAAI,EAAGA,EAAIqvD,GAAW5pD,MAAOzF,IAAK,CAC/BgwD,GAAA7pD,OAASqqD,GAAUnB,GAAWxtB,SAAWwtB,GAAW5pD,OAASirD,EAAYrB,GAAW5pD,MAAQzF,GAAKqvD,GAAWK,UAChH,MAAAkB,GAAYvB,GAAWjpD,OAAS,EAAIqqD,IAAWpB,GAAW5pD,MAAQ4pD,GAAWS,gBAAkB9vD,EAAIqvD,GAAWS,eAAiBa,EACrItB,GAAW9S,UAAUqU,GAAYvB,GAAWO,OAAOpJ,EAAQwJ,GAC5D,CACF,CACF,CACF,CACM,MAAA,CACLnkC,OAAQk9B,EACRtjD,MAAO4pD,GAAW5pD,MAClBW,OAAQipD,GAAWjpD,OACnB7B,KAAM8qD,GAAW9S,UACjB/O,OAAQ6hB,GAAW7hB,OACnB,CAACkR,GAAgB,aAAe,YAAa2Q,GAAW3Q,GAAgB,aAAe,YACvF57C,KAAM8D,KAAK9D,KAEd,CACD,WAAA07C,CAAYr4C,GAEH,OADPS,KAAK9D,KAAOqD,EACLS,IACR,CACD,IAAA6T,CAAKC,EAAKC,EAAQC,EAAYC,GAa5B,OAAOvU,MAAMmU,KAAKC,GAZT,SAAezV,EAASw5C,GAC3BC,GACFz5C,EAAQ+2B,WAAayiB,EAAQziB,WAE7B/2B,EAAQi3B,SAAWuiB,EAAQviB,SAC7Bj3B,EAAQ21B,UAAY7J,EACpB9rB,EAAQ01B,UAAY5J,EACpB9rB,EAAQ8hC,iBAAkB,EAC1B9hC,EAAQu1B,OAAQ,EACZ7f,GACFA,EAAO1V,EAASw5C,EACnB,GACsC7jC,EAAYC,EACpD,ECv0CH,MAAMszB,OAAiCC,QACvC,MAAMyiB,WAAoB73C,EACxB,WAAAhU,CAAYiU,GACV3S,MAAM2S,GACNrS,KAAKkqD,YAAc,GACnBlqD,KAAKmqD,cAAgB,GACrBnqD,KAAKoqD,cAAgB,KACrBpqD,KAAKqqD,eAAiB,KACtBrqD,KAAKsqD,YAAc,EACnBtqD,KAAKgoC,WAAa,GAClBhoC,KAAKuqD,iBAAmB,EACxBvqD,KAAKioC,gBAAkB,GACvBjoC,KAAKwqD,oBAAsB,CACzBtzD,SAAU,WACVy+B,OAAQ,SACRrb,MAAO,QACPmwC,GAAI,aAENzqD,KAAK0qD,sBAAwB,CAC3BxzD,SAAU,eACVy+B,OAAQ,eACRrb,MAAO,eACPmwC,GAAI,eAEP,CACD,cAAAE,CAAex2C,GAEN,OADPnU,KAAKkqD,YAAc/1C,EACZnU,IACR,CACD,gBAAA4qD,CAAiB7gB,GAER,OADP/pC,KAAKmqD,cAAgBpgB,EACd/pC,IACR,CACD,cAAAwhC,CAAe8oB,GAEN,OADPtqD,KAAKsqD,YAAcA,EACZtqD,IACR,CACD,IAAA6T,CAAKC,EAAKC,EAAQC,EAAYC,GAC5B,MAAMW,EAAS,IAAIC,EAAW7U,KAAKqS,SAC5BuC,EAAAE,QAAQ9U,KAAKmU,MACpBS,EAAOG,gBAAgB,eAChBH,EAAAI,iBAAiBhV,KAAKiV,eACtBL,EAAAM,mBAAmBlV,KAAKmV,iBACxBP,EAAAf,KACLC,GACCwN,IACC,MAAMstB,EAAa,CACjBic,aAAc7qD,KAAKwqD,oBACnBM,eAAgB9qD,KAAK0qD,sBACrBK,cAAc,GAEX/qD,KAAAgrD,eAAe1pC,EAAQstB,GAAYpzB,KAAKzH,GAAQ8b,MAAM5b,EAAO,GAEpED,EACAC,EAEH,CAED,eAAAuS,CAAgBlF,EAAQ3L,EAAUk1C,EAAcC,GAC9C,MAAMlc,EAAa,CACjBic,aAAcA,GAAgB7qD,KAAKwqD,oBACnCM,eAAgBA,GAAkB9qD,KAAK0qD,sBACvCK,eAAgBF,GAElB7qD,KAAKgrD,eAAe1pC,EAAQstB,GAAYpzB,KAAK7F,EAC9C,CACD,cAAAq1C,CAAe1pC,EAAQstB,GACV,IAAA,MAAAnoB,KAAamoB,EAAWkc,eAAgB,CAC3C,MAAA5uD,EAAO0yC,EAAWkc,eAAerkC,QACR,IAA3BvqB,EAAKm2B,oBACIuc,EAAAkc,eAAerkC,GAAavqB,EAAK0a,KAE/C,CACK,MAAAq0C,EAAUj1C,KAAKwzB,UAAUoF,GAC3B,GAAArH,GAAW3K,IAAItb,GAAS,CACpB,MAAA4pC,EAAa3jB,GAAWvvB,IAAIsJ,GAC9B,GAAA4pC,EAAW3qD,MAAQ0qD,EACrB,OAAOC,EAAWx3B,QAC1B,GAAuC,IAAtBpS,EAAOK,WAChB,MAAM,IAAInM,MACR,gHAGL,CACG,IAAAqrB,EACJ,MAAMsqB,EAASnrD,KAAKuqD,mBACda,EAAW9pC,EAAOK,WAClB0pC,EAAkBrrD,KAAKsrD,WAAWH,EAAQC,GAAU5vC,MAAM+vC,IACrD1qB,EAAA0qB,EACF,IAAI5zC,SAAQ,CAACC,EAASC,KAC3BgpB,EAAO2qB,WAAWL,GAAU,CAAEvzC,UAASC,UAChCgpB,EAAAS,YAAY,CAAEplC,KAAM,SAAU0uC,GAAIugB,EAAQvc,aAAYttB,UAAU,CAACA,GAAO,OAEhF9F,MAAMw1B,GAAYhxC,KAAKyrD,gBAAgBza,EAAQx6C,YAU3C,OATP60D,EAAgBx7B,OAAM,KAAM,IAAMrU,MAAK,KACjCqlB,GAAUsqB,GACPnrD,KAAA0rD,aAAa7qB,EAAQsqB,EAC3B,IAEH5jB,GAAWhsC,IAAI+lB,EAAQ,CACrB/gB,IAAK0qD,EACLv3B,QAAS23B,IAEJA,CACR,CACD,eAAAI,CAAgBE,GACR,MAAAn1D,EAAW,IAAI+hC,EACjBozB,EAAa50D,OACfP,EAASgB,SAAS,IAAI06B,EAAgBy5B,EAAa50D,MAAM0K,MAAO,IAElE,IAAA,IAASpK,EAAI,EAAGA,EAAIs0D,EAAa3oC,WAAWprB,OAAQP,IAAK,CACjD,MAAAovB,EAAYklC,EAAa3oC,WAAW3rB,GACpCuf,EAAO6P,EAAU7P,KACjBnV,EAAQglB,EAAUhlB,MAClB6iB,EAAWmC,EAAUnC,SAC3B9tB,EAASguB,aAAa5N,EAAM,IAAIsb,EAAgBzwB,EAAO6iB,GACxD,CACM,OAAA9tB,CACR,CACD,YAAAo1D,CAAa93C,EAAK+3C,GAChB,MAAMj3C,EAAS,IAAIC,EAAW7U,KAAKqS,SAInC,OAHOuC,EAAAE,QAAQ9U,KAAKkqD,aACpBt1C,EAAOG,gBAAgB82C,GAChBj3C,EAAAM,mBAAmBlV,KAAKmV,iBACxB,IAAIwC,SAAQ,CAACC,EAASC,KAC3BjD,EAAOf,KAAKC,EAAK8D,OAAS,EAAQC,EAAM,GAE3C,CACD,OAAA6N,GAES,OADP1lB,KAAK8rD,eACE9rD,IACR,CACD,YAAA8rD,GACE,GAAI9rD,KAAKqqD,eACP,OAAOrqD,KAAKqqD,eACd,MAAM0B,EAA+B,iBAAhBnmB,aAAwD,OAA5B5lC,KAAKmqD,cAAcjuD,KAC9D8vD,EAAmB,GAsBzB,OArBID,EACFC,EAAiBz0D,KAAKyI,KAAK4rD,aAAa,mBAAoB,UAE5DI,EAAiBz0D,KAAKyI,KAAK4rD,aAAa,wBAAyB,SACjEI,EAAiBz0D,KAAKyI,KAAK4rD,aAAa,qBAAsB,iBAEhE5rD,KAAKqqD,eAAiB1yC,QAAQ6E,IAAIwvC,GAAkBxwC,MAAMywC,IAClD,MAAAjjB,EAAYijB,EAAU,GACvBF,IACE/rD,KAAAmqD,cAAclZ,WAAagb,EAAU,IAEtC,MAAA3iB,EAAK4iB,GAAYpnB,WACjBhgB,EAAO,CACX,sBACAkkB,EACA,GACA,eACAM,EAAGM,UAAUN,EAAGroC,QAAQ,KAAO,EAAGqoC,EAAGO,YAAY,OACjDzqC,KAAK,MACFY,KAAAioC,gBAAkB9T,IAAIQ,gBAAgB,IAAIF,KAAK,CAAC3P,IAAM,IAEtD9kB,KAAKqqD,cACb,CACD,UAAAiB,CAAWH,EAAQC,GACjB,OAAOprD,KAAK8rD,eAAetwC,MAAK,KAC9B,GAAIxb,KAAKgoC,WAAWpwC,OAASoI,KAAKsqD,YAAa,CAC7C,MAAM6B,EAAU,IAAIriB,OAAO9pC,KAAKioC,iBAChCkkB,EAAQX,WAAa,GACrBW,EAAQC,WAAa,GACrBD,EAAQE,UAAY,EACpBF,EAAQ7qB,YAAY,CAAEplC,KAAM,OAAQiuD,cAAenqD,KAAKmqD,gBAChDgC,EAAAG,UAAY,SAAS/uD,GAC3B,MAAMyzC,EAAUzzC,EAAEI,KAClB,OAAQqzC,EAAQ90C,MACd,IAAK,SACHiwD,EAAQX,WAAWxa,EAAQpG,IAAIhzB,QAAQo5B,GACvC,MACF,IAAK,QACHmb,EAAQX,WAAWxa,EAAQpG,IAAI/yB,OAAOm5B,GACtC,MACF,QACEr6C,QAAQS,MAAM,2CAA6C45C,EAAQ90C,KAAO,KAExF,EACa8D,KAAAgoC,WAAWzwC,KAAK40D,EAC7B,MACQnsD,KAAKgoC,WAAWra,MAAK,SAASrzB,EAAG1B,GAC/B,OAAO0B,EAAE+xD,UAAYzzD,EAAEyzD,WAAiB,EAAA,CAClD,IAEM,MAAMxrB,EAAS7gC,KAAKgoC,WAAWhoC,KAAKgoC,WAAWpwC,OAAS,GAGjD,OAFAipC,EAAAurB,WAAWjB,GAAUC,EAC5BvqB,EAAOwrB,WAAajB,EACbvqB,CAAA,GAEV,CACD,YAAA6qB,CAAa7qB,EAAQsqB,GACZtqB,EAAAwrB,WAAaxrB,EAAOurB,WAAWjB,UAC/BtqB,EAAO2qB,WAAWL,UAClBtqB,EAAOurB,WAAWjB,EAC1B,CACD,KAAAoB,GACU51D,QAAA61D,IACN,cACAxsD,KAAKgoC,WAAW1oC,KAAKuhC,GAAWA,EAAOwrB,YAE1C,CACD,OAAApiD,GACE,IAAA,IAAS5S,EAAI,EAAGA,EAAI2I,KAAKgoC,WAAWpwC,SAAUP,EACvC2I,KAAAgoC,WAAW3wC,GAAGoqC,YAGd,OADPzhC,KAAKgoC,WAAWpwC,OAAS,EAClBoI,IACR,EAEH,SAASksD,KACH,IAAA/B,EACAE,EAwFJ,SAASoC,EAAgBC,EAAOnrC,EAASorC,EAAezoC,EAAeokC,EAAe7hC,GAC9E,MAAAmmC,EAAgBnmC,EAAUomC,iBAE1BC,EADYH,EAAcI,aACFH,EACxBjrC,EAAamrC,EAAYxE,EAAcj2B,kBACvC26B,EAWC,SAAiBN,EAAOpE,GAC/B,OAAQA,GACN,KAAKt+B,aACH,OAAO0iC,EAAMO,WACf,KAAKnjC,UACH,OAAO4iC,EAAMQ,QACf,KAAKnjC,WACH,OAAO2iC,EAAMS,SACf,KAAKC,WACH,OAAOV,EAAMW,SACf,KAAKp1D,WACH,OAAOy0D,EAAMY,SACf,KAAKn1D,YACH,OAAOu0D,EAAMa,UACf,KAAKl1D,YACH,OAAOq0D,EAAMc,UAElB,CA5BkBC,CAAiBf,EAAOpE,GACnClR,EAAMsV,EAAMgB,QAAQ/rC,GAC1BJ,EAAQosC,kCAAkChB,EAAelmC,EAAWumC,EAAUrrC,EAAYy1B,GACpF,MAAA31C,EAAQ,IAAI6mD,EAAcoE,EAAMkB,QAAQtsC,OAAQ81B,EAAK0V,GAAWprD,QAE/D,OADPgrD,EAAMmB,MAAMzW,GACL,CACLxgC,KAAMsN,EACNziB,QACA6iB,SAAUsoC,EAEb,CAtGDN,UAAY,SAAS/uD,GACnB,MAAMyzC,EAAUzzC,EAAEI,KAClB,OAAQqzC,EAAQ90C,MACd,IAAK,OACHiuD,EAAgBnZ,EAAQmZ,cACPE,EAAA,IAAI1yC,SAAQ,SAASC,GACtBuyC,EAAA2D,eAAiB,SAASpB,GAC9B90C,EAAA,CAAE80C,SACtB,EACUqB,mBAAmB5D,EAC7B,IACQ,MACF,IAAK,SACH,MAAM7oC,EAAS0vB,EAAQ1vB,OACjBstB,EAAaoC,EAAQpC,WACZyb,EAAA7uC,MAAMwyC,IACnB,MAAMtB,EAAQsB,EAAOtB,MACfnrC,EAAU,IAAImrC,EAAMuB,QACpBC,EAAgB,IAAIxB,EAAMyB,cAChCD,EAAcE,KAAK,IAAItkC,UAAUxI,GAASA,EAAOK,YAC7C,IACF,MAAMnrB,EAgBhB,SAAwBk2D,EAAOnrC,EAAS2sC,EAAetf,GACrD,MAAMic,EAAejc,EAAWic,aAC1BC,EAAiBlc,EAAWkc,eAC9B,IAAA6B,EACA0B,EACE,MAAAC,EAAe/sC,EAAQgtC,uBAAuBL,GAChD,GAAAI,IAAiB5B,EAAM8B,gBACT7B,EAAA,IAAID,EAAMvuD,KACTkwD,EAAA9sC,EAAQktC,mBAAmBP,EAAevB,OACjE,IAAe2B,IAAiB5B,EAAMgC,YAI1B,MAAA,IAAIl5C,MAAM,gDAHAm3C,EAAA,IAAID,EAAMiC,WACTN,EAAA9sC,EAAQqtC,yBAAyBV,EAAevB,EAGlE,CACD,IAAK0B,EAAeQ,MAA8B,IAAtBlC,EAAcvV,IACxC,MAAM,IAAI5hC,MAAM,uCAAyC64C,EAAeS,aAE1E,MAAMt4D,EAAW,CAAEO,MAAO,KAAMisB,WAAY,IAC5C,IAAA,MAAWkB,KAAiB2mC,EAAc,CACxC,MAAMvC,EAAgBl0B,KAAK02B,EAAe5mC,IACtC,IAAAuC,EACAsoC,EACJ,GAAIngB,EAAWmc,aACbgE,EAAclE,EAAa3mC,GACfuC,EAAAlF,EAAQytC,uBAAuBrC,EAAeoC,OACrD,CAEL,GADAA,EAAcxtC,EAAQ0tC,eAAetC,EAAeD,EAAM7B,EAAa3mC,MACnD,IAAhB6qC,EACF,SACUtoC,EAAAlF,EAAQ2tC,aAAavC,EAAeoC,EACjD,CACQv4D,EAAAwsB,WAAWzrB,KAAKk1D,EAAgBC,EAAOnrC,EAASorC,EAAezoC,EAAeokC,EAAe7hC,GACvG,CACG6nC,IAAiB5B,EAAM8B,kBACzBh4D,EAASO,MAKJ,SAAY21D,EAAOnrC,EAASorC,GAC7B,MAAAwC,EAAWxC,EAAcyC,YACzBC,EAAwB,EAAXF,EACbxtC,EAA0B,EAAb0tC,EACbjY,EAAMsV,EAAMgB,QAAQ/rC,GAClBJ,EAAA+tC,wBAAwB3C,EAAehrC,EAAYy1B,GACrD,MAAArgD,EAAQ,IAAIsB,YAAYq0D,EAAMkB,QAAQtsC,OAAQ81B,EAAKiY,GAAY3tD,QAErE,OADAgrD,EAAMmB,MAAMzW,GACL,CAAE31C,MAAO1K,EAAOutB,SAAU,EAClC,CAdoBirC,CAAY7C,EAAOnrC,EAASorC,IAGxC,OADPD,EAAM8C,QAAQ7C,GACPn2D,CACR,CAvD0Bw0D,CAAe0B,EAAOnrC,EAAS2sC,EAAetf,GACzD/c,EAAUr7B,EAASwsB,WAAW1jB,KAAK6kB,GAASA,EAAK1iB,MAAM6f,SACzD9qB,EAASO,OACX86B,EAAQt6B,KAAKf,EAASO,MAAM0K,MAAM6f,QAC/B8S,KAAAkN,YAAY,CAAEplC,KAAM,SAAU0uC,GAAIoG,EAAQpG,GAAIp0C,YAAYq7B,EAChE,OAAQz6B,GACPT,QAAQS,MAAMA,GACTg9B,KAAAkN,YAAY,CAAEplC,KAAM,QAAS0uC,GAAIoG,EAAQpG,GAAIxzC,MAAOA,EAAM45C,SAC3E,CAAoB,QACR0b,EAAM8C,QAAQtB,GACdxB,EAAM8C,QAAQjuC,EACf,KAIX,CAqFA,CCjVA,IAAIkuC,GACC,MAACC,GAAiB,KACjB,GAAAD,GACK,OAAAA,GACT,MAEME,EAAW,IAAI13D,WAAW,CAC9B,EACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,IACA,GACA,EACA,EACA,GACA,EACA,EACA,GACA,EACA,IACA,GACA,GACA,KAEI23D,EAAW,IAAI33D,WAAW,CAC9B,GACA,EACA,GACA,IACA,EACA,EACA,EACA,GACA,EACA,IACA,EACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,IACA,EACA,IACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,MAEE,GAAuB,iBAAhB2tC,YACF,MAAA,CACLpkB,WAAW,GAGf,IAIIwjB,EAJAS,EA1Hc,gsOA2HdG,YAAYiqB,SAASF,KACvBlqB,EA3HgB,ghUA8HZ,MAAA/R,EAAUkS,YAAYC,YAI5B,SAAgBloC,GACd,MAAMwkB,EAAS,IAAIlqB,WAAW0F,EAAK/F,QACnC,IAAA,IAASP,EAAI,EAAGA,EAAIsG,EAAK/F,SAAUP,EAAG,CAC9B,MAAAy4D,EAAKnyD,EAAKoyD,WAAW14D,GAC3B8qB,EAAO9qB,GAAKy4D,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,EAAIA,EAAK,GAAK,GAAK,EACvF,CACD,IAAIE,EAAQ,EACZ,IAAA,IAAS34D,EAAI,EAAGA,EAAIsG,EAAK/F,SAAUP,EACjC8qB,EAAO6tC,KAAW7tC,EAAO9qB,GAAK,GAAKu4D,EAASztC,EAAO9qB,IAAyB,IAAlB8qB,EAAO9qB,GAAK,IAAW8qB,IAAS9qB,GAE5F,OAAO8qB,EAAOb,OAAO5f,MAAM,EAAGsuD,EAC/B,CAfuCC,CAAOxqB,GAAO,IAAIjqB,MAAM2G,IAC9D6iB,EAAW7iB,EAAO6iB,SAClBA,EAASK,QAAQ6qB,uBAcnB,SAASlyD,EAAOmyD,EAAK3uD,EAAQlK,EAAOwmD,EAAMx9B,EAAQ0B,GAC1C,MAAAouC,EAAOprB,EAASK,QAAQ+qB,KACxBC,EAAS/4D,EAAQ,GAAI,EACrBg5D,EAAKF,EAAKC,EAASvS,GACnByS,EAAKH,EAAK9vC,EAAO1oB,QACjBqtC,EAAO,IAAIhtC,WAAW+sC,EAASK,QAAQC,OAAOhkB,QACpD2jB,EAAK1pC,IAAI+kB,EAAQiwC,GACjB,MAAM9uC,EAAM0uC,EAAIG,EAAIh5D,EAAOwmD,EAAMyS,EAAIjwC,EAAO1oB,QAM5C,GALY,IAAR6pB,GAAaO,GACRA,EAAAsuC,EAAID,EAAQvS,GAErBt8C,EAAOjG,IAAI0pC,EAAK7oC,SAASk0D,EAAIA,EAAKh5D,EAAQwmD,IACrCsS,EAAAE,EAAKF,EAAK,IACH,IAAR3uC,EACF,MAAM,IAAIjM,MAAM,0BAA0BiM,IAE7C,CACD,MAAM+uC,EAAU,CAEd,EAAG,GACH,EAAG,0BACH,EAAG,2BACH,EAAG,0BAEH9qD,KAAM,GACN+qD,WAAY,0BACZC,WAAY,2BACZC,YAAa,2BAETC,EAAW,CAEf,EAAG,6BACH,EAAG,4BACH,EAAG,8BAEH1qC,WAAY,6BACZtD,UAAW,4BACXiuC,QAAS,+BAgCJ,OA9BKpB,GAAA,CACVvtC,MAAOwR,EACPlS,WAAW,EACX,kBAAAsvC,CAAmBtvD,EAAQlK,EAAOwmD,EAAMx9B,EAAQ0B,GAC9ChkB,EACEgnC,EAASK,QAAQ0rB,2BACjBvvD,EACAlK,EACAwmD,EACAx9B,EACA0kB,EAASK,QAAQmrB,EAAQxuC,IAE5B,EACD,iBAAAgvC,CAAkBxvD,EAAQlK,EAAOwmD,EAAMx9B,GACrCtiB,EAAOgnC,EAASK,QAAQ4rB,0BAA2BzvD,EAAQlK,EAAOwmD,EAAMx9B,EACzE,EACD,mBAAA4wC,CAAoB1vD,EAAQlK,EAAOwmD,EAAMx9B,GACvCtiB,EAAOgnC,EAASK,QAAQ8rB,4BAA6B3vD,EAAQlK,EAAOwmD,EAAMx9B,EAC3E,EACD,gBAAA8B,CAAiB5gB,EAAQlK,EAAOwmD,EAAMx9B,EAAQyB,EAAMC,GAClDhkB,EACEgnC,EAASK,QAAQurB,EAAS7uC,IAC1BvgB,EACAlK,EACAwmD,EACAx9B,EACA0kB,EAASK,QAAQmrB,EAAQxuC,IAE5B,GAEIytC,EAAA","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}